{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { flushSync, scheduleWork, flushPassiveEffects } from './ReactFiberWorkLoop';\nimport { updateContainerAtExpirationTime } from './ReactFiberReconciler';\nimport { emptyContextObject } from './ReactFiberContext';\nimport { Sync } from './ReactFiberExpirationTime';\nimport { ClassComponent, FunctionComponent, ForwardRef, HostComponent, HostPortal, HostRoot, MemoComponent, SimpleMemoComponent } from 'shared/ReactWorkTags';\nimport { REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nlet resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n\nlet failedBoundaries = null;\nexport let setRefreshHandler = handler => {\n  if (__DEV__) {\n    resolveFamily = handler;\n  }\n};\nexport function resolveFunctionForHotReloading(type) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    let family = resolveFamily(type);\n\n    if (family === undefined) {\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  } else {\n    return type;\n  }\n}\nexport function resolveClassForHotReloading(type) {\n  // No implementation differences.\n  return resolveFunctionForHotReloading(type);\n}\nexport function resolveForwardRefForHotReloading(type) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    let family = resolveFamily(type);\n\n    if (family === undefined) {\n      // Check if we're dealing with a real forwardRef. Don't want to crash early.\n      if (type !== null && type !== undefined && typeof type.render === 'function') {\n        // ForwardRef is special because its resolved .type is an object,\n        // but it's possible that we only have its inner render function in the map.\n        // If that inner render function is different, we'll build a new forwardRef type.\n        const currentRender = resolveFunctionForHotReloading(type.render);\n\n        if (type.render !== currentRender) {\n          const syntheticType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: currentRender\n          };\n\n          if (type.displayName !== undefined) {\n            syntheticType.displayName = type.displayName;\n          }\n\n          return syntheticType;\n        }\n      }\n\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  } else {\n    return type;\n  }\n}\nexport function isCompatibleFamilyForHotReloading(fiber, element) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return false;\n    }\n\n    const prevType = fiber.elementType;\n    const nextType = element.type; // If we got here, we know types aren't === equal.\n\n    let needsCompareFamilies = false;\n    const $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n\n    switch (fiber.tag) {\n      case ClassComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case FunctionComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            // We don't know the inner type yet.\n            // We're going to assume that the lazy inner type is stable,\n            // and so it is sufficient to avoid reconciling it away.\n            // We're not going to unwrap or actually use the new lazy type.\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case ForwardRef:\n        {\n          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ($$typeofNextType === REACT_MEMO_TYPE) {\n            // TODO: if it was but can no longer be simple,\n            // we shouldn't set this.\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      default:\n        return false;\n    } // Check if both types have a family and it's the same one.\n\n\n    if (needsCompareFamilies) {\n      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n      // This means both of them need to be registered to preserve state.\n      // If we unwrapped and compared the inner types for wrappers instead,\n      // then we would risk falsely saying two separate memo(Foo)\n      // calls are equivalent because they wrap the same Foo function.\n      const prevFamily = resolveFamily(prevType);\n\n      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return false;\n  }\n}\nexport function markFailedErrorBoundaryForHotReloading(fiber) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    if (typeof WeakSet !== 'function') {\n      return;\n    }\n\n    if (failedBoundaries === null) {\n      failedBoundaries = new WeakSet();\n    }\n\n    failedBoundaries.add(fiber);\n  }\n}\nexport let scheduleRefresh = (root, update) => {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    const {\n      staleFamilies,\n      updatedFamilies\n    } = update;\n    flushPassiveEffects();\n    flushSync(() => {\n      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n    });\n  }\n};\nexport let scheduleRoot = (root, element) => {\n  if (__DEV__) {\n    if (root.context !== emptyContextObject) {\n      // Super edge case: root has a legacy _renderSubtree context\n      // but we don't know the parentComponent so we can't pass it.\n      // Just ignore. We'll delete this with _renderSubtree code path later.\n      return;\n    }\n\n    flushPassiveEffects();\n    updateContainerAtExpirationTime(element, root, null, Sync, null);\n  }\n};\n\nfunction scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n  if (__DEV__) {\n    const {\n      alternate,\n      child,\n      sibling,\n      tag,\n      type\n    } = fiber;\n    let candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n\n      default:\n        break;\n    }\n\n    if (resolveFamily === null) {\n      throw new Error('Expected resolveFamily to be set during hot reload.');\n    }\n\n    let needsRender = false;\n    let needsRemount = false;\n\n    if (candidateType !== null) {\n      const family = resolveFamily(candidateType);\n\n      if (family !== undefined) {\n        if (staleFamilies.has(family)) {\n          needsRemount = true;\n        } else if (updatedFamilies.has(family)) {\n          needsRender = true;\n        }\n      }\n    }\n\n    if (failedBoundaries !== null) {\n      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n        needsRemount = true;\n      }\n    }\n\n    if (needsRemount) {\n      fiber._debugNeedsRemount = true;\n    }\n\n    if (needsRemount || needsRender) {\n      scheduleWork(fiber, Sync);\n    }\n\n    if (child !== null && !needsRemount) {\n      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n    }\n\n    if (sibling !== null) {\n      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n  }\n}\n\nexport let findHostInstancesForRefresh = (root, families) => {\n  if (__DEV__) {\n    const hostInstances = new Set();\n    const types = new Set(families.map(family => family.current));\n    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n    return hostInstances;\n  } else {\n    throw new Error('Did not expect findHostInstancesForRefresh to be called in production.');\n  }\n};\n\nfunction findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n  if (__DEV__) {\n    const {\n      child,\n      sibling,\n      tag,\n      type\n    } = fiber;\n    let candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n\n      default:\n        break;\n    }\n\n    let didMatch = false;\n\n    if (candidateType !== null) {\n      if (types.has(candidateType)) {\n        didMatch = true;\n      }\n    }\n\n    if (didMatch) {\n      // We have a match. This only drills down to the closest host components.\n      // There's no need to search deeper because for the purpose of giving\n      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n      findHostInstancesForFiberShallowly(fiber, hostInstances);\n    } else {\n      // If there's no match, maybe there will be one further down in the child tree.\n      if (child !== null) {\n        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n      }\n    }\n\n    if (sibling !== null) {\n      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n    }\n  }\n}\n\nfunction findHostInstancesForFiberShallowly(fiber, hostInstances) {\n  if (__DEV__) {\n    const foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n\n    if (foundHostInstances) {\n      return;\n    } // If we didn't find any host children, fallback to closest host parent.\n\n\n    let node = fiber;\n\n    while (true) {\n      switch (node.tag) {\n        case HostComponent:\n          hostInstances.add(node.stateNode);\n          return;\n\n        case HostPortal:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n\n        case HostRoot:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n      }\n\n      if (node.return === null) {\n        throw new Error('Expected to reach root first.');\n      }\n\n      node = node.return;\n    }\n  }\n}\n\nfunction findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n  if (__DEV__) {\n    let node = fiber;\n    let foundHostInstances = false;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        // We got a match.\n        foundHostInstances = true;\n        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return foundHostInstances;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === fiber) {\n          return foundHostInstances;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberHotReloading.js"],"names":["flushSync","scheduleWork","flushPassiveEffects","updateContainerAtExpirationTime","emptyContextObject","Sync","ClassComponent","FunctionComponent","ForwardRef","HostComponent","HostPortal","HostRoot","MemoComponent","SimpleMemoComponent","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","resolveFamily","failedBoundaries","setRefreshHandler","handler","__DEV__","resolveFunctionForHotReloading","type","family","undefined","current","resolveClassForHotReloading","resolveForwardRefForHotReloading","render","currentRender","syntheticType","$$typeof","displayName","isCompatibleFamilyForHotReloading","fiber","element","prevType","elementType","nextType","needsCompareFamilies","$$typeofNextType","tag","prevFamily","markFailedErrorBoundaryForHotReloading","WeakSet","add","scheduleRefresh","root","update","staleFamilies","updatedFamilies","scheduleFibersWithFamiliesRecursively","scheduleRoot","context","alternate","child","sibling","candidateType","Error","needsRender","needsRemount","has","_debugNeedsRemount","findHostInstancesForRefresh","families","hostInstances","Set","types","map","findHostInstancesForMatchingFibersRecursively","didMatch","findHostInstancesForFiberShallowly","foundHostInstances","findChildHostInstancesForFiberShallowly","node","stateNode","containerInfo","return"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactElement} from 'shared/ReactElementType';\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {Instance} from './ReactFiberHostConfig';\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport {\n  flushSync,\n  scheduleWork,\n  flushPassiveEffects,\n} from './ReactFiberWorkLoop';\nimport {updateContainerAtExpirationTime} from './ReactFiberReconciler';\nimport {emptyContextObject} from './ReactFiberContext';\nimport {Sync} from './ReactFiberExpirationTime';\nimport {\n  ClassComponent,\n  FunctionComponent,\n  ForwardRef,\n  HostComponent,\n  HostPortal,\n  HostRoot,\n  MemoComponent,\n  SimpleMemoComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\n\nexport type Family = {|\n  current: any,\n|};\n\nexport type RefreshUpdate = {|\n  staleFamilies: Set<Family>,\n  updatedFamilies: Set<Family>,\n|};\n\n// Resolves type to a family.\ntype RefreshHandler = any => Family | void;\n\n// Used by React Refresh runtime through DevTools Global Hook.\nexport type SetRefreshHandler = (handler: RefreshHandler | null) => void;\nexport type ScheduleRefresh = (root: FiberRoot, update: RefreshUpdate) => void;\nexport type ScheduleRoot = (root: FiberRoot, element: ReactNodeList) => void;\nexport type FindHostInstancesForRefresh = (\n  root: FiberRoot,\n  families: Array<Family>,\n) => Set<Instance>;\n\nlet resolveFamily: RefreshHandler | null = null;\n// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nlet failedBoundaries: WeakSet<Fiber> | null = null;\n\nexport let setRefreshHandler = (handler: RefreshHandler | null): void => {\n  if (__DEV__) {\n    resolveFamily = handler;\n  }\n};\n\nexport function resolveFunctionForHotReloading(type: any): any {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n    let family = resolveFamily(type);\n    if (family === undefined) {\n      return type;\n    }\n    // Use the latest known implementation.\n    return family.current;\n  } else {\n    return type;\n  }\n}\n\nexport function resolveClassForHotReloading(type: any): any {\n  // No implementation differences.\n  return resolveFunctionForHotReloading(type);\n}\n\nexport function resolveForwardRefForHotReloading(type: any): any {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n    let family = resolveFamily(type);\n    if (family === undefined) {\n      // Check if we're dealing with a real forwardRef. Don't want to crash early.\n      if (\n        type !== null &&\n        type !== undefined &&\n        typeof type.render === 'function'\n      ) {\n        // ForwardRef is special because its resolved .type is an object,\n        // but it's possible that we only have its inner render function in the map.\n        // If that inner render function is different, we'll build a new forwardRef type.\n        const currentRender = resolveFunctionForHotReloading(type.render);\n        if (type.render !== currentRender) {\n          const syntheticType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: currentRender,\n          };\n          if (type.displayName !== undefined) {\n            (syntheticType: any).displayName = type.displayName;\n          }\n          return syntheticType;\n        }\n      }\n      return type;\n    }\n    // Use the latest known implementation.\n    return family.current;\n  } else {\n    return type;\n  }\n}\n\nexport function isCompatibleFamilyForHotReloading(\n  fiber: Fiber,\n  element: ReactElement,\n): boolean {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return false;\n    }\n\n    const prevType = fiber.elementType;\n    const nextType = element.type;\n\n    // If we got here, we know types aren't === equal.\n    let needsCompareFamilies = false;\n\n    const $$typeofNextType =\n      typeof nextType === 'object' && nextType !== null\n        ? nextType.$$typeof\n        : null;\n\n    switch (fiber.tag) {\n      case ClassComponent: {\n        if (typeof nextType === 'function') {\n          needsCompareFamilies = true;\n        }\n        break;\n      }\n      case FunctionComponent: {\n        if (typeof nextType === 'function') {\n          needsCompareFamilies = true;\n        } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n          // We don't know the inner type yet.\n          // We're going to assume that the lazy inner type is stable,\n          // and so it is sufficient to avoid reconciling it away.\n          // We're not going to unwrap or actually use the new lazy type.\n          needsCompareFamilies = true;\n        }\n        break;\n      }\n      case ForwardRef: {\n        if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n          needsCompareFamilies = true;\n        } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n          needsCompareFamilies = true;\n        }\n        break;\n      }\n      case MemoComponent:\n      case SimpleMemoComponent: {\n        if ($$typeofNextType === REACT_MEMO_TYPE) {\n          // TODO: if it was but can no longer be simple,\n          // we shouldn't set this.\n          needsCompareFamilies = true;\n        } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n          needsCompareFamilies = true;\n        }\n        break;\n      }\n      default:\n        return false;\n    }\n\n    // Check if both types have a family and it's the same one.\n    if (needsCompareFamilies) {\n      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n      // This means both of them need to be registered to preserve state.\n      // If we unwrapped and compared the inner types for wrappers instead,\n      // then we would risk falsely saying two separate memo(Foo)\n      // calls are equivalent because they wrap the same Foo function.\n      const prevFamily = resolveFamily(prevType);\n      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return false;\n  }\n}\n\nexport function markFailedErrorBoundaryForHotReloading(fiber: Fiber) {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n    if (typeof WeakSet !== 'function') {\n      return;\n    }\n    if (failedBoundaries === null) {\n      failedBoundaries = new WeakSet();\n    }\n    failedBoundaries.add(fiber);\n  }\n}\n\nexport let scheduleRefresh: ScheduleRefresh = (\n  root: FiberRoot,\n  update: RefreshUpdate,\n): void => {\n  if (__DEV__) {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n    const {staleFamilies, updatedFamilies} = update;\n    flushPassiveEffects();\n    flushSync(() => {\n      scheduleFibersWithFamiliesRecursively(\n        root.current,\n        updatedFamilies,\n        staleFamilies,\n      );\n    });\n  }\n};\n\nexport let scheduleRoot: ScheduleRoot = (\n  root: FiberRoot,\n  element: ReactNodeList,\n): void => {\n  if (__DEV__) {\n    if (root.context !== emptyContextObject) {\n      // Super edge case: root has a legacy _renderSubtree context\n      // but we don't know the parentComponent so we can't pass it.\n      // Just ignore. We'll delete this with _renderSubtree code path later.\n      return;\n    }\n    flushPassiveEffects();\n    updateContainerAtExpirationTime(element, root, null, Sync, null);\n  }\n};\n\nfunction scheduleFibersWithFamiliesRecursively(\n  fiber: Fiber,\n  updatedFamilies: Set<Family>,\n  staleFamilies: Set<Family>,\n) {\n  if (__DEV__) {\n    const {alternate, child, sibling, tag, type} = fiber;\n\n    let candidateType = null;\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n      default:\n        break;\n    }\n\n    if (resolveFamily === null) {\n      throw new Error('Expected resolveFamily to be set during hot reload.');\n    }\n\n    let needsRender = false;\n    let needsRemount = false;\n    if (candidateType !== null) {\n      const family = resolveFamily(candidateType);\n      if (family !== undefined) {\n        if (staleFamilies.has(family)) {\n          needsRemount = true;\n        } else if (updatedFamilies.has(family)) {\n          needsRender = true;\n        }\n      }\n    }\n    if (failedBoundaries !== null) {\n      if (\n        failedBoundaries.has(fiber) ||\n        (alternate !== null && failedBoundaries.has(alternate))\n      ) {\n        needsRemount = true;\n      }\n    }\n\n    if (needsRemount) {\n      fiber._debugNeedsRemount = true;\n    }\n    if (needsRemount || needsRender) {\n      scheduleWork(fiber, Sync);\n    }\n    if (child !== null && !needsRemount) {\n      scheduleFibersWithFamiliesRecursively(\n        child,\n        updatedFamilies,\n        staleFamilies,\n      );\n    }\n    if (sibling !== null) {\n      scheduleFibersWithFamiliesRecursively(\n        sibling,\n        updatedFamilies,\n        staleFamilies,\n      );\n    }\n  }\n}\n\nexport let findHostInstancesForRefresh: FindHostInstancesForRefresh = (\n  root: FiberRoot,\n  families: Array<Family>,\n): Set<Instance> => {\n  if (__DEV__) {\n    const hostInstances = new Set();\n    const types = new Set(families.map(family => family.current));\n    findHostInstancesForMatchingFibersRecursively(\n      root.current,\n      types,\n      hostInstances,\n    );\n    return hostInstances;\n  } else {\n    throw new Error(\n      'Did not expect findHostInstancesForRefresh to be called in production.',\n    );\n  }\n};\n\nfunction findHostInstancesForMatchingFibersRecursively(\n  fiber: Fiber,\n  types: Set<any>,\n  hostInstances: Set<Instance>,\n) {\n  if (__DEV__) {\n    const {child, sibling, tag, type} = fiber;\n\n    let candidateType = null;\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n      default:\n        break;\n    }\n\n    let didMatch = false;\n    if (candidateType !== null) {\n      if (types.has(candidateType)) {\n        didMatch = true;\n      }\n    }\n\n    if (didMatch) {\n      // We have a match. This only drills down to the closest host components.\n      // There's no need to search deeper because for the purpose of giving\n      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n      findHostInstancesForFiberShallowly(fiber, hostInstances);\n    } else {\n      // If there's no match, maybe there will be one further down in the child tree.\n      if (child !== null) {\n        findHostInstancesForMatchingFibersRecursively(\n          child,\n          types,\n          hostInstances,\n        );\n      }\n    }\n\n    if (sibling !== null) {\n      findHostInstancesForMatchingFibersRecursively(\n        sibling,\n        types,\n        hostInstances,\n      );\n    }\n  }\n}\n\nfunction findHostInstancesForFiberShallowly(\n  fiber: Fiber,\n  hostInstances: Set<Instance>,\n): void {\n  if (__DEV__) {\n    const foundHostInstances = findChildHostInstancesForFiberShallowly(\n      fiber,\n      hostInstances,\n    );\n    if (foundHostInstances) {\n      return;\n    }\n    // If we didn't find any host children, fallback to closest host parent.\n    let node = fiber;\n    while (true) {\n      switch (node.tag) {\n        case HostComponent:\n          hostInstances.add(node.stateNode);\n          return;\n        case HostPortal:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n        case HostRoot:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n      }\n      if (node.return === null) {\n        throw new Error('Expected to reach root first.');\n      }\n      node = node.return;\n    }\n  }\n}\n\nfunction findChildHostInstancesForFiberShallowly(\n  fiber: Fiber,\n  hostInstances: Set<Instance>,\n): boolean {\n  if (__DEV__) {\n    let node: Fiber = fiber;\n    let foundHostInstances = false;\n    while (true) {\n      if (node.tag === HostComponent) {\n        // We got a match.\n        foundHostInstances = true;\n        hostInstances.add(node.stateNode);\n        // There may still be more, so keep searching.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === fiber) {\n        return foundHostInstances;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === fiber) {\n          return foundHostInstances;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}