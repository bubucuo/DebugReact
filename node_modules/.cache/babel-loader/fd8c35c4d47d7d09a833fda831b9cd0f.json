{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { accumulateTwoPhaseDispatches } from 'legacy-events/EventPropagators';\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport SyntheticEvent from 'legacy-events/SyntheticEvent';\nimport isTextInputElement from 'shared/isTextInputElement';\nimport shallowEqual from 'shared/shallowEqual';\nimport { TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE } from './DOMTopLevelEventTypes';\nimport { isListeningToAllDependencies } from './ReactBrowserEventEmitter';\nimport getActiveElement from '../client/getActiveElement';\nimport { getNodeFromInstance } from '../client/ReactDOMComponentTree';\nimport { hasSelectionCapabilities } from '../client/ReactInputSelection';\nimport { DOCUMENT_NODE } from '../shared/HTMLNodeType';\nconst skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;\nconst eventTypes = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]\n  }\n};\nlet activeElement = null;\nlet activeElementInst = null;\nlet lastSelection = null;\nlet mouseDown = false;\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\n\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else {\n    const win = node.ownerDocument && node.ownerDocument.defaultView || window;\n    const selection = win.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n/**\n * Get document associated with the event target.\n *\n * @param {object} nativeEventTarget\n * @return {Document}\n */\n\n\nfunction getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n}\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */\n\n\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  const doc = getEventTargetDocument(nativeEventTarget);\n\n  if (mouseDown || activeElement == null || activeElement !== getActiveElement(doc)) {\n    return null;\n  } // Only fire when selection has actually changed.\n\n\n  const currentSelection = getSelection(activeElement);\n\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n    const syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement;\n    accumulateTwoPhaseDispatches(syntheticEvent);\n    return syntheticEvent;\n  }\n\n  return null;\n}\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\n\n\nconst SelectEventPlugin = {\n  eventTypes: eventTypes,\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    const doc = getEventTargetDocument(nativeEventTarget); // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case TOP_FOCUS:\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement = targetNode;\n          activeElementInst = targetInst;\n          lastSelection = null;\n        }\n\n        break;\n\n      case TOP_BLUR:\n        activeElement = null;\n        activeElementInst = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n\n      case TOP_MOUSE_DOWN:\n        mouseDown = true;\n        break;\n\n      case TOP_CONTEXT_MENU:\n      case TOP_MOUSE_UP:\n      case TOP_DRAG_END:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n\n      case TOP_SELECTION_CHANGE:\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n\n      // falls through\n\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\nexport default SelectEventPlugin;","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/SelectEventPlugin.js"],"names":["accumulateTwoPhaseDispatches","canUseDOM","SyntheticEvent","isTextInputElement","shallowEqual","TOP_BLUR","TOP_CONTEXT_MENU","TOP_DRAG_END","TOP_FOCUS","TOP_KEY_DOWN","TOP_KEY_UP","TOP_MOUSE_DOWN","TOP_MOUSE_UP","TOP_SELECTION_CHANGE","isListeningToAllDependencies","getActiveElement","getNodeFromInstance","hasSelectionCapabilities","DOCUMENT_NODE","skipSelectionChangeEvent","document","documentMode","eventTypes","select","phasedRegistrationNames","bubbled","captured","dependencies","activeElement","activeElementInst","lastSelection","mouseDown","getSelection","node","start","selectionStart","end","selectionEnd","win","ownerDocument","defaultView","window","selection","anchorNode","anchorOffset","focusNode","focusOffset","getEventTargetDocument","eventTarget","nodeType","constructSelectEvent","nativeEvent","nativeEventTarget","doc","currentSelection","syntheticEvent","getPooled","type","target","SelectEventPlugin","extractEvents","topLevelType","targetInst","targetNode","contentEditable"],"mappings":"AAAA;;;;;;AAOA,SAAQA,4BAAR,QAA2C,gCAA3C;AACA,SAAQC,SAAR,QAAwB,6BAAxB;AACA,OAAOC,cAAP,MAA2B,8BAA3B;AACA,OAAOC,kBAAP,MAA+B,2BAA/B;AACA,OAAOC,YAAP,MAAyB,qBAAzB;AAEA,SACEC,QADF,EAEEC,gBAFF,EAGEC,YAHF,EAIEC,SAJF,EAKEC,YALF,EAMEC,UANF,EAOEC,cAPF,EAQEC,YARF,EASEC,oBATF,QAUO,yBAVP;AAWA,SAAQC,4BAAR,QAA2C,4BAA3C;AACA,OAAOC,gBAAP,MAA6B,4BAA7B;AACA,SAAQC,mBAAR,QAAkC,iCAAlC;AACA,SAAQC,wBAAR,QAAuC,+BAAvC;AACA,SAAQC,aAAR,QAA4B,wBAA5B;AAEA,MAAMC,wBAAwB,GAC5BlB,SAAS,IAAI,kBAAkBmB,QAA/B,IAA2CA,QAAQ,CAACC,YAAT,IAAyB,EADtE;AAGA,MAAMC,UAAU,GAAG;AACjBC,EAAAA,MAAM,EAAE;AACNC,IAAAA,uBAAuB,EAAE;AACvBC,MAAAA,OAAO,EAAE,UADc;AAEvBC,MAAAA,QAAQ,EAAE;AAFa,KADnB;AAKNC,IAAAA,YAAY,EAAE,CACZtB,QADY,EAEZC,gBAFY,EAGZC,YAHY,EAIZC,SAJY,EAKZC,YALY,EAMZC,UANY,EAOZC,cAPY,EAQZC,YARY,EASZC,oBATY;AALR;AADS,CAAnB;AAoBA,IAAIe,aAAa,GAAG,IAApB;AACA,IAAIC,iBAAiB,GAAG,IAAxB;AACA,IAAIC,aAAa,GAAG,IAApB;AACA,IAAIC,SAAS,GAAG,KAAhB;AAEA;;;;;;;;;;AASA,SAASC,YAAT,CAAsBC,IAAtB,EAA4B;AAC1B,MAAI,oBAAoBA,IAApB,IAA4BhB,wBAAwB,CAACgB,IAAD,CAAxD,EAAgE;AAC9D,WAAO;AACLC,MAAAA,KAAK,EAAED,IAAI,CAACE,cADP;AAELC,MAAAA,GAAG,EAAEH,IAAI,CAACI;AAFL,KAAP;AAID,GALD,MAKO;AACL,UAAMC,GAAG,GACNL,IAAI,CAACM,aAAL,IAAsBN,IAAI,CAACM,aAAL,CAAmBC,WAA1C,IAA0DC,MAD5D;AAEA,UAAMC,SAAS,GAAGJ,GAAG,CAACN,YAAJ,EAAlB;AACA,WAAO;AACLW,MAAAA,UAAU,EAAED,SAAS,CAACC,UADjB;AAELC,MAAAA,YAAY,EAAEF,SAAS,CAACE,YAFnB;AAGLC,MAAAA,SAAS,EAAEH,SAAS,CAACG,SAHhB;AAILC,MAAAA,WAAW,EAAEJ,SAAS,CAACI;AAJlB,KAAP;AAMD;AACF;AAED;;;;;;;;AAMA,SAASC,sBAAT,CAAgCC,WAAhC,EAA6C;AAC3C,SAAOA,WAAW,CAACP,MAAZ,KAAuBO,WAAvB,GACHA,WAAW,CAAC5B,QADT,GAEH4B,WAAW,CAACC,QAAZ,KAAyB/B,aAAzB,GACE8B,WADF,GAEEA,WAAW,CAACT,aAJlB;AAKD;AAED;;;;;;;;;AAOA,SAASW,oBAAT,CAA8BC,WAA9B,EAA2CC,iBAA3C,EAA8D;AAC5D;AACA;AACA;AACA;AACA,QAAMC,GAAG,GAAGN,sBAAsB,CAACK,iBAAD,CAAlC;;AAEA,MACErB,SAAS,IACTH,aAAa,IAAI,IADjB,IAEAA,aAAa,KAAKb,gBAAgB,CAACsC,GAAD,CAHpC,EAIE;AACA,WAAO,IAAP;AACD,GAb2D,CAe5D;;;AACA,QAAMC,gBAAgB,GAAGtB,YAAY,CAACJ,aAAD,CAArC;;AACA,MAAI,CAACE,aAAD,IAAkB,CAAC1B,YAAY,CAAC0B,aAAD,EAAgBwB,gBAAhB,CAAnC,EAAsE;AACpExB,IAAAA,aAAa,GAAGwB,gBAAhB;AAEA,UAAMC,cAAc,GAAGrD,cAAc,CAACsD,SAAf,CACrBlC,UAAU,CAACC,MADU,EAErBM,iBAFqB,EAGrBsB,WAHqB,EAIrBC,iBAJqB,CAAvB;AAOAG,IAAAA,cAAc,CAACE,IAAf,GAAsB,QAAtB;AACAF,IAAAA,cAAc,CAACG,MAAf,GAAwB9B,aAAxB;AAEA5B,IAAAA,4BAA4B,CAACuD,cAAD,CAA5B;AAEA,WAAOA,cAAP;AACD;;AAED,SAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;;;AAcA,MAAMI,iBAAiB,GAAG;AACxBrC,EAAAA,UAAU,EAAEA,UADY;AAGxBsC,EAAAA,aAAa,EAAE,UACbC,YADa,EAEbC,UAFa,EAGbX,WAHa,EAIbC,iBAJa,EAKb;AACA,UAAMC,GAAG,GAAGN,sBAAsB,CAACK,iBAAD,CAAlC,CADA,CAEA;AACA;;AACA,QAAI,CAACC,GAAD,IAAQ,CAACvC,4BAA4B,CAAC,UAAD,EAAauC,GAAb,CAAzC,EAA4D;AAC1D,aAAO,IAAP;AACD;;AAED,UAAMU,UAAU,GAAGD,UAAU,GAAG9C,mBAAmB,CAAC8C,UAAD,CAAtB,GAAqCrB,MAAlE;;AAEA,YAAQoB,YAAR;AACE;AACA,WAAKrD,SAAL;AACE,YACEL,kBAAkB,CAAC4D,UAAD,CAAlB,IACAA,UAAU,CAACC,eAAX,KAA+B,MAFjC,EAGE;AACApC,UAAAA,aAAa,GAAGmC,UAAhB;AACAlC,UAAAA,iBAAiB,GAAGiC,UAApB;AACAhC,UAAAA,aAAa,GAAG,IAAhB;AACD;;AACD;;AACF,WAAKzB,QAAL;AACEuB,QAAAA,aAAa,GAAG,IAAhB;AACAC,QAAAA,iBAAiB,GAAG,IAApB;AACAC,QAAAA,aAAa,GAAG,IAAhB;AACA;AACF;AACA;;AACA,WAAKnB,cAAL;AACEoB,QAAAA,SAAS,GAAG,IAAZ;AACA;;AACF,WAAKzB,gBAAL;AACA,WAAKM,YAAL;AACA,WAAKL,YAAL;AACEwB,QAAAA,SAAS,GAAG,KAAZ;AACA,eAAOmB,oBAAoB,CAACC,WAAD,EAAcC,iBAAd,CAA3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAKvC,oBAAL;AACE,YAAIM,wBAAJ,EAA8B;AAC5B;AACD;;AACH;;AACA,WAAKV,YAAL;AACA,WAAKC,UAAL;AACE,eAAOwC,oBAAoB,CAACC,WAAD,EAAcC,iBAAd,CAA3B;AA3CJ;;AA8CA,WAAO,IAAP;AACD;AAjEuB,CAA1B;AAoEA,eAAeO,iBAAf","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {accumulateTwoPhaseDispatches} from 'legacy-events/EventPropagators';\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\nimport SyntheticEvent from 'legacy-events/SyntheticEvent';\nimport isTextInputElement from 'shared/isTextInputElement';\nimport shallowEqual from 'shared/shallowEqual';\n\nimport {\n  TOP_BLUR,\n  TOP_CONTEXT_MENU,\n  TOP_DRAG_END,\n  TOP_FOCUS,\n  TOP_KEY_DOWN,\n  TOP_KEY_UP,\n  TOP_MOUSE_DOWN,\n  TOP_MOUSE_UP,\n  TOP_SELECTION_CHANGE,\n} from './DOMTopLevelEventTypes';\nimport {isListeningToAllDependencies} from './ReactBrowserEventEmitter';\nimport getActiveElement from '../client/getActiveElement';\nimport {getNodeFromInstance} from '../client/ReactDOMComponentTree';\nimport {hasSelectionCapabilities} from '../client/ReactInputSelection';\nimport {DOCUMENT_NODE} from '../shared/HTMLNodeType';\n\nconst skipSelectionChangeEvent =\n  canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nconst eventTypes = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture',\n    },\n    dependencies: [\n      TOP_BLUR,\n      TOP_CONTEXT_MENU,\n      TOP_DRAG_END,\n      TOP_FOCUS,\n      TOP_KEY_DOWN,\n      TOP_KEY_UP,\n      TOP_MOUSE_DOWN,\n      TOP_MOUSE_UP,\n      TOP_SELECTION_CHANGE,\n    ],\n  },\n};\n\nlet activeElement = null;\nlet activeElementInst = null;\nlet lastSelection = null;\nlet mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd,\n    };\n  } else {\n    const win =\n      (node.ownerDocument && node.ownerDocument.defaultView) || window;\n    const selection = win.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset,\n    };\n  }\n}\n\n/**\n * Get document associated with the event target.\n *\n * @param {object} nativeEventTarget\n * @return {Document}\n */\nfunction getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget\n    ? eventTarget.document\n    : eventTarget.nodeType === DOCUMENT_NODE\n      ? eventTarget\n      : eventTarget.ownerDocument;\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  const doc = getEventTargetDocument(nativeEventTarget);\n\n  if (\n    mouseDown ||\n    activeElement == null ||\n    activeElement !== getActiveElement(doc)\n  ) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  const currentSelection = getSelection(activeElement);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    const syntheticEvent = SyntheticEvent.getPooled(\n      eventTypes.select,\n      activeElementInst,\n      nativeEvent,\n      nativeEventTarget,\n    );\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nconst SelectEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n  ) {\n    const doc = getEventTargetDocument(nativeEventTarget);\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case TOP_FOCUS:\n        if (\n          isTextInputElement(targetNode) ||\n          targetNode.contentEditable === 'true'\n        ) {\n          activeElement = targetNode;\n          activeElementInst = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case TOP_BLUR:\n        activeElement = null;\n        activeElementInst = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case TOP_MOUSE_DOWN:\n        mouseDown = true;\n        break;\n      case TOP_CONTEXT_MENU:\n      case TOP_MOUSE_UP:\n      case TOP_DRAG_END:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case TOP_SELECTION_CHANGE:\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  },\n};\n\nexport default SelectEventPlugin;\n"]},"metadata":{},"sourceType":"module"}