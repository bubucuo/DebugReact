{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { SuspenseComponent, SuspenseListComponent } from 'shared/ReactWorkTags';\nimport { NoEffect, DidCapture } from 'shared/ReactSideEffectTags';\nimport { isSuspenseInstancePending, isSuspenseInstanceFallback } from './ReactFiberHostConfig';\nexport function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  const nextState = workInProgress.memoizedState;\n\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n\n    return false;\n  }\n\n  const props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.\n\n  if (props.fallback === undefined) {\n    return false;\n  } // Regular boundaries always capture.\n\n\n  if (props.unstable_avoidThisFallback !== true) {\n    return true;\n  } // If it's a boundary we should avoid, then we prefer to bubble up to the\n  // parent boundary if it is currently invisible.\n\n\n  if (hasInvisibleParent) {\n    return false;\n  } // If the parent is not able to handle it, we must handle it.\n\n\n  return true;\n}\nexport function findFirstSuspended(row) {\n  let node = row;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        const dehydrated = state.dehydrated;\n\n        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n          return node;\n        }\n      }\n    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n    // keep track of whether it suspended or not.\n    node.memoizedProps.revealOrder !== undefined) {\n      let didSuspend = (node.effectTag & DidCapture) !== NoEffect;\n\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === row) {\n      return null;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberSuspenseComponent.js"],"names":["SuspenseComponent","SuspenseListComponent","NoEffect","DidCapture","isSuspenseInstancePending","isSuspenseInstanceFallback","shouldCaptureSuspense","workInProgress","hasInvisibleParent","nextState","memoizedState","dehydrated","props","memoizedProps","fallback","undefined","unstable_avoidThisFallback","findFirstSuspended","row","node","tag","state","revealOrder","didSuspend","effectTag","child","return","sibling"],"mappings":"AAAA;;;;;;;;AAYA,SAAQA,iBAAR,EAA2BC,qBAA3B,QAAuD,sBAAvD;AACA,SAAQC,QAAR,EAAkBC,UAAlB,QAAmC,4BAAnC;AACA,SACEC,yBADF,EAEEC,0BAFF,QAGO,wBAHP;AAgDA,OAAO,SAASC,qBAAT,CACLC,cADK,EAELC,kBAFK,EAGI;AACT;AACA;AACA,QAAMC,SAA+B,GAAGF,cAAc,CAACG,aAAvD;;AACA,MAAID,SAAS,KAAK,IAAlB,EAAwB;AACtB,QAAIA,SAAS,CAACE,UAAV,KAAyB,IAA7B,EAAmC;AACjC;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AACD,QAAMC,KAAK,GAAGL,cAAc,CAACM,aAA7B,CAXS,CAYT;;AACA,MAAID,KAAK,CAACE,QAAN,KAAmBC,SAAvB,EAAkC;AAChC,WAAO,KAAP;AACD,GAfQ,CAgBT;;;AACA,MAAIH,KAAK,CAACI,0BAAN,KAAqC,IAAzC,EAA+C;AAC7C,WAAO,IAAP;AACD,GAnBQ,CAoBT;AACA;;;AACA,MAAIR,kBAAJ,EAAwB;AACtB,WAAO,KAAP;AACD,GAxBQ,CAyBT;;;AACA,SAAO,IAAP;AACD;AAED,OAAO,SAASS,kBAAT,CAA4BC,GAA5B,EAAsD;AAC3D,MAAIC,IAAI,GAAGD,GAAX;;AACA,SAAOC,IAAI,KAAK,IAAhB,EAAsB;AACpB,QAAIA,IAAI,CAACC,GAAL,KAAapB,iBAAjB,EAAoC;AAClC,YAAMqB,KAA2B,GAAGF,IAAI,CAACT,aAAzC;;AACA,UAAIW,KAAK,KAAK,IAAd,EAAoB;AAClB,cAAMV,UAAmC,GAAGU,KAAK,CAACV,UAAlD;;AACA,YACEA,UAAU,KAAK,IAAf,IACAP,yBAAyB,CAACO,UAAD,CADzB,IAEAN,0BAA0B,CAACM,UAAD,CAH5B,EAIE;AACA,iBAAOQ,IAAP;AACD;AACF;AACF,KAZD,MAYO,IACLA,IAAI,CAACC,GAAL,KAAanB,qBAAb,IACA;AACA;AACAkB,IAAAA,IAAI,CAACN,aAAL,CAAmBS,WAAnB,KAAmCP,SAJ9B,EAKL;AACA,UAAIQ,UAAU,GAAG,CAACJ,IAAI,CAACK,SAAL,GAAiBrB,UAAlB,MAAkCD,QAAnD;;AACA,UAAIqB,UAAJ,EAAgB;AACd,eAAOJ,IAAP;AACD;AACF,KAVM,MAUA,IAAIA,IAAI,CAACM,KAAL,KAAe,IAAnB,EAAyB;AAC9BN,MAAAA,IAAI,CAACM,KAAL,CAAWC,MAAX,GAAoBP,IAApB;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACM,KAAZ;AACA;AACD;;AACD,QAAIN,IAAI,KAAKD,GAAb,EAAkB;AAChB,aAAO,IAAP;AACD;;AACD,WAAOC,IAAI,CAACQ,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAIR,IAAI,CAACO,MAAL,KAAgB,IAAhB,IAAwBP,IAAI,CAACO,MAAL,KAAgBR,GAA5C,EAAiD;AAC/C,eAAO,IAAP;AACD;;AACDC,MAAAA,IAAI,GAAGA,IAAI,CAACO,MAAZ;AACD;;AACDP,IAAAA,IAAI,CAACQ,OAAL,CAAaD,MAAb,GAAsBP,IAAI,CAACO,MAA3B;AACAP,IAAAA,IAAI,GAAGA,IAAI,CAACQ,OAAZ;AACD;;AACD,SAAO,IAAP;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport {SuspenseComponent, SuspenseListComponent} from 'shared/ReactWorkTags';\nimport {NoEffect, DidCapture} from 'shared/ReactSideEffectTags';\nimport {\n  isSuspenseInstancePending,\n  isSuspenseInstanceFallback,\n} from './ReactFiberHostConfig';\n\nexport type SuspenseHydrationCallbacks = {\n  onHydrated?: (suspenseInstance: SuspenseInstance) => void,\n  onDeleted?: (suspenseInstance: SuspenseInstance) => void,\n};\n\n// A null SuspenseState represents an unsuspended normal Suspense boundary.\n// A non-null SuspenseState means that it is blocked for one reason or another.\n// - A non-null dehydrated field means it's blocked pending hydration.\n//   - A non-null dehydrated field can use isSuspenseInstancePending or\n//     isSuspenseInstanceFallback to query the reason for being dehydrated.\n// - A null dehydrated field means it's blocked by something suspending and\n//   we're currently showing a fallback instead.\nexport type SuspenseState = {|\n  // If this boundary is still dehydrated, we store the SuspenseInstance\n  // here to indicate that it is dehydrated (flag) and for quick access\n  // to check things like isSuspenseInstancePending.\n  dehydrated: null | SuspenseInstance,\n  // Represents the earliest expiration time we should attempt to hydrate\n  // a dehydrated boundary at.\n  // Never is the default for dehydrated boundaries.\n  // NoWork is the default for normal boundaries, which turns into \"normal\" pri.\n  retryTime: ExpirationTime,\n|};\n\nexport type SuspenseListTailMode = 'collapsed' | 'hidden' | void;\n\nexport type SuspenseListRenderState = {|\n  isBackwards: boolean,\n  // The currently rendering tail row.\n  rendering: null | Fiber,\n  // The last of the already rendered children.\n  last: null | Fiber,\n  // Remaining rows on the tail of the list.\n  tail: null | Fiber,\n  // The absolute time in ms that we'll expire the tail rendering.\n  tailExpiration: number,\n  // Tail insertions setting.\n  tailMode: SuspenseListTailMode,\n  // Last Effect before we rendered the \"rendering\" item.\n  // Used to remove new effects added by the rendered item.\n  lastEffect: null | Fiber,\n|};\n\nexport function shouldCaptureSuspense(\n  workInProgress: Fiber,\n  hasInvisibleParent: boolean,\n): boolean {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  const nextState: SuspenseState | null = workInProgress.memoizedState;\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n    return false;\n  }\n  const props = workInProgress.memoizedProps;\n  // In order to capture, the Suspense component must have a fallback prop.\n  if (props.fallback === undefined) {\n    return false;\n  }\n  // Regular boundaries always capture.\n  if (props.unstable_avoidThisFallback !== true) {\n    return true;\n  }\n  // If it's a boundary we should avoid, then we prefer to bubble up to the\n  // parent boundary if it is currently invisible.\n  if (hasInvisibleParent) {\n    return false;\n  }\n  // If the parent is not able to handle it, we must handle it.\n  return true;\n}\n\nexport function findFirstSuspended(row: Fiber): null | Fiber {\n  let node = row;\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state: SuspenseState | null = node.memoizedState;\n      if (state !== null) {\n        const dehydrated: null | SuspenseInstance = state.dehydrated;\n        if (\n          dehydrated === null ||\n          isSuspenseInstancePending(dehydrated) ||\n          isSuspenseInstanceFallback(dehydrated)\n        ) {\n          return node;\n        }\n      }\n    } else if (\n      node.tag === SuspenseListComponent &&\n      // revealOrder undefined can't be trusted because it don't\n      // keep track of whether it suspended or not.\n      node.memoizedProps.revealOrder !== undefined\n    ) {\n      let didSuspend = (node.effectTag & DidCapture) !== NoEffect;\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === row) {\n      return null;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}