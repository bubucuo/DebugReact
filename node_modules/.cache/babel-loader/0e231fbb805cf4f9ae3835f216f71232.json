{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { warnAboutDeprecatedLifecycles, enableUserTimingAPI, enableSuspenseServerRenderer, replayFailedUnitOfWorkWithInvokeGuardedCallback, enableProfilerTimer, enableSchedulerTracing, warnAboutUnmockedScheduler, flushSuspenseFallbacksInTests, disableSchedulerTimeoutBasedOnReactExpirationTime } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport { scheduleCallback, cancelCallback, getCurrentPriorityLevel, runWithPriority, shouldYield, requestPaint, now, NoPriority, ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority, flushSyncCallbackQueue, scheduleSyncCallback } from './SchedulerWithReactIntegration'; // The scheduler is imported here *only* to detect whether it's been mocked\n\nimport * as Scheduler from 'scheduler';\nimport { __interactionsRef, __subscriberRef } from 'scheduler/tracing';\nimport { prepareForCommit, resetAfterCommit, scheduleTimeout, cancelTimeout, noTimeout, warnsIfNotActing } from './ReactFiberHostConfig';\nimport { createWorkInProgress, assignFiberPropertiesInDEV } from './ReactFiber';\nimport { isRootSuspendedAtTime, markRootSuspendedAtTime, markRootFinishedAtTime, markRootUpdatedAtTime, markRootExpiredAtTime } from './ReactFiberRoot';\nimport { NoMode, StrictMode, ProfileMode, BlockingMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostRoot, ClassComponent, SuspenseComponent, SuspenseListComponent, FunctionComponent, ForwardRef, MemoComponent, SimpleMemoComponent } from 'shared/ReactWorkTags';\nimport { NoEffect, PerformedWork, Placement, Update, PlacementAndUpdate, Deletion, Ref, ContentReset, Snapshot, Callback, Passive, Incomplete, HostEffectMask, Hydrating, HydratingAndUpdate } from 'shared/ReactSideEffectTags';\nimport { NoWork, Sync, Never, msToExpirationTime, expirationTimeToMs, computeInteractiveExpiration, computeAsyncExpiration, computeSuspenseExpiration, inferPriorityFromExpirationTime, LOW_PRIORITY_EXPIRATION, Batched, Idle } from './ReactFiberExpirationTime';\nimport { beginWork as originalBeginWork } from './ReactFiberBeginWork';\nimport { completeWork } from './ReactFiberCompleteWork';\nimport { unwindWork, unwindInterruptedWork } from './ReactFiberUnwindWork';\nimport { throwException, createRootErrorUpdate, createClassErrorUpdate } from './ReactFiberThrow';\nimport { commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber, commitLifeCycles as commitLayoutEffectOnFiber, commitPassiveHookEffects, commitPlacement, commitWork, commitDeletion, commitDetachRef, commitAttachRef, commitResetTextContent } from './ReactFiberCommitWork';\nimport { enqueueUpdate } from './ReactUpdateQueue';\nimport { resetContextDependencies } from './ReactFiberNewContext';\nimport { resetHooks, ContextOnlyDispatcher } from './ReactFiberHooks';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { recordCommitTime, startProfilerTimer, stopProfilerTimerIfRunningAndRecordDelta } from './ReactProfilerTimer'; // DEV stuff\n\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { phase as ReactCurrentDebugFiberPhaseInDEV, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV, getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { recordEffect, recordScheduleUpdate, startWorkTimer, stopWorkTimer, stopFailedWorkTimer, startWorkLoopTimer, stopWorkLoopTimer, startCommitTimer, stopCommitTimer, startCommitSnapshotEffectsTimer, stopCommitSnapshotEffectsTimer, startCommitHostEffectsTimer, stopCommitHostEffectsTimer, startCommitLifeCyclesTimer, stopCommitLifeCyclesTimer } from './ReactDebugFiberPerf';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { onCommitRoot } from './ReactFiberDevToolsHook';\nconst ceil = Math.ceil;\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  IsSomeRendererActing\n} = ReactSharedInternals;\nconst NoContext =\n/*                    */\n0b000000;\nconst BatchedContext =\n/*               */\n0b000001;\nconst EventContext =\n/*                 */\n0b000010;\nconst DiscreteEventContext =\n/*         */\n0b000100;\nconst LegacyUnbatchedContext =\n/*       */\n0b001000;\nconst RenderContext =\n/*                */\n0b010000;\nconst CommitContext =\n/*                */\n0b100000;\nconst RootIncomplete = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\n// Describes where we are in the React execution stack\nlet executionContext = NoContext; // The root we're working on\n\nlet workInProgressRoot = null; // The fiber we're working on\n\nlet workInProgress = null; // The expiration time we're rendering\n\nlet renderExpirationTime = NoWork; // Whether to root completed, errored, suspended, etc.\n\nlet workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown\n\nlet workInProgressRootFatalError = null; // Most recent event time among processed updates during this render.\n// This is conceptually a time stamp but expressed in terms of an ExpirationTime\n// because we deal mostly with expiration times in the hot path, so this avoids\n// the conversion happening in the hot path.\n\nlet workInProgressRootLatestProcessedExpirationTime = Sync;\nlet workInProgressRootLatestSuspenseTimeout = Sync;\nlet workInProgressRootCanSuspendUsingConfig = null; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nlet workInProgressRootNextUnprocessedUpdateTime = NoWork; // If we're pinged while rendering we don't always restart immediately.\n// This flag determines if it might be worthwhile to restart if an opportunity\n// happens latere.\n\nlet workInProgressRootHasPendingPing = false; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nlet globalMostRecentFallbackTime = 0;\nconst FALLBACK_THROTTLE_MS = 500;\nlet nextEffect = null;\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed = null;\nlet rootDoesHavePassiveEffects = false;\nlet rootWithPendingPassiveEffects = null;\nlet pendingPassiveEffectsRenderPriority = NoPriority;\nlet pendingPassiveEffectsExpirationTime = NoWork;\nlet rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates\n\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount = 0;\nlet rootWithNestedUpdates = null;\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount = 0;\nlet interruptedBy = null; // Marks the need to reschedule pending interactions at these expiration times\n// during the commit phase. This enables them to be traced across components\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\n// hydration or SuspenseList.\n\nlet spawnedWorkDuringRender = null; // Expiration times are computed by adding to the current time (the start\n// time). However, if two updates are scheduled within the same event, we\n// should treat their start times as simultaneous, even if the actual clock\n// time has advanced between the first and second call.\n// In other words, because expiration times determine how updates are batched,\n// we want all updates of like priority that occur within the same event to\n// receive the same expiration time. Otherwise we get tearing.\n\nlet currentEventTime = NoWork;\nexport function requestCurrentTimeForUpdate() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\nexport function getCurrentTime() {\n  return msToExpirationTime(now());\n}\nexport function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {\n  const mode = fiber.mode;\n\n  if ((mode & BlockingMode) === NoMode) {\n    return Sync;\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(currentTime, suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n\n      case NormalPriority:\n      case LowPriority:\n        // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  } // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n\n\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\nexport function scheduleUpdateOnFiber(fiber, expirationTime) {\n  checkForNestedUpdates();\n  warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n\n  if (root === null) {\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  }\n\n  checkForInterruption(fiber, expirationTime);\n  recordScheduleUpdate(); // TODO: computeExpirationForFiber also reads the priority. Pass the\n  // priority as an argument to that function and this one.\n\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if (expirationTime === Sync) {\n    if ( // Check if we're inside unbatchedUpdates\n    (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering\n    (executionContext & (RenderContext | CommitContext)) === NoContext) {\n      // Register pending interactions on the root to avoid losing traced interaction data.\n      schedulePendingInteractions(root, expirationTime); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n      // root inside of batchedUpdates should be synchronous, but layout updates\n      // should be deferred until the end of the batch.\n\n      performSyncWorkOnRoot(root);\n    } else {\n      ensureRootIsScheduled(root);\n      schedulePendingInteractions(root, expirationTime);\n\n      if (executionContext === NoContext) {\n        // Flush the synchronous work now, unless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initiated\n        // updates, to preserve historical behavior of legacy mode.\n        flushSyncCallbackQueue();\n      }\n    }\n  } else {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, expirationTime);\n  }\n\n  if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered\n  // discrete, even inside a discrete event.\n  priorityLevel === UserBlockingPriority || priorityLevel === ImmediatePriority)) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\nexport const scheduleWork = scheduleUpdateOnFiber; // This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\n\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n\n  let alternate = fiber.alternate;\n\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  } // Walk the parent path to the root and update the child expiration time.\n\n\n  let node = fiber.return;\n  let root = null;\n\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n\n        if (alternate !== null && alternate.childExpirationTime < expirationTime) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {\n        alternate.childExpirationTime = expirationTime;\n      }\n\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    } // Mark that the root has a pending update.\n\n\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\nfunction getNextRootExpirationTimeToWorkOn(root) {\n  // Determines the next expiration time that the root should render, taking\n  // into account levels that may be suspended, or levels that may have\n  // received a ping.\n  const lastExpiredTime = root.lastExpiredTime;\n\n  if (lastExpiredTime !== NoWork) {\n    return lastExpiredTime;\n  } // \"Pending\" refers to any update that hasn't committed yet, including if it\n  // suspended. The \"suspended\" range is therefore a subset.\n\n\n  const firstPendingTime = root.firstPendingTime;\n\n  if (!isRootSuspendedAtTime(root, firstPendingTime)) {\n    // The highest priority pending time is not suspended. Let's work on that.\n    return firstPendingTime;\n  } // If the first pending time is suspended, check if there's a lower priority\n  // pending level that we know about. Or check if we received a ping. Work\n  // on whichever is higher priority.\n\n\n  const lastPingedTime = root.lastPingedTime;\n  const nextKnownPendingLevel = root.nextKnownPendingLevel;\n  return lastPingedTime > nextKnownPendingLevel ? lastPingedTime : nextKnownPendingLevel;\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\n\n\nfunction ensureRootIsScheduled(root) {\n  const lastExpiredTime = root.lastExpiredTime;\n\n  if (lastExpiredTime !== NoWork) {\n    // Special case: Expired work should flush synchronously.\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n\n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n\n    return;\n  } // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n\n\n  const currentTime = requestCurrentTimeForUpdate();\n  const priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime); // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n\n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n\n    if ( // Callback must have the exact same expiration time.\n    existingCallbackExpirationTime === expirationTime && // Callback must have greater or equal priority.\n    existingCallbackPriority >= priorityLevel) {\n      // Existing callback is sufficient.\n      return;\n    } // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n\n\n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n  let callbackNode;\n\n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  } else {\n    callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root), // Compute a task timeout based on the expiration time. This also affects\n    // ordering because tasks are processed in timeout order.\n    {\n      timeout: expirationTimeToMs(expirationTime) - now()\n    });\n  }\n\n  root.callbackNode = callbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoWork;\n\n  if (didTimeout) {\n    // The render task took too long to complete. Mark the current time as\n    // expired to synchronously render all expired work in a single batch.\n    const currentTime = requestCurrentTimeForUpdate();\n    markRootExpiredAtTime(root, currentTime); // This will schedule a synchronous callback.\n\n    ensureRootIsScheduled(root);\n    return null;\n  } // Determine the next expiration time to work on, using the fields stored\n  // on the root.\n\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n\n  if (expirationTime !== NoWork) {\n    const originalCallbackNode = root.callbackNode;\n    invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.');\n    flushPassiveEffects(); // If the root or expiration time have changed, throw out the existing stack\n    // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n    if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n      prepareFreshStack(root, expirationTime);\n      startWorkOnPendingInteractions(root, expirationTime);\n    } // If we have a work-in-progress fiber, it means there's still work to do\n    // in this root.\n\n\n    if (workInProgress !== null) {\n      const prevExecutionContext = executionContext;\n      executionContext |= RenderContext;\n      const prevDispatcher = pushDispatcher(root);\n      const prevInteractions = pushInteractions(root);\n      startWorkLoopTimer(workInProgress);\n\n      do {\n        try {\n          workLoopConcurrent();\n          break;\n        } catch (thrownValue) {\n          handleError(root, thrownValue);\n        }\n      } while (true);\n\n      resetContextDependencies();\n      executionContext = prevExecutionContext;\n      popDispatcher(prevDispatcher);\n\n      if (enableSchedulerTracing) {\n        popInteractions(prevInteractions);\n      }\n\n      if (workInProgressRootExitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        stopInterruptedWorkLoopTimer();\n        prepareFreshStack(root, expirationTime);\n        markRootSuspendedAtTime(root, expirationTime);\n        ensureRootIsScheduled(root);\n        throw fatalError;\n      }\n\n      if (workInProgress !== null) {\n        // There's still work left over. Exit without committing.\n        stopInterruptedWorkLoopTimer();\n      } else {\n        // We now have a consistent tree. The next step is either to commit it,\n        // or, if something suspended, wait to commit it after a timeout.\n        stopFinishedWorkLoopTimer();\n        const finishedWork = root.finishedWork = root.current.alternate;\n        root.finishedExpirationTime = expirationTime;\n        finishConcurrentRender(root, finishedWork, workInProgressRootExitStatus, expirationTime);\n      }\n\n      ensureRootIsScheduled(root);\n\n      if (root.callbackNode === originalCallbackNode) {\n        // The task node scheduled for this root is the same one that's\n        // currently executed. Need to return a continuation.\n        return performConcurrentWorkOnRoot.bind(null, root);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction finishConcurrentRender(root, finishedWork, exitStatus, expirationTime) {\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  switch (exitStatus) {\n    case RootIncomplete:\n    case RootFatalErrored:\n      {\n        invariant(false, 'Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // If this was an async render, the error may have happened due to\n        // a mutation in a concurrent event. Try rendering one more time,\n        // synchronously, to see if the error goes away. If there are\n        // lower priority updates, let's include those, too, in case they\n        // fix the inconsistency. Render at Idle to include all updates.\n        // If it was Idle or Never or some not-yet-invented time, render\n        // at that time.\n        markRootExpiredAtTime(root, expirationTime > Idle ? Idle : expirationTime); // We assume that this second render pass will be synchronous\n        // and therefore not hit this path again.\n\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspendedAtTime(root, expirationTime);\n        const lastSuspendedTime = root.lastSuspendedTime;\n\n        if (expirationTime === lastSuspendedTime) {\n          root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n        }\n\n        flushSuspensePriorityWarningInDEV(); // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n        // If we have processed new updates during this render, we may now\n        // have a new loading state ready. We want to ensure that we commit\n        // that as soon as possible.\n\n        const hasNotProcessedNewUpdates = workInProgressRootLatestProcessedExpirationTime === Sync;\n\n        if (hasNotProcessedNewUpdates && // do not delay if we're inside an act() scope\n        !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current)) {\n          // If we have not processed any new updates during this pass, then\n          // this is either a retry of an existing fallback state or a\n          // hidden tree. Hidden trees shouldn't be batched with other work\n          // and after that's fixed it can only be a retry. We're going to\n          // throttle committing retries so that we don't show too many\n          // loading states too quickly.\n          let msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            if (workInProgressRootHasPendingPing) {\n              const lastPingedTime = root.lastPingedTime;\n\n              if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n                // This render was pinged but we didn't get to restart\n                // earlier so try restarting now instead.\n                root.lastPingedTime = expirationTime;\n                prepareFreshStack(root, expirationTime);\n                break;\n              }\n            }\n\n            const nextTime = getNextRootExpirationTimeToWorkOn(root);\n\n            if (nextTime !== NoWork && nextTime !== expirationTime) {\n              // There's additional work on this root.\n              break;\n            }\n\n            if (lastSuspendedTime !== NoWork && lastSuspendedTime !== expirationTime) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              root.lastPingedTime = lastSuspendedTime;\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspendedAtTime(root, expirationTime);\n        const lastSuspendedTime = root.lastSuspendedTime;\n\n        if (expirationTime === lastSuspendedTime) {\n          root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n        }\n\n        flushSuspensePriorityWarningInDEV();\n\n        if ( // do not delay if we're inside an act() scope\n        !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current)) {\n          // We're suspended in a state that should be avoided. We'll try to\n          // avoid committing it for as long as the timeouts let us.\n          if (workInProgressRootHasPendingPing) {\n            const lastPingedTime = root.lastPingedTime;\n\n            if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n              // This render was pinged but we didn't get to restart earlier\n              // so try restarting now instead.\n              root.lastPingedTime = expirationTime;\n              prepareFreshStack(root, expirationTime);\n              break;\n            }\n          }\n\n          const nextTime = getNextRootExpirationTimeToWorkOn(root);\n\n          if (nextTime !== NoWork && nextTime !== expirationTime) {\n            // There's additional work on this root.\n            break;\n          }\n\n          if (lastSuspendedTime !== NoWork && lastSuspendedTime !== expirationTime) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            root.lastPingedTime = lastSuspendedTime;\n            break;\n          }\n\n          let msUntilTimeout;\n\n          if (workInProgressRootLatestSuspenseTimeout !== Sync) {\n            // We have processed a suspense config whose expiration time we\n            // can use as the timeout.\n            msUntilTimeout = expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();\n          } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {\n            // This should never normally happen because only new updates\n            // cause delayed states, so we should have processed something.\n            // However, this could also happen in an offscreen tree.\n            msUntilTimeout = 0;\n          } else {\n            // If we don't have a suspense config, we're going to use a\n            // heuristic to determine how long we can suspend.\n            const eventTimeMs = inferTimeFromExpirationTime(workInProgressRootLatestProcessedExpirationTime);\n            const currentTimeMs = now();\n            const timeUntilExpirationMs = expirationTimeToMs(expirationTime) - currentTimeMs;\n            let timeElapsed = currentTimeMs - eventTimeMs;\n\n            if (timeElapsed < 0) {\n              // We get this wrong some time since we estimate the time.\n              timeElapsed = 0;\n            }\n\n            msUntilTimeout = jnd(timeElapsed) - timeElapsed; // Clamp the timeout to the expiration time. TODO: Once the\n            // event time is exact instead of inferred from expiration time\n            // we don't need this.\n\n            if (timeUntilExpirationMs < msUntilTimeout) {\n              msUntilTimeout = timeUntilExpirationMs;\n            }\n          } // Don't bother with a very short suspense time.\n\n\n          if (msUntilTimeout > 10) {\n            // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        if ( // do not delay if we're inside an act() scope\n        !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current) && workInProgressRootLatestProcessedExpirationTime !== Sync && workInProgressRootCanSuspendUsingConfig !== null) {\n          // If we have exceeded the minimum loading delay, which probably\n          // means we have shown a spinner already, we might have to suspend\n          // a bit longer to ensure that the spinner is shown for\n          // enough time.\n          const msUntilTimeout = computeMsUntilSuspenseLoadingDelay(workInProgressRootLatestProcessedExpirationTime, expirationTime, workInProgressRootCanSuspendUsingConfig);\n\n          if (msUntilTimeout > 10) {\n            markRootSuspendedAtTime(root, expirationTime);\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        }\n\n        commitRoot(root);\n        break;\n      }\n\n    default:\n      {\n        invariant(false, 'Unknown root exit status.');\n      }\n  }\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n\n\nfunction performSyncWorkOnRoot(root) {\n  // Check if there's expired work on this root. Otherwise, render at Sync.\n  const lastExpiredTime = root.lastExpiredTime;\n  const expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;\n\n  if (root.finishedExpirationTime === expirationTime) {\n    // There's already a pending commit at this expiration time.\n    // TODO: This is poorly factored. This case only exists for the\n    // batch.commit() API.\n    commitRoot(root);\n  } else {\n    invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.');\n    flushPassiveEffects(); // If the root or expiration time have changed, throw out the existing stack\n    // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n    if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n      prepareFreshStack(root, expirationTime);\n      startWorkOnPendingInteractions(root, expirationTime);\n    } // If we have a work-in-progress fiber, it means there's still work to do\n    // in this root.\n\n\n    if (workInProgress !== null) {\n      const prevExecutionContext = executionContext;\n      executionContext |= RenderContext;\n      const prevDispatcher = pushDispatcher(root);\n      const prevInteractions = pushInteractions(root);\n      startWorkLoopTimer(workInProgress);\n\n      do {\n        try {\n          workLoopSync();\n          break;\n        } catch (thrownValue) {\n          handleError(root, thrownValue);\n        }\n      } while (true);\n\n      resetContextDependencies();\n      executionContext = prevExecutionContext;\n      popDispatcher(prevDispatcher);\n\n      if (enableSchedulerTracing) {\n        popInteractions(prevInteractions);\n      }\n\n      if (workInProgressRootExitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        stopInterruptedWorkLoopTimer();\n        prepareFreshStack(root, expirationTime);\n        markRootSuspendedAtTime(root, expirationTime);\n        ensureRootIsScheduled(root);\n        throw fatalError;\n      }\n\n      if (workInProgress !== null) {\n        // This is a sync render, so we should have finished the whole tree.\n        invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n      } else {\n        // We now have a consistent tree. Because this is a sync render, we\n        // will commit it even if something suspended.\n        stopFinishedWorkLoopTimer();\n        root.finishedWork = root.current.alternate;\n        root.finishedExpirationTime = expirationTime;\n        finishSyncRender(root, workInProgressRootExitStatus, expirationTime);\n      } // Before exiting, make sure there's a callback scheduled for the next\n      // pending level.\n\n\n      ensureRootIsScheduled(root);\n    }\n  }\n\n  return null;\n}\n\nfunction finishSyncRender(root, exitStatus, expirationTime) {\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  if (__DEV__) {\n    if (exitStatus === RootSuspended || exitStatus === RootSuspendedWithDelay) {\n      flushSuspensePriorityWarningInDEV();\n    }\n  }\n\n  commitRoot(root);\n}\n\nexport function flushRoot(root, expirationTime) {\n  markRootExpiredAtTime(root, expirationTime);\n  ensureRootIsScheduled(root);\n\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushSyncCallbackQueue();\n  }\n}\nexport function flushDiscreteUpdates() {\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\n  // as a public API.\n  if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {\n    if (__DEV__ && (executionContext & RenderContext) !== NoContext) {\n      warning(false, 'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');\n    } // We're already rendering, so we can't synchronously flush pending work.\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\n    // like `el.focus()`. Exit.\n\n\n    return;\n  }\n\n  flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that\n  // they fire before the next serial event.\n\n  flushPassiveEffects();\n}\nexport function deferredUpdates(fn) {\n  // TODO: Remove in favor of Scheduler.next\n  return runWithPriority(NormalPriority, fn);\n}\nexport function syncUpdates(fn, a, b, c) {\n  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));\n}\n\nfunction flushPendingDiscreteUpdates() {\n  if (rootsWithPendingDiscreteUpdates !== null) {\n    // For each root with pending discrete updates, schedule a callback to\n    // immediately flush them.\n    const roots = rootsWithPendingDiscreteUpdates;\n    rootsWithPendingDiscreteUpdates = null;\n    roots.forEach((expirationTime, root) => {\n      markRootExpiredAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n    }); // Now flush the immediate queue.\n\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function batchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function batchedEventUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= EventContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function discreteUpdates(fn, a, b, c) {\n  const prevExecutionContext = executionContext;\n  executionContext |= DiscreteEventContext;\n\n  try {\n    // Should this\n    return runWithPriority(UserBlockingPriority, fn.bind(null, a, b, c));\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function unbatchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function flushSync(fn, a) {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be ' + 'called when React is already rendering.');\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return runWithPriority(ImmediatePriority, fn.bind(null, a));\n  } finally {\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    flushSyncCallbackQueue();\n  }\n}\nexport function flushControlled(fn) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    runWithPriority(ImmediatePriority, fn);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nfunction prepareFreshStack(root, expirationTime) {\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n  const timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null, expirationTime);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootFatalError = null;\n  workInProgressRootLatestProcessedExpirationTime = Sync;\n  workInProgressRootLatestSuspenseTimeout = Sync;\n  workInProgressRootCanSuspendUsingConfig = null;\n  workInProgressRootNextUnprocessedUpdateTime = NoWork;\n  workInProgressRootHasPendingPing = false;\n\n  if (enableSchedulerTracing) {\n    spawnedWorkDuringRender = null;\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    componentsThatTriggeredHighPriSuspend = null;\n  }\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooks();\n      resetCurrentDebugFiberInDEV();\n\n      if (workInProgress === null || workInProgress.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        return null;\n      }\n\n      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n      }\n\n      throwException(root, workInProgress.return, workInProgress, thrownValue, renderExpirationTime);\n      workInProgress = completeUnitOfWork(workInProgress);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n      continue;\n    } // Return to the normal work loop.\n\n\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher(root) {\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nfunction pushInteractions(root) {\n  if (enableSchedulerTracing) {\n    const prevInteractions = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n    return prevInteractions;\n  }\n\n  return null;\n}\n\nfunction popInteractions(prevInteractions) {\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = prevInteractions;\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nexport function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {\n  if (expirationTime < workInProgressRootLatestProcessedExpirationTime && expirationTime > Idle) {\n    workInProgressRootLatestProcessedExpirationTime = expirationTime;\n  }\n\n  if (suspenseConfig !== null) {\n    if (expirationTime < workInProgressRootLatestSuspenseTimeout && expirationTime > Idle) {\n      workInProgressRootLatestSuspenseTimeout = expirationTime; // Most of the time we only have one config and getting wrong is not bad.\n\n      workInProgressRootCanSuspendUsingConfig = suspenseConfig;\n    }\n  }\n}\nexport function markUnprocessedUpdateTime(expirationTime) {\n  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {\n    workInProgressRootNextUnprocessedUpdateTime = expirationTime;\n  }\n}\nexport function renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nexport function renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there's a lower priority update somewhere else in the tree.\n\n\n  if (workInProgressRootNextUnprocessedUpdateTime !== NoWork && workInProgressRoot !== null) {\n    // Mark the current render as suspended, and then mark that there's a\n    // pending update.\n    // TODO: This should immediately interrupt the current render, instead\n    // of waiting until the next time we yield.\n    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime);\n    markRootUpdatedAtTime(workInProgressRoot, workInProgressRootNextUnprocessedUpdateTime);\n  }\n}\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootCompleted) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nexport function renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction inferTimeFromExpirationTime(expirationTime) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction inferTimeFromExpirationTimeWithSuspenseConfig(expirationTime, suspenseConfig) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time by subtracting the timeout\n  // that was added to the event time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  startWorkTimer(unitOfWork);\n  setCurrentDebugFiberInDEV(unitOfWork);\n  let next;\n\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  workInProgress = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = workInProgress.alternate;\n    const returnFiber = workInProgress.return; // Check if the work completed or if something threw.\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      setCurrentDebugFiberInDEV(workInProgress);\n      let next;\n\n      if (!enableProfilerTimer || (workInProgress.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, workInProgress, renderExpirationTime);\n      } else {\n        startProfilerTimer(workInProgress);\n        next = completeWork(current, workInProgress, renderExpirationTime); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n\n      stopWorkTimer(workInProgress);\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(workInProgress);\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        return next;\n      }\n\n      if (returnFiber !== null && // Do not append effects to parents if a sibling failed to complete\n      (returnFiber.effectTag & Incomplete) === NoEffect) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        } // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if needed,\n        // by doing multiple passes over the effect list. We don't want to\n        // schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n\n\n        const effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\n        // committed.\n\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, renderExpirationTime); // Because this fiber did not complete, don't reset its expiration time.\n\n      if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false); // Include the time spent working on failed children before continuing.\n\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        // TODO: The name stopFailedWorkTimer is misleading because Suspense\n        // also captures and restarts.\n        stopFailedWorkTimer(workInProgress);\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n\n      stopWorkTimer(workInProgress);\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    }\n\n    const siblingFiber = workInProgress.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      return siblingFiber;\n    } // Otherwise, return to the parent\n\n\n    workInProgress = returnFiber;\n  } while (workInProgress !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n\n  return null;\n}\n\nfunction getRemainingExpirationTime(fiber) {\n  const updateExpirationTime = fiber.expirationTime;\n  const childExpirationTime = fiber.childExpirationTime;\n  return updateExpirationTime > childExpirationTime ? updateExpirationTime : childExpirationTime;\n}\n\nfunction resetChildExpirationTime(completedWork) {\n  if (renderExpirationTime !== Never && completedWork.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork; // Bubble up the earliest expiration time.\n\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n    // In profiling mode, resetChildExpirationTime is also used to reset\n    // profiler durations.\n    let actualDuration = completedWork.actualDuration;\n    let treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration. If\n    // the fiber has not been cloned though, (meaning no work was done), then\n    // this value will reflect the amount of time spent working on a previous\n    // render. In that case it should not bubble. We determine whether it was\n    // cloned by comparing the child pointer.\n\n    const shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;\n    let child = completedWork.child;\n\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n\n    completedWork.actualDuration = actualDuration;\n    completedWork.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = completedWork.child;\n\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n\n      child = child.sibling;\n    }\n  }\n\n  completedWork.childExpirationTime = newChildExpirationTime;\n}\n\nfunction commitRoot(root) {\n  const renderPriorityLevel = getCurrentPriorityLevel();\n  runWithPriority(ImmediatePriority, commitRootImpl.bind(null, root, renderPriorityLevel));\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.');\n  const finishedWork = root.finishedWork;\n  const expirationTime = root.finishedExpirationTime;\n\n  if (finishedWork === null) {\n    return null;\n  }\n\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n  invariant(finishedWork !== root.current, 'Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.'); // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n\n  root.callbackNode = null;\n  root.callbackExpirationTime = NoWork;\n  root.callbackPriority = NoPriority;\n  root.nextKnownPendingLevel = NoWork;\n  startCommitTimer(); // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  const remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(finishedWork);\n  markRootFinishedAtTime(root, expirationTime, remainingExpirationTimeBeforeCommit);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    renderExpirationTime = NoWork;\n  } else {} // This indicates that the last root we worked on is not the same one that\n  // we're committing now. This most commonly happens when a suspended root\n  // times out.\n  // Get the list of effects.\n\n\n  let firstEffect;\n\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if it\n    // had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  if (firstEffect !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext;\n    const prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    startCommitSnapshotEffectsTimer();\n    prepareForCommit(root.containerInfo);\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitBeforeMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    } // The next phase is the mutation phase, where we mutate the host tree.\n\n\n    startCommitHostEffectsTimer();\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitMutationEffects(root, renderPriorityLevel);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitHostEffectsTimer();\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n\n    startCommitLifeCyclesTimer();\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, expirationTime);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitLayoutEffects(root, expirationTime);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitLifeCyclesTimer();\n    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n\n    requestPaint();\n\n    if (enableSchedulerTracing) {\n      popInteractions(prevInteractions);\n    }\n\n    executionContext = prevExecutionContext;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    startCommitSnapshotEffectsTimer();\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n\n    startCommitHostEffectsTimer();\n    stopCommitHostEffectsTimer();\n    startCommitLifeCyclesTimer();\n    stopCommitLifeCyclesTimer();\n  }\n\n  stopCommitTimer();\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsExpirationTime = expirationTime;\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n  } else {\n    // We are done with the effect chain at this point so let's clear the\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\n    // clear this in flushPassiveEffects.\n    nextEffect = firstEffect;\n\n    while (nextEffect !== null) {\n      const nextNextEffect = nextEffect.nextEffect;\n      nextEffect.nextEffect = null;\n      nextEffect = nextNextEffect;\n    }\n  } // Check if there's remaining work on this root\n\n\n  const remainingExpirationTime = root.firstPendingTime;\n\n  if (remainingExpirationTime !== NoWork) {\n    if (enableSchedulerTracing) {\n      if (spawnedWorkDuringRender !== null) {\n        const expirationTimes = spawnedWorkDuringRender;\n        spawnedWorkDuringRender = null;\n\n        for (let i = 0; i < expirationTimes.length; i++) {\n          scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);\n        }\n      }\n\n      schedulePendingInteractions(root, remainingExpirationTime);\n    }\n  } else {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (enableSchedulerTracing) {\n    if (!rootDidHavePassiveEffects) {\n      // If there are no passive effects, then we can complete the pending interactions.\n      // Otherwise, we'll wait until after the passive effects are flushed.\n      // Wait to do this until after remaining work has been scheduled,\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\n      finishPendingInteractions(root, expirationTime);\n    }\n  }\n\n  if (remainingExpirationTime === Sync) {\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  onCommitRoot(finishedWork.stateNode, expirationTime); // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n  ensureRootIsScheduled(root);\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\n    // This is a legacy edge case. We just committed the initial mount of\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\n    // synchronously, but layout updates should be deferred until the end\n    // of the batch.\n    return null;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbackQueue();\n  return null;\n}\n\nfunction commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n\n    if ((effectTag & Snapshot) !== NoEffect) {\n      setCurrentDebugFiberInDEV(nextEffect);\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if ((effectTag & Passive) !== NoEffect) {\n      // If there are passive effects, schedule a callback to flush at\n      // the earliest opportunity.\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitMutationEffects(root, renderPriorityLevel) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    } // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every possible\n    // bitmap value, we remove the secondary effects from the effect tag and\n    // switch on that value.\n\n\n    let primaryEffectTag = effectTag & (Placement | Update | Deletion | Hydrating);\n\n    switch (primaryEffectTag) {\n      case Placement:\n        {\n          commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is\n          // inserted, before any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted does\n          // and isMounted is deprecated anyway so we should be able to kill this.\n\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n\n      case PlacementAndUpdate:\n        {\n          // Placement\n          commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is\n          // inserted, before any life-cycles like componentDidMount gets called.\n\n          nextEffect.effectTag &= ~Placement; // Update\n\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n\n      case Hydrating:\n        {\n          nextEffect.effectTag &= ~Hydrating;\n          break;\n        }\n\n      case HydratingAndUpdate:\n        {\n          nextEffect.effectTag &= ~Hydrating; // Update\n\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n\n      case Update:\n        {\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n\n      case Deletion:\n        {\n          commitDeletion(root, nextEffect, renderPriorityLevel);\n          break;\n        }\n    } // TODO: Only record a mutation effect if primaryEffectTag is non-zero.\n\n\n    recordEffect();\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitLayoutEffects(root, committedExpirationTime) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedExpirationTime);\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nexport function flushPassiveEffects() {\n  if (pendingPassiveEffectsRenderPriority !== NoPriority) {\n    const priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority ? NormalPriority : pendingPassiveEffectsRenderPriority;\n    pendingPassiveEffectsRenderPriority = NoPriority;\n    return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  const root = rootWithPendingPassiveEffects;\n  const expirationTime = pendingPassiveEffectsExpirationTime;\n  rootWithPendingPassiveEffects = null;\n  pendingPassiveEffectsExpirationTime = NoWork;\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Cannot flush passive effects while already rendering.');\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  const prevInteractions = pushInteractions(root); // Note: This currently assumes there are no passive effects on the root\n  // fiber, because the root is not part of its own effect list. This could\n  // change in the future.\n\n  let effect = root.current.firstEffect;\n\n  while (effect !== null) {\n    if (__DEV__) {\n      setCurrentDebugFiberInDEV(effect);\n      invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n\n      if (hasCaughtError()) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        const error = clearCaughtError();\n        captureCommitPhaseError(effect, error);\n      }\n\n      resetCurrentDebugFiberInDEV();\n    } else {\n      try {\n        commitPassiveHookEffects(effect);\n      } catch (error) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        captureCommitPhaseError(effect, error);\n      }\n    }\n\n    const nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC\n\n    effect.nextEffect = null;\n    effect = nextNextEffect;\n  }\n\n  if (enableSchedulerTracing) {\n    popInteractions(prevInteractions);\n    finishPendingInteractions(root, expirationTime);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n\n  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nexport function markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, Sync);\n  enqueueUpdate(rootFiber, update);\n  const root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);\n\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, Sync);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber, error) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = sourceFiber.return;\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(fiber, errorInfo, // TODO: This is always sync\n        Sync);\n        enqueueUpdate(fiber, update);\n        const root = markUpdateTimeFromFiberToRoot(fiber, Sync);\n\n        if (root !== null) {\n          ensureRootIsScheduled(root);\n          schedulePendingInteractions(root, Sync);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n}\nexport function pingSuspendedRoot(root, thenable, suspendedTime) {\n  const pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (workInProgressRoot === root && renderExpirationTime === suspendedTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, we'll always suspend so we can always\n    // restart. If we're suspended without any updates, it might be a retry.\n    // If it's early in the retry we can restart. We can't know for sure\n    // whether we'll eventually process an update during this render pass,\n    // but it's somewhat unlikely that we get to a ping before that, since\n    // getting to the root most update is usually very fast.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && workInProgressRootLatestProcessedExpirationTime === Sync && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root. Don't need to schedule a ping because\n      // we're already working on this tree.\n      prepareFreshStack(root, renderExpirationTime);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootHasPendingPing = true;\n    }\n\n    return;\n  }\n\n  if (!isRootSuspendedAtTime(root, suspendedTime)) {\n    // The root is no longer suspended at this time.\n    return;\n  }\n\n  const lastPingedTime = root.lastPingedTime;\n\n  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {\n    // There's already a lower priority ping scheduled.\n    return;\n  } // Mark the time at which this ping was scheduled.\n\n\n  root.lastPingedTime = suspendedTime;\n\n  if (root.finishedExpirationTime === suspendedTime) {\n    // If there's a pending fallback waiting to commit, throw it away.\n    root.finishedExpirationTime = NoWork;\n    root.finishedWork = null;\n  }\n\n  ensureRootIsScheduled(root);\n  schedulePendingInteractions(root, suspendedTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryTime) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new expiration time.\n  if (retryTime === NoWork) {\n    const suspenseConfig = null; // Retries don't carry over the already committed update.\n\n    const currentTime = requestCurrentTimeForUpdate();\n    retryTime = computeExpirationForFiber(currentTime, boundaryFiber, suspenseConfig);\n  } // TODO: Special case idle priority?\n\n\n  const root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);\n\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, retryTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber) {\n  const suspenseState = boundaryFiber.memoizedState;\n  let retryTime = NoWork;\n\n  if (suspenseState !== null) {\n    retryTime = suspenseState.retryTime;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\nexport function resolveRetryThenable(boundaryFiber, thenable) {\n  let retryTime = NoWork; // Default\n\n  let retryCache;\n\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState = boundaryFiber.memoizedState;\n\n        if (suspenseState !== null) {\n          retryTime = suspenseState.retryTime;\n        }\n\n        break;\n\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n\n      default:\n        invariant(false, 'Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction computeMsUntilSuspenseLoadingDelay(mostRecentEventTime, committedExpirationTime, suspenseConfig) {\n  const busyMinDurationMs = suspenseConfig.busyMinDurationMs | 0;\n\n  if (busyMinDurationMs <= 0) {\n    return 0;\n  }\n\n  const busyDelayMs = suspenseConfig.busyDelayMs | 0; // Compute the time until this render pass would expire.\n\n  const currentTimeMs = now();\n  const eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(mostRecentEventTime, suspenseConfig);\n  const timeElapsed = currentTimeMs - eventTimeMs;\n\n  if (timeElapsed <= busyDelayMs) {\n    // If we haven't yet waited longer than the initial delay, we don't\n    // have to wait any additional time.\n    return 0;\n  }\n\n  const msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; // This is the value that is passed to `setTimeout`.\n\n  return msUntilTimeout;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    invariant(false, 'Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      warning(false, 'Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction stopFinishedWorkLoopTimer() {\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction stopInterruptedWorkLoopTimer() {\n  // TODO: Track which fiber caused the interruption.\n  const didCompleteRoot = false;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {\n  if (enableUserTimingAPI && workInProgressRoot !== null && updateExpirationTime > renderExpirationTime) {\n    interruptedBy = fiberThatReceivedUpdate;\n  }\n}\n\nlet didWarnStateUpdateForUnmountedComponent = null;\n\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    const tag = fiber.tag;\n\n    if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\n    }\n\n    warningWithoutStack(false, \"Can't perform a React state update on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.%s', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function', getStackByFiberInDevAndProd(fiber));\n  }\n}\n\nlet beginWork;\n\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  let dummyFiber = null;\n\n  beginWork = (current, unitOfWork, expirationTime) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return originalBeginWork(current, unitOfWork, expirationTime);\n    } catch (originalError) {\n      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      } // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooks(); // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, originalBeginWork, null, current, unitOfWork, expirationTime);\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\n        // Rethrow this error instead of the original one.\n\n        throw replayError;\n      } else {\n        // This branch is reachable if the render phase is impure.\n        throw originalError;\n      }\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInGetChildContext = false;\n\nfunction warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.tag === ClassComponent) {\n      switch (ReactCurrentDebugFiberPhaseInDEV) {\n        case 'getChildContext':\n          if (didWarnAboutUpdateInGetChildContext) {\n            return;\n          }\n\n          warningWithoutStack(false, 'setState(...): Cannot call setState() inside getChildContext()');\n          didWarnAboutUpdateInGetChildContext = true;\n          break;\n\n        case 'render':\n          if (didWarnAboutUpdateInRender) {\n            return;\n          }\n\n          warningWithoutStack(false, 'Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure function of ' + 'props and state.');\n          didWarnAboutUpdateInRender = true;\n          break;\n      }\n    }\n  }\n} // a 'shared' variable that changes when act() opens/closes in tests.\n\n\nexport const IsThisRendererActing = {\n  current: false\n};\nexport function warnIfNotScopedWithMatchingAct(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {\n      warningWithoutStack(false, \"It looks like you're using the wrong act() around your test interactions.\\n\" + 'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' + '// for react-dom:\\n' + \"import {act} from 'react-dom/test-utils';\\n\" + '// ...\\n' + 'act(() => ...);\\n\\n' + '// for react-test-renderer:\\n' + \"import TestRenderer from 'react-test-renderer';\\n\" + 'const {act} = TestRenderer;\\n' + '// ...\\n' + 'act(() => ...);' + '%s', getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\n      warningWithoutStack(false, 'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\n\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\n      warningWithoutStack(false, 'An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\n\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.\n\nlet didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked\n// scheduler is the actual recommendation. The alternative could be a testing build,\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\n// to get their tests right.\n\nexport function warnIfUnmockedScheduler(fiber) {\n  if (__DEV__) {\n    if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(false, 'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \\n' + \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" + 'For more info, visit https://fb.me/react-mock-scheduler');\n      } else if (warnAboutUnmockedScheduler === true) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(false, 'Starting from React v17, the \"scheduler\" module will need to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \\n' + \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" + 'For more info, visit https://fb.me/react-mock-scheduler');\n      }\n    }\n  }\n}\nlet componentsThatTriggeredHighPriSuspend = null;\nexport function checkForWrongSuspensePriorityInDEV(sourceFiber) {\n  if (__DEV__) {\n    const currentPriorityLevel = getCurrentPriorityLevel();\n\n    if ((sourceFiber.mode & ConcurrentMode) !== NoEffect && (currentPriorityLevel === UserBlockingPriority || currentPriorityLevel === ImmediatePriority)) {\n      let workInProgressNode = sourceFiber;\n\n      while (workInProgressNode !== null) {\n        // Add the component that triggered the suspense\n        const current = workInProgressNode.alternate;\n\n        if (current !== null) {\n          // TODO: warn component that triggers the high priority\n          // suspend is the HostRoot\n          switch (workInProgressNode.tag) {\n            case ClassComponent:\n              // Loop through the component's update queue and see whether the component\n              // has triggered any high priority updates\n              const updateQueue = current.updateQueue;\n\n              if (updateQueue !== null) {\n                let update = updateQueue.firstUpdate;\n\n                while (update !== null) {\n                  const priorityLevel = update.priority;\n\n                  if (priorityLevel === UserBlockingPriority || priorityLevel === ImmediatePriority) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([getComponentName(workInProgressNode.type)]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(getComponentName(workInProgressNode.type));\n                    }\n\n                    break;\n                  }\n\n                  update = update.next;\n                }\n              }\n\n              break;\n\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent:\n              if (workInProgressNode.memoizedState !== null && workInProgressNode.memoizedState.baseUpdate !== null) {\n                let update = workInProgressNode.memoizedState.baseUpdate; // Loop through the functional component's memoized state to see whether\n                // the component has triggered any high pri updates\n\n                while (update !== null) {\n                  const priority = update.priority;\n\n                  if (priority === UserBlockingPriority || priority === ImmediatePriority) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([getComponentName(workInProgressNode.type)]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(getComponentName(workInProgressNode.type));\n                    }\n\n                    break;\n                  }\n\n                  if (update.next === workInProgressNode.memoizedState.baseUpdate) {\n                    break;\n                  }\n\n                  update = update.next;\n                }\n              }\n\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        workInProgressNode = workInProgressNode.return;\n      }\n    }\n  }\n}\n\nfunction flushSuspensePriorityWarningInDEV() {\n  if (__DEV__) {\n    if (componentsThatTriggeredHighPriSuspend !== null) {\n      const componentNames = [];\n      componentsThatTriggeredHighPriSuspend.forEach(name => componentNames.push(name));\n      componentsThatTriggeredHighPriSuspend = null;\n\n      if (componentNames.length > 0) {\n        warningWithoutStack(false, '%s triggered a user-blocking update that suspended.' + '\\n\\n' + 'The fix is to split the update into multiple parts: a user-blocking ' + 'update to provide immediate feedback, and another update that ' + 'triggers the bulk of the changes.' + '\\n\\n' + 'Refer to the documentation for useTransition to learn how ' + 'to implement this pattern.', // TODO: Add link to React docs with more information, once it exists\n        componentNames.sort().join(', '));\n      }\n    }\n  }\n}\n\nfunction computeThreadID(root, expirationTime) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + root.interactionThreadID;\n}\n\nexport function markSpawnedWork(expirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (spawnedWorkDuringRender === null) {\n    spawnedWorkDuringRender = [expirationTime];\n  } else {\n    spawnedWorkDuringRender.push(expirationTime);\n  }\n}\n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n\n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      pendingInteractionMap.set(expirationTime, new Set(interactions)); // Update the pending async work count for the current interactions.\n\n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n\n    const subscriber = __subscriberRef.current;\n\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction schedulePendingInteractions(root, expirationTime) {\n  // This is called when work is scheduled on a root.\n  // It associates the current interactions with the newly-scheduled expiration.\n  // They will be restored when that expiration is later committed.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  scheduleInteractions(root, expirationTime, __interactionsRef.current);\n}\n\nfunction startWorkOnPendingInteractions(root, expirationTime) {\n  // This is called when new work is started on a root.\n  if (!enableSchedulerTracing) {\n    return;\n  } // Determine which interactions this batch of work currently includes, So that\n  // we can accurately attribute time spent working on it, And so that cascading\n  // work triggered during the render phase will be associated with it.\n\n\n  const interactions = new Set();\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledExpirationTime) => {\n    if (scheduledExpirationTime >= expirationTime) {\n      scheduledInteractions.forEach(interaction => interactions.add(interaction));\n    }\n  }); // Store the current set of interactions on the FiberRoot for a few reasons:\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\n  // without having to recalculate it. We will also use it in commitWork() to\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\n  // way to access it when the onCommitRoot() hook is called.\n\n  root.memoizedInteractions = interactions;\n\n  if (interactions.size > 0) {\n    const subscriber = __subscriberRef.current;\n\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        // If the subscriber throws, rethrow it in a separate task\n        scheduleCallback(ImmediatePriority, () => {\n          throw error;\n        });\n      }\n    }\n  }\n}\n\nfunction finishPendingInteractions(root, committedExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const earliestRemainingTimeAfterCommit = root.firstPendingTime;\n  let subscriber;\n\n  try {\n    subscriber = __subscriberRef.current;\n\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\n      const threadID = computeThreadID(root, committedExpirationTime);\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n    }\n  } catch (error) {\n    // If the subscriber throws, rethrow it in a separate task\n    scheduleCallback(ImmediatePriority, () => {\n      throw error;\n    });\n  } finally {\n    // Clear completed interactions from the pending Map.\n    // Unless the render was suspended or cascading work was scheduled,\n    // In which case leave pending interactions until the subsequent render.\n    const pendingInteractionMap = root.pendingInteractionMap;\n    pendingInteractionMap.forEach((scheduledInteractions, scheduledExpirationTime) => {\n      // Only decrement the pending interaction count if we're done.\n      // If there's still work at the current priority,\n      // That indicates that we are waiting for suspense data.\n      if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n        pendingInteractionMap.delete(scheduledExpirationTime);\n        scheduledInteractions.forEach(interaction => {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            try {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            } catch (error) {\n              // If the subscriber throws, rethrow it in a separate task\n              scheduleCallback(ImmediatePriority, () => {\n                throw error;\n              });\n            }\n          }\n        });\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberWorkLoop.js"],"names":["warnAboutDeprecatedLifecycles","enableUserTimingAPI","enableSuspenseServerRenderer","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableProfilerTimer","enableSchedulerTracing","warnAboutUnmockedScheduler","flushSuspenseFallbacksInTests","disableSchedulerTimeoutBasedOnReactExpirationTime","ReactSharedInternals","invariant","warning","scheduleCallback","cancelCallback","getCurrentPriorityLevel","runWithPriority","shouldYield","requestPaint","now","NoPriority","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","flushSyncCallbackQueue","scheduleSyncCallback","Scheduler","__interactionsRef","__subscriberRef","prepareForCommit","resetAfterCommit","scheduleTimeout","cancelTimeout","noTimeout","warnsIfNotActing","createWorkInProgress","assignFiberPropertiesInDEV","isRootSuspendedAtTime","markRootSuspendedAtTime","markRootFinishedAtTime","markRootUpdatedAtTime","markRootExpiredAtTime","NoMode","StrictMode","ProfileMode","BlockingMode","ConcurrentMode","HostRoot","ClassComponent","SuspenseComponent","SuspenseListComponent","FunctionComponent","ForwardRef","MemoComponent","SimpleMemoComponent","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","Ref","ContentReset","Snapshot","Callback","Passive","Incomplete","HostEffectMask","Hydrating","HydratingAndUpdate","NoWork","Sync","Never","msToExpirationTime","expirationTimeToMs","computeInteractiveExpiration","computeAsyncExpiration","computeSuspenseExpiration","inferPriorityFromExpirationTime","LOW_PRIORITY_EXPIRATION","Batched","Idle","beginWork","originalBeginWork","completeWork","unwindWork","unwindInterruptedWork","throwException","createRootErrorUpdate","createClassErrorUpdate","commitBeforeMutationLifeCycles","commitBeforeMutationEffectOnFiber","commitLifeCycles","commitLayoutEffectOnFiber","commitPassiveHookEffects","commitPlacement","commitWork","commitDeletion","commitDetachRef","commitAttachRef","commitResetTextContent","enqueueUpdate","resetContextDependencies","resetHooks","ContextOnlyDispatcher","createCapturedValue","recordCommitTime","startProfilerTimer","stopProfilerTimerIfRunningAndRecordDelta","warningWithoutStack","getComponentName","ReactStrictModeWarnings","phase","ReactCurrentDebugFiberPhaseInDEV","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","getStackByFiberInDevAndProd","recordEffect","recordScheduleUpdate","startWorkTimer","stopWorkTimer","stopFailedWorkTimer","startWorkLoopTimer","stopWorkLoopTimer","startCommitTimer","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","invokeGuardedCallback","hasCaughtError","clearCaughtError","onCommitRoot","ceil","Math","ReactCurrentDispatcher","ReactCurrentOwner","IsSomeRendererActing","NoContext","BatchedContext","EventContext","DiscreteEventContext","LegacyUnbatchedContext","RenderContext","CommitContext","RootIncomplete","RootFatalErrored","RootErrored","RootSuspended","RootSuspendedWithDelay","RootCompleted","executionContext","workInProgressRoot","workInProgress","renderExpirationTime","workInProgressRootExitStatus","workInProgressRootFatalError","workInProgressRootLatestProcessedExpirationTime","workInProgressRootLatestSuspenseTimeout","workInProgressRootCanSuspendUsingConfig","workInProgressRootNextUnprocessedUpdateTime","workInProgressRootHasPendingPing","globalMostRecentFallbackTime","FALLBACK_THROTTLE_MS","nextEffect","hasUncaughtError","firstUncaughtError","legacyErrorBoundariesThatAlreadyFailed","rootDoesHavePassiveEffects","rootWithPendingPassiveEffects","pendingPassiveEffectsRenderPriority","pendingPassiveEffectsExpirationTime","rootsWithPendingDiscreteUpdates","NESTED_UPDATE_LIMIT","nestedUpdateCount","rootWithNestedUpdates","NESTED_PASSIVE_UPDATE_LIMIT","nestedPassiveUpdateCount","interruptedBy","spawnedWorkDuringRender","currentEventTime","requestCurrentTimeForUpdate","getCurrentTime","computeExpirationForFiber","currentTime","fiber","suspenseConfig","mode","priorityLevel","expirationTime","timeoutMs","scheduleUpdateOnFiber","checkForNestedUpdates","warnAboutInvalidUpdatesOnClassComponentsInDEV","root","markUpdateTimeFromFiberToRoot","warnAboutUpdateOnUnmountedFiberInDEV","checkForInterruption","schedulePendingInteractions","performSyncWorkOnRoot","ensureRootIsScheduled","Map","lastDiscreteTime","get","undefined","set","scheduleWork","alternate","node","return","tag","stateNode","childExpirationTime","markUnprocessedUpdateTime","getNextRootExpirationTimeToWorkOn","lastExpiredTime","firstPendingTime","lastPingedTime","nextKnownPendingLevel","callbackExpirationTime","callbackPriority","callbackNode","bind","existingCallbackNode","existingCallbackPriority","existingCallbackExpirationTime","performConcurrentWorkOnRoot","timeout","didTimeout","originalCallbackNode","flushPassiveEffects","prepareFreshStack","startWorkOnPendingInteractions","prevExecutionContext","prevDispatcher","pushDispatcher","prevInteractions","pushInteractions","workLoopConcurrent","thrownValue","handleError","popDispatcher","popInteractions","fatalError","stopInterruptedWorkLoopTimer","stopFinishedWorkLoopTimer","finishedWork","current","finishedExpirationTime","finishConcurrentRender","exitStatus","lastSuspendedTime","getRemainingExpirationTime","flushSuspensePriorityWarningInDEV","hasNotProcessedNewUpdates","__DEV__","IsThisRendererActing","msUntilTimeout","nextTime","timeoutHandle","commitRoot","eventTimeMs","inferTimeFromExpirationTime","currentTimeMs","timeUntilExpirationMs","timeElapsed","jnd","computeMsUntilSuspenseLoadingDelay","workLoopSync","finishSyncRender","flushRoot","flushDiscreteUpdates","flushPendingDiscreteUpdates","deferredUpdates","fn","syncUpdates","a","b","c","roots","forEach","batchedUpdates","batchedEventUpdates","discreteUpdates","unbatchedUpdates","flushSync","flushControlled","interruptedWork","discardPendingWarnings","componentsThatTriggeredHighPriSuspend","completeUnitOfWork","yetAnotherThrownValue","memoizedInteractions","markCommitTimeOfFallback","markRenderEventTimeAndConfig","renderDidSuspend","renderDidSuspendDelayIfPossible","renderDidError","renderHasNotSuspendedYet","earliestExpirationTimeMs","inferTimeFromExpirationTimeWithSuspenseConfig","performUnitOfWork","unitOfWork","next","memoizedProps","pendingProps","returnFiber","effectTag","resetChildExpirationTime","firstEffect","lastEffect","actualDuration","child","sibling","siblingFiber","updateExpirationTime","completedWork","newChildExpirationTime","treeBaseDuration","selfBaseDuration","shouldBubbleActualDurations","childUpdateExpirationTime","childChildExpirationTime","renderPriorityLevel","commitRootImpl","flushRenderPhaseStrictModeWarningsInDEV","remainingExpirationTimeBeforeCommit","containerInfo","commitBeforeMutationEffects","error","captureCommitPhaseError","commitMutationEffects","commitLayoutEffects","rootDidHavePassiveEffects","nextNextEffect","remainingExpirationTime","expirationTimes","i","length","scheduleInteractions","finishPendingInteractions","primaryEffectTag","committedExpirationTime","flushPassiveEffectsImpl","effect","isAlreadyFailedLegacyErrorBoundary","instance","has","markLegacyErrorBoundaryAsFailed","Set","add","prepareToThrowUncaughtError","onUncaughtError","captureCommitPhaseErrorOnRoot","rootFiber","sourceFiber","errorInfo","update","ctor","type","getDerivedStateFromError","componentDidCatch","pingSuspendedRoot","thenable","suspendedTime","pingCache","delete","retryTimedOutBoundary","boundaryFiber","retryTime","retryDehydratedSuspenseBoundary","suspenseState","memoizedState","resolveRetryThenable","retryCache","mostRecentEventTime","busyMinDurationMs","busyDelayMs","flushLegacyContextWarning","flushPendingUnsafeLifecycleWarnings","didCompleteRoot","fiberThatReceivedUpdate","didWarnStateUpdateForUnmountedComponent","componentName","dummyFiber","originalWorkInProgressCopy","originalError","then","replayError","didWarnAboutUpdateInRender","didWarnAboutUpdateInGetChildContext","warnIfNotScopedWithMatchingAct","warnIfNotCurrentlyActingEffectsInDEV","warnIfNotCurrentlyActingUpdatesInDEV","warnIfNotCurrentlyActingUpdatesInDev","didWarnAboutUnmockedScheduler","warnIfUnmockedScheduler","unstable_flushAllWithoutAsserting","checkForWrongSuspensePriorityInDEV","currentPriorityLevel","workInProgressNode","updateQueue","firstUpdate","priority","baseUpdate","componentNames","name","push","sort","join","computeThreadID","interactionThreadID","markSpawnedWork","interactions","size","pendingInteractionMap","pendingInteractions","interaction","__count","subscriber","threadID","onWorkScheduled","scheduledInteractions","scheduledExpirationTime","onWorkStarted","earliestRemainingTimeAfterCommit","onWorkStopped","onInteractionScheduledWorkCompleted"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\nimport type {Interaction} from 'scheduler/src/Tracing';\nimport type {SuspenseConfig} from './ReactFiberSuspenseConfig';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\n\nimport {\n  warnAboutDeprecatedLifecycles,\n  enableUserTimingAPI,\n  enableSuspenseServerRenderer,\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\n  enableProfilerTimer,\n  enableSchedulerTracing,\n  warnAboutUnmockedScheduler,\n  flushSuspenseFallbacksInTests,\n  disableSchedulerTimeoutBasedOnReactExpirationTime,\n} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\n\nimport {\n  scheduleCallback,\n  cancelCallback,\n  getCurrentPriorityLevel,\n  runWithPriority,\n  shouldYield,\n  requestPaint,\n  now,\n  NoPriority,\n  ImmediatePriority,\n  UserBlockingPriority,\n  NormalPriority,\n  LowPriority,\n  IdlePriority,\n  flushSyncCallbackQueue,\n  scheduleSyncCallback,\n} from './SchedulerWithReactIntegration';\n\n// The scheduler is imported here *only* to detect whether it's been mocked\nimport * as Scheduler from 'scheduler';\n\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\n\nimport {\n  prepareForCommit,\n  resetAfterCommit,\n  scheduleTimeout,\n  cancelTimeout,\n  noTimeout,\n  warnsIfNotActing,\n} from './ReactFiberHostConfig';\n\nimport {createWorkInProgress, assignFiberPropertiesInDEV} from './ReactFiber';\nimport {\n  isRootSuspendedAtTime,\n  markRootSuspendedAtTime,\n  markRootFinishedAtTime,\n  markRootUpdatedAtTime,\n  markRootExpiredAtTime,\n} from './ReactFiberRoot';\nimport {\n  NoMode,\n  StrictMode,\n  ProfileMode,\n  BlockingMode,\n  ConcurrentMode,\n} from './ReactTypeOfMode';\nimport {\n  HostRoot,\n  ClassComponent,\n  SuspenseComponent,\n  SuspenseListComponent,\n  FunctionComponent,\n  ForwardRef,\n  MemoComponent,\n  SimpleMemoComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  NoEffect,\n  PerformedWork,\n  Placement,\n  Update,\n  PlacementAndUpdate,\n  Deletion,\n  Ref,\n  ContentReset,\n  Snapshot,\n  Callback,\n  Passive,\n  Incomplete,\n  HostEffectMask,\n  Hydrating,\n  HydratingAndUpdate,\n} from 'shared/ReactSideEffectTags';\nimport {\n  NoWork,\n  Sync,\n  Never,\n  msToExpirationTime,\n  expirationTimeToMs,\n  computeInteractiveExpiration,\n  computeAsyncExpiration,\n  computeSuspenseExpiration,\n  inferPriorityFromExpirationTime,\n  LOW_PRIORITY_EXPIRATION,\n  Batched,\n  Idle,\n} from './ReactFiberExpirationTime';\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork';\nimport {completeWork} from './ReactFiberCompleteWork';\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork';\nimport {\n  throwException,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n} from './ReactFiberThrow';\nimport {\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\n  commitLifeCycles as commitLayoutEffectOnFiber,\n  commitPassiveHookEffects,\n  commitPlacement,\n  commitWork,\n  commitDeletion,\n  commitDetachRef,\n  commitAttachRef,\n  commitResetTextContent,\n} from './ReactFiberCommitWork';\nimport {enqueueUpdate} from './ReactUpdateQueue';\nimport {resetContextDependencies} from './ReactFiberNewContext';\nimport {resetHooks, ContextOnlyDispatcher} from './ReactFiberHooks';\nimport {createCapturedValue} from './ReactCapturedValue';\n\nimport {\n  recordCommitTime,\n  startProfilerTimer,\n  stopProfilerTimerIfRunningAndRecordDelta,\n} from './ReactProfilerTimer';\n\n// DEV stuff\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {\n  phase as ReactCurrentDebugFiberPhaseInDEV,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n  getStackByFiberInDevAndProd,\n} from './ReactCurrentFiber';\nimport {\n  recordEffect,\n  recordScheduleUpdate,\n  startWorkTimer,\n  stopWorkTimer,\n  stopFailedWorkTimer,\n  startWorkLoopTimer,\n  stopWorkLoopTimer,\n  startCommitTimer,\n  stopCommitTimer,\n  startCommitSnapshotEffectsTimer,\n  stopCommitSnapshotEffectsTimer,\n  startCommitHostEffectsTimer,\n  stopCommitHostEffectsTimer,\n  startCommitLifeCyclesTimer,\n  stopCommitLifeCyclesTimer,\n} from './ReactDebugFiberPerf';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {onCommitRoot} from './ReactFiberDevToolsHook';\n\nconst ceil = Math.ceil;\n\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  IsSomeRendererActing,\n} = ReactSharedInternals;\n\ntype ExecutionContext = number;\n\nconst NoContext = /*                    */ 0b000000;\nconst BatchedContext = /*               */ 0b000001;\nconst EventContext = /*                 */ 0b000010;\nconst DiscreteEventContext = /*         */ 0b000100;\nconst LegacyUnbatchedContext = /*       */ 0b001000;\nconst RenderContext = /*                */ 0b010000;\nconst CommitContext = /*                */ 0b100000;\n\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst RootIncomplete = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\n\nexport type Thenable = {\n  then(resolve: () => mixed, reject?: () => mixed): Thenable | void,\n\n  // Special flag to opt out of tracing interactions across a Suspense boundary.\n  __reactDoNotTraceInteractions?: boolean,\n};\n\n// Describes where we are in the React execution stack\nlet executionContext: ExecutionContext = NoContext;\n// The root we're working on\nlet workInProgressRoot: FiberRoot | null = null;\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n// The expiration time we're rendering\nlet renderExpirationTime: ExpirationTime = NoWork;\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\n// A fatal error, if one is thrown\nlet workInProgressRootFatalError: mixed = null;\n// Most recent event time among processed updates during this render.\n// This is conceptually a time stamp but expressed in terms of an ExpirationTime\n// because we deal mostly with expiration times in the hot path, so this avoids\n// the conversion happening in the hot path.\nlet workInProgressRootLatestProcessedExpirationTime: ExpirationTime = Sync;\nlet workInProgressRootLatestSuspenseTimeout: ExpirationTime = Sync;\nlet workInProgressRootCanSuspendUsingConfig: null | SuspenseConfig = null;\n// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nlet workInProgressRootNextUnprocessedUpdateTime: ExpirationTime = NoWork;\n\n// If we're pinged while rendering we don't always restart immediately.\n// This flag determines if it might be worthwhile to restart if an opportunity\n// happens latere.\nlet workInProgressRootHasPendingPing: boolean = false;\n// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nlet globalMostRecentFallbackTime: number = 0;\nconst FALLBACK_THROTTLE_MS: number = 500;\n\nlet nextEffect: Fiber | null = null;\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\n\nlet rootDoesHavePassiveEffects: boolean = false;\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoPriority;\nlet pendingPassiveEffectsExpirationTime: ExpirationTime = NoWork;\n\nlet rootsWithPendingDiscreteUpdates: Map<\n  FiberRoot,\n  ExpirationTime,\n> | null = null;\n\n// Use these to prevent an infinite loop of nested updates\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\n\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount: number = 0;\n\nlet interruptedBy: Fiber | null = null;\n\n// Marks the need to reschedule pending interactions at these expiration times\n// during the commit phase. This enables them to be traced across components\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\n// hydration or SuspenseList.\nlet spawnedWorkDuringRender: null | Array<ExpirationTime> = null;\n\n// Expiration times are computed by adding to the current time (the start\n// time). However, if two updates are scheduled within the same event, we\n// should treat their start times as simultaneous, even if the actual clock\n// time has advanced between the first and second call.\n\n// In other words, because expiration times determine how updates are batched,\n// we want all updates of like priority that occur within the same event to\n// receive the same expiration time. Otherwise we get tearing.\nlet currentEventTime: ExpirationTime = NoWork;\n\nexport function requestCurrentTimeForUpdate() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\n\nexport function getCurrentTime() {\n  return msToExpirationTime(now());\n}\n\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BlockingMode) === NoMode) {\n    return Sync;\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\nexport function scheduleUpdateOnFiber(\n  fiber: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  checkForNestedUpdates();\n  warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);\n\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n  if (root === null) {\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  }\n\n  checkForInterruption(fiber, expirationTime);\n  recordScheduleUpdate();\n\n  // TODO: computeExpirationForFiber also reads the priority. Pass the\n  // priority as an argument to that function and this one.\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if (expirationTime === Sync) {\n    if (\n      // Check if we're inside unbatchedUpdates\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\n      // Check if we're not already rendering\n      (executionContext & (RenderContext | CommitContext)) === NoContext\n    ) {\n      // Register pending interactions on the root to avoid losing traced interaction data.\n      schedulePendingInteractions(root, expirationTime);\n\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n      // root inside of batchedUpdates should be synchronous, but layout updates\n      // should be deferred until the end of the batch.\n      performSyncWorkOnRoot(root);\n    } else {\n      ensureRootIsScheduled(root);\n      schedulePendingInteractions(root, expirationTime);\n      if (executionContext === NoContext) {\n        // Flush the synchronous work now, unless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initiated\n        // updates, to preserve historical behavior of legacy mode.\n        flushSyncCallbackQueue();\n      }\n    }\n  } else {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, expirationTime);\n  }\n\n  if (\n    (executionContext & DiscreteEventContext) !== NoContext &&\n    // Only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (priorityLevel === UserBlockingPriority ||\n      priorityLevel === ImmediatePriority)\n  ) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\nexport const scheduleWork = scheduleUpdateOnFiber;\n\n// This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  let node = fiber.return;\n  let root = null;\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    }\n    // Mark that the root has a pending update.\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\nfunction getNextRootExpirationTimeToWorkOn(root: FiberRoot): ExpirationTime {\n  // Determines the next expiration time that the root should render, taking\n  // into account levels that may be suspended, or levels that may have\n  // received a ping.\n\n  const lastExpiredTime = root.lastExpiredTime;\n  if (lastExpiredTime !== NoWork) {\n    return lastExpiredTime;\n  }\n\n  // \"Pending\" refers to any update that hasn't committed yet, including if it\n  // suspended. The \"suspended\" range is therefore a subset.\n  const firstPendingTime = root.firstPendingTime;\n  if (!isRootSuspendedAtTime(root, firstPendingTime)) {\n    // The highest priority pending time is not suspended. Let's work on that.\n    return firstPendingTime;\n  }\n\n  // If the first pending time is suspended, check if there's a lower priority\n  // pending level that we know about. Or check if we received a ping. Work\n  // on whichever is higher priority.\n  const lastPingedTime = root.lastPingedTime;\n  const nextKnownPendingLevel = root.nextKnownPendingLevel;\n  return lastPingedTime > nextKnownPendingLevel\n    ? lastPingedTime\n    : nextKnownPendingLevel;\n}\n\n// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\nfunction ensureRootIsScheduled(root: FiberRoot) {\n  const lastExpiredTime = root.lastExpiredTime;\n  if (lastExpiredTime !== NoWork) {\n    // Special case: Expired work should flush synchronously.\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(\n      performSyncWorkOnRoot.bind(null, root),\n    );\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n    return;\n  }\n\n  // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n  const currentTime = requestCurrentTimeForUpdate();\n  const priorityLevel = inferPriorityFromExpirationTime(\n    currentTime,\n    expirationTime,\n  );\n\n  // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n    if (\n      // Callback must have the exact same expiration time.\n      existingCallbackExpirationTime === expirationTime &&\n      // Callback must have greater or equal priority.\n      existingCallbackPriority >= priorityLevel\n    ) {\n      // Existing callback is sufficient.\n      return;\n    }\n    // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n\n  let callbackNode;\n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  } else {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n      // Compute a task timeout based on the expiration time. This also affects\n      // ordering because tasks are processed in timeout order.\n      {timeout: expirationTimeToMs(expirationTime) - now()},\n    );\n  }\n\n  root.callbackNode = callbackNode;\n}\n\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoWork;\n\n  if (didTimeout) {\n    // The render task took too long to complete. Mark the current time as\n    // expired to synchronously render all expired work in a single batch.\n    const currentTime = requestCurrentTimeForUpdate();\n    markRootExpiredAtTime(root, currentTime);\n    // This will schedule a synchronous callback.\n    ensureRootIsScheduled(root);\n    return null;\n  }\n\n  // Determine the next expiration time to work on, using the fields stored\n  // on the root.\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  if (expirationTime !== NoWork) {\n    const originalCallbackNode = root.callbackNode;\n    invariant(\n      (executionContext & (RenderContext | CommitContext)) === NoContext,\n      'Should not already be working.',\n    );\n\n    flushPassiveEffects();\n\n    // If the root or expiration time have changed, throw out the existing stack\n    // and prepare a fresh one. Otherwise we'll continue where we left off.\n    if (\n      root !== workInProgressRoot ||\n      expirationTime !== renderExpirationTime\n    ) {\n      prepareFreshStack(root, expirationTime);\n      startWorkOnPendingInteractions(root, expirationTime);\n    }\n\n    // If we have a work-in-progress fiber, it means there's still work to do\n    // in this root.\n    if (workInProgress !== null) {\n      const prevExecutionContext = executionContext;\n      executionContext |= RenderContext;\n      const prevDispatcher = pushDispatcher(root);\n      const prevInteractions = pushInteractions(root);\n      startWorkLoopTimer(workInProgress);\n      do {\n        try {\n          workLoopConcurrent();\n          break;\n        } catch (thrownValue) {\n          handleError(root, thrownValue);\n        }\n      } while (true);\n      resetContextDependencies();\n      executionContext = prevExecutionContext;\n      popDispatcher(prevDispatcher);\n      if (enableSchedulerTracing) {\n        popInteractions(((prevInteractions: any): Set<Interaction>));\n      }\n\n      if (workInProgressRootExitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        stopInterruptedWorkLoopTimer();\n        prepareFreshStack(root, expirationTime);\n        markRootSuspendedAtTime(root, expirationTime);\n        ensureRootIsScheduled(root);\n        throw fatalError;\n      }\n\n      if (workInProgress !== null) {\n        // There's still work left over. Exit without committing.\n        stopInterruptedWorkLoopTimer();\n      } else {\n        // We now have a consistent tree. The next step is either to commit it,\n        // or, if something suspended, wait to commit it after a timeout.\n        stopFinishedWorkLoopTimer();\n\n        const finishedWork: Fiber = ((root.finishedWork =\n          root.current.alternate): any);\n        root.finishedExpirationTime = expirationTime;\n        finishConcurrentRender(\n          root,\n          finishedWork,\n          workInProgressRootExitStatus,\n          expirationTime,\n        );\n      }\n\n      ensureRootIsScheduled(root);\n      if (root.callbackNode === originalCallbackNode) {\n        // The task node scheduled for this root is the same one that's\n        // currently executed. Need to return a continuation.\n        return performConcurrentWorkOnRoot.bind(null, root);\n      }\n    }\n  }\n  return null;\n}\n\nfunction finishConcurrentRender(\n  root,\n  finishedWork,\n  exitStatus,\n  expirationTime,\n) {\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  switch (exitStatus) {\n    case RootIncomplete:\n    case RootFatalErrored: {\n      invariant(false, 'Root did not complete. This is a bug in React.');\n    }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n    case RootErrored: {\n      // If this was an async render, the error may have happened due to\n      // a mutation in a concurrent event. Try rendering one more time,\n      // synchronously, to see if the error goes away. If there are\n      // lower priority updates, let's include those, too, in case they\n      // fix the inconsistency. Render at Idle to include all updates.\n      // If it was Idle or Never or some not-yet-invented time, render\n      // at that time.\n      markRootExpiredAtTime(\n        root,\n        expirationTime > Idle ? Idle : expirationTime,\n      );\n      // We assume that this second render pass will be synchronous\n      // and therefore not hit this path again.\n      break;\n    }\n    case RootSuspended: {\n      markRootSuspendedAtTime(root, expirationTime);\n      const lastSuspendedTime = root.lastSuspendedTime;\n      if (expirationTime === lastSuspendedTime) {\n        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n      }\n      flushSuspensePriorityWarningInDEV();\n\n      // We have an acceptable loading state. We need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      // If we have processed new updates during this render, we may now\n      // have a new loading state ready. We want to ensure that we commit\n      // that as soon as possible.\n      const hasNotProcessedNewUpdates =\n        workInProgressRootLatestProcessedExpirationTime === Sync;\n      if (\n        hasNotProcessedNewUpdates &&\n        // do not delay if we're inside an act() scope\n        !(\n          __DEV__ &&\n          flushSuspenseFallbacksInTests &&\n          IsThisRendererActing.current\n        )\n      ) {\n        // If we have not processed any new updates during this pass, then\n        // this is either a retry of an existing fallback state or a\n        // hidden tree. Hidden trees shouldn't be batched with other work\n        // and after that's fixed it can only be a retry. We're going to\n        // throttle committing retries so that we don't show too many\n        // loading states too quickly.\n        let msUntilTimeout =\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          if (workInProgressRootHasPendingPing) {\n            const lastPingedTime = root.lastPingedTime;\n            if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n              // This render was pinged but we didn't get to restart\n              // earlier so try restarting now instead.\n              root.lastPingedTime = expirationTime;\n              prepareFreshStack(root, expirationTime);\n              break;\n            }\n          }\n\n          const nextTime = getNextRootExpirationTimeToWorkOn(root);\n          if (nextTime !== NoWork && nextTime !== expirationTime) {\n            // There's additional work on this root.\n            break;\n          }\n          if (\n            lastSuspendedTime !== NoWork &&\n            lastSuspendedTime !== expirationTime\n          ) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            root.lastPingedTime = lastSuspendedTime;\n            break;\n          }\n\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootSuspendedWithDelay: {\n      markRootSuspendedAtTime(root, expirationTime);\n      const lastSuspendedTime = root.lastSuspendedTime;\n      if (expirationTime === lastSuspendedTime) {\n        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n      }\n      flushSuspensePriorityWarningInDEV();\n\n      if (\n        // do not delay if we're inside an act() scope\n        !(\n          __DEV__ &&\n          flushSuspenseFallbacksInTests &&\n          IsThisRendererActing.current\n        )\n      ) {\n        // We're suspended in a state that should be avoided. We'll try to\n        // avoid committing it for as long as the timeouts let us.\n        if (workInProgressRootHasPendingPing) {\n          const lastPingedTime = root.lastPingedTime;\n          if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n            // This render was pinged but we didn't get to restart earlier\n            // so try restarting now instead.\n            root.lastPingedTime = expirationTime;\n            prepareFreshStack(root, expirationTime);\n            break;\n          }\n        }\n\n        const nextTime = getNextRootExpirationTimeToWorkOn(root);\n        if (nextTime !== NoWork && nextTime !== expirationTime) {\n          // There's additional work on this root.\n          break;\n        }\n        if (\n          lastSuspendedTime !== NoWork &&\n          lastSuspendedTime !== expirationTime\n        ) {\n          // We should prefer to render the fallback of at the last\n          // suspended level. Ping the last suspended level to try\n          // rendering it again.\n          root.lastPingedTime = lastSuspendedTime;\n          break;\n        }\n\n        let msUntilTimeout;\n        if (workInProgressRootLatestSuspenseTimeout !== Sync) {\n          // We have processed a suspense config whose expiration time we\n          // can use as the timeout.\n          msUntilTimeout =\n            expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();\n        } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {\n          // This should never normally happen because only new updates\n          // cause delayed states, so we should have processed something.\n          // However, this could also happen in an offscreen tree.\n          msUntilTimeout = 0;\n        } else {\n          // If we don't have a suspense config, we're going to use a\n          // heuristic to determine how long we can suspend.\n          const eventTimeMs: number = inferTimeFromExpirationTime(\n            workInProgressRootLatestProcessedExpirationTime,\n          );\n          const currentTimeMs = now();\n          const timeUntilExpirationMs =\n            expirationTimeToMs(expirationTime) - currentTimeMs;\n          let timeElapsed = currentTimeMs - eventTimeMs;\n          if (timeElapsed < 0) {\n            // We get this wrong some time since we estimate the time.\n            timeElapsed = 0;\n          }\n\n          msUntilTimeout = jnd(timeElapsed) - timeElapsed;\n\n          // Clamp the timeout to the expiration time. TODO: Once the\n          // event time is exact instead of inferred from expiration time\n          // we don't need this.\n          if (timeUntilExpirationMs < msUntilTimeout) {\n            msUntilTimeout = timeUntilExpirationMs;\n          }\n        }\n\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      if (\n        // do not delay if we're inside an act() scope\n        !(\n          __DEV__ &&\n          flushSuspenseFallbacksInTests &&\n          IsThisRendererActing.current\n        ) &&\n        workInProgressRootLatestProcessedExpirationTime !== Sync &&\n        workInProgressRootCanSuspendUsingConfig !== null\n      ) {\n        // If we have exceeded the minimum loading delay, which probably\n        // means we have shown a spinner already, we might have to suspend\n        // a bit longer to ensure that the spinner is shown for\n        // enough time.\n        const msUntilTimeout = computeMsUntilSuspenseLoadingDelay(\n          workInProgressRootLatestProcessedExpirationTime,\n          expirationTime,\n          workInProgressRootCanSuspendUsingConfig,\n        );\n        if (msUntilTimeout > 10) {\n          markRootSuspendedAtTime(root, expirationTime);\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      commitRoot(root);\n      break;\n    }\n    default: {\n      invariant(false, 'Unknown root exit status.');\n    }\n  }\n}\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  // Check if there's expired work on this root. Otherwise, render at Sync.\n  const lastExpiredTime = root.lastExpiredTime;\n  const expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;\n  if (root.finishedExpirationTime === expirationTime) {\n    // There's already a pending commit at this expiration time.\n    // TODO: This is poorly factored. This case only exists for the\n    // batch.commit() API.\n    commitRoot(root);\n  } else {\n    invariant(\n      (executionContext & (RenderContext | CommitContext)) === NoContext,\n      'Should not already be working.',\n    );\n\n    flushPassiveEffects();\n\n    // If the root or expiration time have changed, throw out the existing stack\n    // and prepare a fresh one. Otherwise we'll continue where we left off.\n    if (\n      root !== workInProgressRoot ||\n      expirationTime !== renderExpirationTime\n    ) {\n      prepareFreshStack(root, expirationTime);\n      startWorkOnPendingInteractions(root, expirationTime);\n    }\n\n    // If we have a work-in-progress fiber, it means there's still work to do\n    // in this root.\n    if (workInProgress !== null) {\n      const prevExecutionContext = executionContext;\n      executionContext |= RenderContext;\n      const prevDispatcher = pushDispatcher(root);\n      const prevInteractions = pushInteractions(root);\n      startWorkLoopTimer(workInProgress);\n\n      do {\n        try {\n          workLoopSync();\n          break;\n        } catch (thrownValue) {\n          handleError(root, thrownValue);\n        }\n      } while (true);\n      resetContextDependencies();\n      executionContext = prevExecutionContext;\n      popDispatcher(prevDispatcher);\n      if (enableSchedulerTracing) {\n        popInteractions(((prevInteractions: any): Set<Interaction>));\n      }\n\n      if (workInProgressRootExitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        stopInterruptedWorkLoopTimer();\n        prepareFreshStack(root, expirationTime);\n        markRootSuspendedAtTime(root, expirationTime);\n        ensureRootIsScheduled(root);\n        throw fatalError;\n      }\n\n      if (workInProgress !== null) {\n        // This is a sync render, so we should have finished the whole tree.\n        invariant(\n          false,\n          'Cannot commit an incomplete root. This error is likely caused by a ' +\n            'bug in React. Please file an issue.',\n        );\n      } else {\n        // We now have a consistent tree. Because this is a sync render, we\n        // will commit it even if something suspended.\n        stopFinishedWorkLoopTimer();\n        root.finishedWork = (root.current.alternate: any);\n        root.finishedExpirationTime = expirationTime;\n        finishSyncRender(root, workInProgressRootExitStatus, expirationTime);\n      }\n\n      // Before exiting, make sure there's a callback scheduled for the next\n      // pending level.\n      ensureRootIsScheduled(root);\n    }\n  }\n\n  return null;\n}\n\nfunction finishSyncRender(root, exitStatus, expirationTime) {\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  if (__DEV__) {\n    if (exitStatus === RootSuspended || exitStatus === RootSuspendedWithDelay) {\n      flushSuspensePriorityWarningInDEV();\n    }\n  }\n  commitRoot(root);\n}\n\nexport function flushRoot(root: FiberRoot, expirationTime: ExpirationTime) {\n  markRootExpiredAtTime(root, expirationTime);\n  ensureRootIsScheduled(root);\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function flushDiscreteUpdates() {\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\n  // as a public API.\n  if (\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\n    NoContext\n  ) {\n    if (__DEV__ && (executionContext & RenderContext) !== NoContext) {\n      warning(\n        false,\n        'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\n          'already rendering.',\n      );\n    }\n    // We're already rendering, so we can't synchronously flush pending work.\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\n    // like `el.focus()`. Exit.\n    return;\n  }\n  flushPendingDiscreteUpdates();\n  // If the discrete updates scheduled passive effects, flush them now so that\n  // they fire before the next serial event.\n  flushPassiveEffects();\n}\n\nexport function deferredUpdates<A>(fn: () => A): A {\n  // TODO: Remove in favor of Scheduler.next\n  return runWithPriority(NormalPriority, fn);\n}\n\nexport function syncUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));\n}\n\nfunction flushPendingDiscreteUpdates() {\n  if (rootsWithPendingDiscreteUpdates !== null) {\n    // For each root with pending discrete updates, schedule a callback to\n    // immediately flush them.\n    const roots = rootsWithPendingDiscreteUpdates;\n    rootsWithPendingDiscreteUpdates = null;\n    roots.forEach((expirationTime, root) => {\n      markRootExpiredAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n    });\n    // Now flush the immediate queue.\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= EventContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function discreteUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= DiscreteEventContext;\n  try {\n    // Should this\n    return runWithPriority(UserBlockingPriority, fn.bind(null, a, b, c));\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function flushSync<A, R>(fn: A => R, a: A): R {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(\n      false,\n      'flushSync was called from inside a lifecycle method. It cannot be ' +\n        'called when React is already rendering.',\n    );\n  }\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return runWithPriority(ImmediatePriority, fn.bind(null, a));\n  } finally {\n    executionContext = prevExecutionContext;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function flushControlled(fn: () => mixed): void {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    runWithPriority(ImmediatePriority, fn);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nfunction prepareFreshStack(root, expirationTime) {\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n\n  const timeoutHandle = root.timeoutHandle;\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout;\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null, expirationTime);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootFatalError = null;\n  workInProgressRootLatestProcessedExpirationTime = Sync;\n  workInProgressRootLatestSuspenseTimeout = Sync;\n  workInProgressRootCanSuspendUsingConfig = null;\n  workInProgressRootNextUnprocessedUpdateTime = NoWork;\n  workInProgressRootHasPendingPing = false;\n\n  if (enableSchedulerTracing) {\n    spawnedWorkDuringRender = null;\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    componentsThatTriggeredHighPriSuspend = null;\n  }\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooks();\n      resetCurrentDebugFiberInDEV();\n\n      if (workInProgress === null || workInProgress.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        return null;\n      }\n\n      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n      }\n\n      throwException(\n        root,\n        workInProgress.return,\n        workInProgress,\n        thrownValue,\n        renderExpirationTime,\n      );\n      workInProgress = completeUnitOfWork(workInProgress);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n      continue;\n    }\n    // Return to the normal work loop.\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher(root) {\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nfunction pushInteractions(root) {\n  if (enableSchedulerTracing) {\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n    return prevInteractions;\n  }\n  return null;\n}\n\nfunction popInteractions(prevInteractions) {\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = prevInteractions;\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\n\nexport function markRenderEventTimeAndConfig(\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n): void {\n  if (\n    expirationTime < workInProgressRootLatestProcessedExpirationTime &&\n    expirationTime > Idle\n  ) {\n    workInProgressRootLatestProcessedExpirationTime = expirationTime;\n  }\n  if (suspenseConfig !== null) {\n    if (\n      expirationTime < workInProgressRootLatestSuspenseTimeout &&\n      expirationTime > Idle\n    ) {\n      workInProgressRootLatestSuspenseTimeout = expirationTime;\n      // Most of the time we only have one config and getting wrong is not bad.\n      workInProgressRootCanSuspendUsingConfig = suspenseConfig;\n    }\n  }\n}\n\nexport function markUnprocessedUpdateTime(\n  expirationTime: ExpirationTime,\n): void {\n  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {\n    workInProgressRootNextUnprocessedUpdateTime = expirationTime;\n  }\n}\n\nexport function renderDidSuspend(): void {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\n\nexport function renderDidSuspendDelayIfPossible(): void {\n  if (\n    workInProgressRootExitStatus === RootIncomplete ||\n    workInProgressRootExitStatus === RootSuspended\n  ) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  }\n\n  // Check if there's a lower priority update somewhere else in the tree.\n  if (\n    workInProgressRootNextUnprocessedUpdateTime !== NoWork &&\n    workInProgressRoot !== null\n  ) {\n    // Mark the current render as suspended, and then mark that there's a\n    // pending update.\n    // TODO: This should immediately interrupt the current render, instead\n    // of waiting until the next time we yield.\n    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime);\n    markRootUpdatedAtTime(\n      workInProgressRoot,\n      workInProgressRootNextUnprocessedUpdateTime,\n    );\n  }\n}\n\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootCompleted) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n}\n\n// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nexport function renderHasNotSuspendedYet(): boolean {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction inferTimeFromExpirationTime(expirationTime: ExpirationTime): number {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction inferTimeFromExpirationTimeWithSuspenseConfig(\n  expirationTime: ExpirationTime,\n  suspenseConfig: SuspenseConfig,\n): number {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time by subtracting the timeout\n  // that was added to the event time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return (\n    earliestExpirationTimeMs -\n    (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION)\n  );\n}\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n\n  startWorkTimer(unitOfWork);\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\nfunction completeUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  workInProgress = unitOfWork;\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = workInProgress.alternate;\n    const returnFiber = workInProgress.return;\n\n    // Check if the work completed or if something threw.\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      setCurrentDebugFiberInDEV(workInProgress);\n      let next;\n      if (\n        !enableProfilerTimer ||\n        (workInProgress.mode & ProfileMode) === NoMode\n      ) {\n        next = completeWork(current, workInProgress, renderExpirationTime);\n      } else {\n        startProfilerTimer(workInProgress);\n        next = completeWork(current, workInProgress, renderExpirationTime);\n        // Update render duration assuming we didn't error.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n      stopWorkTimer(workInProgress);\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(workInProgress);\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        return next;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if needed,\n        // by doing multiple passes over the effect list. We don't want to\n        // schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        const effectTag = workInProgress.effectTag;\n\n        // Skip both NoWork and PerformedWork tags when creating the effect\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\n        // committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, renderExpirationTime);\n\n      // Because this fiber did not complete, don't reset its expiration time.\n\n      if (\n        enableProfilerTimer &&\n        (workInProgress.mode & ProfileMode) !== NoMode\n      ) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        // TODO: The name stopFailedWorkTimer is misleading because Suspense\n        // also captures and restarts.\n        stopFailedWorkTimer(workInProgress);\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n      stopWorkTimer(workInProgress);\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    }\n\n    const siblingFiber = workInProgress.sibling;\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      return siblingFiber;\n    }\n    // Otherwise, return to the parent\n    workInProgress = returnFiber;\n  } while (workInProgress !== null);\n\n  // We've reached the root.\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n  return null;\n}\n\nfunction getRemainingExpirationTime(fiber: Fiber) {\n  const updateExpirationTime = fiber.expirationTime;\n  const childExpirationTime = fiber.childExpirationTime;\n  return updateExpirationTime > childExpirationTime\n    ? updateExpirationTime\n    : childExpirationTime;\n}\n\nfunction resetChildExpirationTime(completedWork: Fiber) {\n  if (\n    renderExpirationTime !== Never &&\n    completedWork.childExpirationTime === Never\n  ) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n    // In profiling mode, resetChildExpirationTime is also used to reset\n    // profiler durations.\n    let actualDuration = completedWork.actualDuration;\n    let treeBaseDuration = completedWork.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration. If\n    // the fiber has not been cloned though, (meaning no work was done), then\n    // this value will reflect the amount of time spent working on a previous\n    // render. In that case it should not bubble. We determine whether it was\n    // cloned by comparing the child pointer.\n    const shouldBubbleActualDurations =\n      completedWork.alternate === null ||\n      completedWork.child !== completedWork.alternate.child;\n\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    completedWork.actualDuration = actualDuration;\n    completedWork.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      child = child.sibling;\n    }\n  }\n\n  completedWork.childExpirationTime = newChildExpirationTime;\n}\n\nfunction commitRoot(root) {\n  const renderPriorityLevel = getCurrentPriorityLevel();\n  runWithPriority(\n    ImmediatePriority,\n    commitRootImpl.bind(null, root, renderPriorityLevel),\n  );\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Should not already be working.',\n  );\n\n  const finishedWork = root.finishedWork;\n  const expirationTime = root.finishedExpirationTime;\n  if (finishedWork === null) {\n    return null;\n  }\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n\n  invariant(\n    finishedWork !== root.current,\n    'Cannot commit the same tree as before. This error is likely caused by ' +\n      'a bug in React. Please file an issue.',\n  );\n\n  // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n  root.callbackNode = null;\n  root.callbackExpirationTime = NoWork;\n  root.callbackPriority = NoPriority;\n  root.nextKnownPendingLevel = NoWork;\n\n  startCommitTimer();\n\n  // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n  const remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(\n    finishedWork,\n  );\n  markRootFinishedAtTime(\n    root,\n    expirationTime,\n    remainingExpirationTimeBeforeCommit,\n  );\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    renderExpirationTime = NoWork;\n  } else {\n    // This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  }\n\n  // Get the list of effects.\n  let firstEffect;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if it\n    // had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  if (firstEffect !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext;\n    const prevInteractions = pushInteractions(root);\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    startCommitSnapshotEffectsTimer();\n    prepareForCommit(root.containerInfo);\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitBeforeMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    // The next phase is the mutation phase, where we mutate the host tree.\n    startCommitHostEffectsTimer();\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(\n          null,\n          commitMutationEffects,\n          null,\n          root,\n          renderPriorityLevel,\n        );\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitMutationEffects(root, renderPriorityLevel);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitHostEffectsTimer();\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    startCommitLifeCyclesTimer();\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(\n          null,\n          commitLayoutEffects,\n          null,\n          root,\n          expirationTime,\n        );\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitLayoutEffects(root, expirationTime);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitLifeCyclesTimer();\n\n    nextEffect = null;\n\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    requestPaint();\n\n    if (enableSchedulerTracing) {\n      popInteractions(((prevInteractions: any): Set<Interaction>));\n    }\n    executionContext = prevExecutionContext;\n  } else {\n    // No effects.\n    root.current = finishedWork;\n    // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n    startCommitSnapshotEffectsTimer();\n    stopCommitSnapshotEffectsTimer();\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n    startCommitHostEffectsTimer();\n    stopCommitHostEffectsTimer();\n    startCommitLifeCyclesTimer();\n    stopCommitLifeCyclesTimer();\n  }\n\n  stopCommitTimer();\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsExpirationTime = expirationTime;\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n  } else {\n    // We are done with the effect chain at this point so let's clear the\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\n    // clear this in flushPassiveEffects.\n    nextEffect = firstEffect;\n    while (nextEffect !== null) {\n      const nextNextEffect = nextEffect.nextEffect;\n      nextEffect.nextEffect = null;\n      nextEffect = nextNextEffect;\n    }\n  }\n\n  // Check if there's remaining work on this root\n  const remainingExpirationTime = root.firstPendingTime;\n  if (remainingExpirationTime !== NoWork) {\n    if (enableSchedulerTracing) {\n      if (spawnedWorkDuringRender !== null) {\n        const expirationTimes = spawnedWorkDuringRender;\n        spawnedWorkDuringRender = null;\n        for (let i = 0; i < expirationTimes.length; i++) {\n          scheduleInteractions(\n            root,\n            expirationTimes[i],\n            root.memoizedInteractions,\n          );\n        }\n      }\n      schedulePendingInteractions(root, remainingExpirationTime);\n    }\n  } else {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (enableSchedulerTracing) {\n    if (!rootDidHavePassiveEffects) {\n      // If there are no passive effects, then we can complete the pending interactions.\n      // Otherwise, we'll wait until after the passive effects are flushed.\n      // Wait to do this until after remaining work has been scheduled,\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\n      finishPendingInteractions(root, expirationTime);\n    }\n  }\n\n  if (remainingExpirationTime === Sync) {\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  onCommitRoot(finishedWork.stateNode, expirationTime);\n\n  // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n  ensureRootIsScheduled(root);\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\n    // This is a legacy edge case. We just committed the initial mount of\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\n    // synchronously, but layout updates should be deferred until the end\n    // of the batch.\n    return null;\n  }\n\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbackQueue();\n  return null;\n}\n\nfunction commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n    if ((effectTag & Snapshot) !== NoEffect) {\n      setCurrentDebugFiberInDEV(nextEffect);\n      recordEffect();\n\n      const current = nextEffect.alternate;\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n\n      resetCurrentDebugFiberInDEV();\n    }\n    if ((effectTag & Passive) !== NoEffect) {\n      // If there are passive effects, schedule a callback to flush at\n      // the earliest opportunity.\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitMutationEffects(root: FiberRoot, renderPriorityLevel) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every possible\n    // bitmap value, we remove the secondary effects from the effect tag and\n    // switch on that value.\n    let primaryEffectTag =\n      effectTag & (Placement | Update | Deletion | Hydrating);\n    switch (primaryEffectTag) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n        // and isMounted is deprecated anyway so we should be able to kill this.\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Hydrating: {\n        nextEffect.effectTag &= ~Hydrating;\n        break;\n      }\n      case HydratingAndUpdate: {\n        nextEffect.effectTag &= ~Hydrating;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(root, nextEffect, renderPriorityLevel);\n        break;\n      }\n    }\n\n    // TODO: Only record a mutation effect if primaryEffectTag is non-zero.\n    recordEffect();\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitLayoutEffects(\n  root: FiberRoot,\n  committedExpirationTime: ExpirationTime,\n) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(\n        root,\n        current,\n        nextEffect,\n        committedExpirationTime,\n      );\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nexport function flushPassiveEffects() {\n  if (pendingPassiveEffectsRenderPriority !== NoPriority) {\n    const priorityLevel =\n      pendingPassiveEffectsRenderPriority > NormalPriority\n        ? NormalPriority\n        : pendingPassiveEffectsRenderPriority;\n    pendingPassiveEffectsRenderPriority = NoPriority;\n    return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n  const root = rootWithPendingPassiveEffects;\n  const expirationTime = pendingPassiveEffectsExpirationTime;\n  rootWithPendingPassiveEffects = null;\n  pendingPassiveEffectsExpirationTime = NoWork;\n\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Cannot flush passive effects while already rendering.',\n  );\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  const prevInteractions = pushInteractions(root);\n\n  // Note: This currently assumes there are no passive effects on the root\n  // fiber, because the root is not part of its own effect list. This could\n  // change in the future.\n  let effect = root.current.firstEffect;\n  while (effect !== null) {\n    if (__DEV__) {\n      setCurrentDebugFiberInDEV(effect);\n      invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n      if (hasCaughtError()) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        const error = clearCaughtError();\n        captureCommitPhaseError(effect, error);\n      }\n      resetCurrentDebugFiberInDEV();\n    } else {\n      try {\n        commitPassiveHookEffects(effect);\n      } catch (error) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        captureCommitPhaseError(effect, error);\n      }\n    }\n    const nextNextEffect = effect.nextEffect;\n    // Remove nextEffect pointer to assist GC\n    effect.nextEffect = null;\n    effect = nextNextEffect;\n  }\n\n  if (enableSchedulerTracing) {\n    popInteractions(((prevInteractions: any): Set<Interaction>));\n    finishPendingInteractions(root, expirationTime);\n  }\n\n  executionContext = prevExecutionContext;\n\n  flushSyncCallbackQueue();\n\n  // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n  nestedPassiveUpdateCount =\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error: mixed) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(\n  rootFiber: Fiber,\n  sourceFiber: Fiber,\n  error: mixed,\n) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, Sync);\n  enqueueUpdate(rootFiber, update);\n  const root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, Sync);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = sourceFiber.return;\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n      if (\n        typeof ctor.getDerivedStateFromError === 'function' ||\n        (typeof instance.componentDidCatch === 'function' &&\n          !isAlreadyFailedLegacyErrorBoundary(instance))\n      ) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(\n          fiber,\n          errorInfo,\n          // TODO: This is always sync\n          Sync,\n        );\n        enqueueUpdate(fiber, update);\n        const root = markUpdateTimeFromFiberToRoot(fiber, Sync);\n        if (root !== null) {\n          ensureRootIsScheduled(root);\n          schedulePendingInteractions(root, Sync);\n        }\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n}\n\nexport function pingSuspendedRoot(\n  root: FiberRoot,\n  thenable: Thenable,\n  suspendedTime: ExpirationTime,\n) {\n  const pingCache = root.pingCache;\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (workInProgressRoot === root && renderExpirationTime === suspendedTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n\n    // If we're suspended with delay, we'll always suspend so we can always\n    // restart. If we're suspended without any updates, it might be a retry.\n    // If it's early in the retry we can restart. We can't know for sure\n    // whether we'll eventually process an update during this render pass,\n    // but it's somewhat unlikely that we get to a ping before that, since\n    // getting to the root most update is usually very fast.\n    if (\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\n      (workInProgressRootExitStatus === RootSuspended &&\n        workInProgressRootLatestProcessedExpirationTime === Sync &&\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\n    ) {\n      // Restart from the root. Don't need to schedule a ping because\n      // we're already working on this tree.\n      prepareFreshStack(root, renderExpirationTime);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootHasPendingPing = true;\n    }\n    return;\n  }\n\n  if (!isRootSuspendedAtTime(root, suspendedTime)) {\n    // The root is no longer suspended at this time.\n    return;\n  }\n\n  const lastPingedTime = root.lastPingedTime;\n  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {\n    // There's already a lower priority ping scheduled.\n    return;\n  }\n\n  // Mark the time at which this ping was scheduled.\n  root.lastPingedTime = suspendedTime;\n\n  if (root.finishedExpirationTime === suspendedTime) {\n    // If there's a pending fallback waiting to commit, throw it away.\n    root.finishedExpirationTime = NoWork;\n    root.finishedWork = null;\n  }\n\n  ensureRootIsScheduled(root);\n  schedulePendingInteractions(root, suspendedTime);\n}\n\nfunction retryTimedOutBoundary(\n  boundaryFiber: Fiber,\n  retryTime: ExpirationTime,\n) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new expiration time.\n  if (retryTime === NoWork) {\n    const suspenseConfig = null; // Retries don't carry over the already committed update.\n    const currentTime = requestCurrentTimeForUpdate();\n    retryTime = computeExpirationForFiber(\n      currentTime,\n      boundaryFiber,\n      suspenseConfig,\n    );\n  }\n  // TODO: Special case idle priority?\n  const root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, retryTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n  let retryTime = NoWork;\n  if (suspenseState !== null) {\n    retryTime = suspenseState.retryTime;\n  }\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\n\nexport function resolveRetryThenable(boundaryFiber: Fiber, thenable: Thenable) {\n  let retryTime = NoWork; // Default\n  let retryCache: WeakSet<Thenable> | Set<Thenable> | null;\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n        if (suspenseState !== null) {\n          retryTime = suspenseState.retryTime;\n        }\n        break;\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n      default:\n        invariant(\n          false,\n          'Pinged unknown suspense boundary type. ' +\n            'This is probably a bug in React.',\n        );\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\n\n// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed: number) {\n  return timeElapsed < 120\n    ? 120\n    : timeElapsed < 480\n      ? 480\n      : timeElapsed < 1080\n        ? 1080\n        : timeElapsed < 1920\n          ? 1920\n          : timeElapsed < 3000\n            ? 3000\n            : timeElapsed < 4320\n              ? 4320\n              : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction computeMsUntilSuspenseLoadingDelay(\n  mostRecentEventTime: ExpirationTime,\n  committedExpirationTime: ExpirationTime,\n  suspenseConfig: SuspenseConfig,\n) {\n  const busyMinDurationMs = (suspenseConfig.busyMinDurationMs: any) | 0;\n  if (busyMinDurationMs <= 0) {\n    return 0;\n  }\n  const busyDelayMs = (suspenseConfig.busyDelayMs: any) | 0;\n\n  // Compute the time until this render pass would expire.\n  const currentTimeMs: number = now();\n  const eventTimeMs: number = inferTimeFromExpirationTimeWithSuspenseConfig(\n    mostRecentEventTime,\n    suspenseConfig,\n  );\n  const timeElapsed = currentTimeMs - eventTimeMs;\n  if (timeElapsed <= busyDelayMs) {\n    // If we haven't yet waited longer than the initial delay, we don't\n    // have to wait any additional time.\n    return 0;\n  }\n  const msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed;\n  // This is the value that is passed to `setTimeout`.\n  return msUntilTimeout;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    invariant(\n      false,\n      'Maximum update depth exceeded. This can happen when a component ' +\n        'repeatedly calls setState inside componentWillUpdate or ' +\n        'componentDidUpdate. React limits the number of nested updates to ' +\n        'prevent infinite loops.',\n    );\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      warning(\n        false,\n        'Maximum update depth exceeded. This can happen when a component ' +\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\n          'have a dependency array, or one of the dependencies changes on ' +\n          'every render.',\n      );\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction stopFinishedWorkLoopTimer() {\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction stopInterruptedWorkLoopTimer() {\n  // TODO: Track which fiber caused the interruption.\n  const didCompleteRoot = false;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction checkForInterruption(\n  fiberThatReceivedUpdate: Fiber,\n  updateExpirationTime: ExpirationTime,\n) {\n  if (\n    enableUserTimingAPI &&\n    workInProgressRoot !== null &&\n    updateExpirationTime > renderExpirationTime\n  ) {\n    interruptedBy = fiberThatReceivedUpdate;\n  }\n}\n\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    const tag = fiber.tag;\n    if (\n      tag !== HostRoot &&\n      tag !== ClassComponent &&\n      tag !== FunctionComponent &&\n      tag !== ForwardRef &&\n      tag !== MemoComponent &&\n      tag !== SimpleMemoComponent\n    ) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    }\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\n        return;\n      }\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\n    }\n    warningWithoutStack(\n      false,\n      \"Can't perform a React state update on an unmounted component. This \" +\n        'is a no-op, but it indicates a memory leak in your application. To ' +\n        'fix, cancel all subscriptions and asynchronous tasks in %s.%s',\n      tag === ClassComponent\n        ? 'the componentWillUnmount method'\n        : 'a useEffect cleanup function',\n      getStackByFiberInDevAndProd(fiber),\n    );\n  }\n}\n\nlet beginWork;\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  let dummyFiber = null;\n  beginWork = (current, unitOfWork, expirationTime) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\n      dummyFiber,\n      unitOfWork,\n    );\n    try {\n      return originalBeginWork(current, unitOfWork, expirationTime);\n    } catch (originalError) {\n      if (\n        originalError !== null &&\n        typeof originalError === 'object' &&\n        typeof originalError.then === 'function'\n      ) {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      }\n\n      // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n      resetContextDependencies();\n      resetHooks();\n      // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n\n      // Unwind the failed stack frame\n      unwindInterruptedWork(unitOfWork);\n\n      // Restore the original properties of the fiber.\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      }\n\n      // Run beginWork again.\n      invokeGuardedCallback(\n        null,\n        originalBeginWork,\n        null,\n        current,\n        unitOfWork,\n        expirationTime,\n      );\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\n        // Rethrow this error instead of the original one.\n        throw replayError;\n      } else {\n        // This branch is reachable if the render phase is impure.\n        throw originalError;\n      }\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInGetChildContext = false;\nfunction warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.tag === ClassComponent) {\n      switch (ReactCurrentDebugFiberPhaseInDEV) {\n        case 'getChildContext':\n          if (didWarnAboutUpdateInGetChildContext) {\n            return;\n          }\n          warningWithoutStack(\n            false,\n            'setState(...): Cannot call setState() inside getChildContext()',\n          );\n          didWarnAboutUpdateInGetChildContext = true;\n          break;\n        case 'render':\n          if (didWarnAboutUpdateInRender) {\n            return;\n          }\n          warningWithoutStack(\n            false,\n            'Cannot update during an existing state transition (such as ' +\n              'within `render`). Render methods should be a pure function of ' +\n              'props and state.',\n          );\n          didWarnAboutUpdateInRender = true;\n          break;\n      }\n    }\n  }\n}\n\n// a 'shared' variable that changes when act() opens/closes in tests.\nexport const IsThisRendererActing = {current: (false: boolean)};\n\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      IsSomeRendererActing.current === true &&\n      IsThisRendererActing.current !== true\n    ) {\n      warningWithoutStack(\n        false,\n        \"It looks like you're using the wrong act() around your test interactions.\\n\" +\n          'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\n          '// for react-dom:\\n' +\n          \"import {act} from 'react-dom/test-utils';\\n\" +\n          '// ...\\n' +\n          'act(() => ...);\\n\\n' +\n          '// for react-test-renderer:\\n' +\n          \"import TestRenderer from 'react-test-renderer';\\n\" +\n          'const {act} = TestRenderer;\\n' +\n          '// ...\\n' +\n          'act(() => ...);' +\n          '%s',\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      (fiber.mode & StrictMode) !== NoMode &&\n      IsSomeRendererActing.current === false &&\n      IsThisRendererActing.current === false\n    ) {\n      warningWithoutStack(\n        false,\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be ' +\n          'wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      executionContext === NoContext &&\n      IsSomeRendererActing.current === false &&\n      IsThisRendererActing.current === false\n    ) {\n      warningWithoutStack(\n        false,\n        'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be ' +\n          'wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\n\n// In tests, we want to enforce a mocked scheduler.\nlet didWarnAboutUnmockedScheduler = false;\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\n// scheduler is the actual recommendation. The alternative could be a testing build,\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\n// to get their tests right.\n\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\n  if (__DEV__) {\n    if (\n      didWarnAboutUnmockedScheduler === false &&\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\n    ) {\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(\n          false,\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\n            'to guarantee consistent behaviour across tests and browsers. ' +\n            'For example, with jest: \\n' +\n            \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" +\n            'For more info, visit https://fb.me/react-mock-scheduler',\n        );\n      } else if (warnAboutUnmockedScheduler === true) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(\n          false,\n          'Starting from React v17, the \"scheduler\" module will need to be mocked ' +\n            'to guarantee consistent behaviour across tests and browsers. ' +\n            'For example, with jest: \\n' +\n            \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" +\n            'For more info, visit https://fb.me/react-mock-scheduler',\n        );\n      }\n    }\n  }\n}\n\nlet componentsThatTriggeredHighPriSuspend = null;\nexport function checkForWrongSuspensePriorityInDEV(sourceFiber: Fiber) {\n  if (__DEV__) {\n    const currentPriorityLevel = getCurrentPriorityLevel();\n    if (\n      (sourceFiber.mode & ConcurrentMode) !== NoEffect &&\n      (currentPriorityLevel === UserBlockingPriority ||\n        currentPriorityLevel === ImmediatePriority)\n    ) {\n      let workInProgressNode = sourceFiber;\n      while (workInProgressNode !== null) {\n        // Add the component that triggered the suspense\n        const current = workInProgressNode.alternate;\n        if (current !== null) {\n          // TODO: warn component that triggers the high priority\n          // suspend is the HostRoot\n          switch (workInProgressNode.tag) {\n            case ClassComponent:\n              // Loop through the component's update queue and see whether the component\n              // has triggered any high priority updates\n              const updateQueue = current.updateQueue;\n              if (updateQueue !== null) {\n                let update = updateQueue.firstUpdate;\n                while (update !== null) {\n                  const priorityLevel = update.priority;\n                  if (\n                    priorityLevel === UserBlockingPriority ||\n                    priorityLevel === ImmediatePriority\n                  ) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([\n                        getComponentName(workInProgressNode.type),\n                      ]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(\n                        getComponentName(workInProgressNode.type),\n                      );\n                    }\n                    break;\n                  }\n                  update = update.next;\n                }\n              }\n              break;\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent:\n              if (\n                workInProgressNode.memoizedState !== null &&\n                workInProgressNode.memoizedState.baseUpdate !== null\n              ) {\n                let update = workInProgressNode.memoizedState.baseUpdate;\n                // Loop through the functional component's memoized state to see whether\n                // the component has triggered any high pri updates\n                while (update !== null) {\n                  const priority = update.priority;\n                  if (\n                    priority === UserBlockingPriority ||\n                    priority === ImmediatePriority\n                  ) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([\n                        getComponentName(workInProgressNode.type),\n                      ]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(\n                        getComponentName(workInProgressNode.type),\n                      );\n                    }\n                    break;\n                  }\n                  if (\n                    update.next === workInProgressNode.memoizedState.baseUpdate\n                  ) {\n                    break;\n                  }\n                  update = update.next;\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        workInProgressNode = workInProgressNode.return;\n      }\n    }\n  }\n}\n\nfunction flushSuspensePriorityWarningInDEV() {\n  if (__DEV__) {\n    if (componentsThatTriggeredHighPriSuspend !== null) {\n      const componentNames = [];\n      componentsThatTriggeredHighPriSuspend.forEach(name =>\n        componentNames.push(name),\n      );\n      componentsThatTriggeredHighPriSuspend = null;\n\n      if (componentNames.length > 0) {\n        warningWithoutStack(\n          false,\n          '%s triggered a user-blocking update that suspended.' +\n            '\\n\\n' +\n            'The fix is to split the update into multiple parts: a user-blocking ' +\n            'update to provide immediate feedback, and another update that ' +\n            'triggers the bulk of the changes.' +\n            '\\n\\n' +\n            'Refer to the documentation for useTransition to learn how ' +\n            'to implement this pattern.',\n          // TODO: Add link to React docs with more information, once it exists\n          componentNames.sort().join(', '),\n        );\n      }\n    }\n  }\n}\n\nfunction computeThreadID(root, expirationTime) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + root.interactionThreadID;\n}\n\nexport function markSpawnedWork(expirationTime: ExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n  if (spawnedWorkDuringRender === null) {\n    spawnedWorkDuringRender = [expirationTime];\n  } else {\n    spawnedWorkDuringRender.push(expirationTime);\n  }\n}\n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction schedulePendingInteractions(root, expirationTime) {\n  // This is called when work is scheduled on a root.\n  // It associates the current interactions with the newly-scheduled expiration.\n  // They will be restored when that expiration is later committed.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  scheduleInteractions(root, expirationTime, __interactionsRef.current);\n}\n\nfunction startWorkOnPendingInteractions(root, expirationTime) {\n  // This is called when new work is started on a root.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  // Determine which interactions this batch of work currently includes, So that\n  // we can accurately attribute time spent working on it, And so that cascading\n  // work triggered during the render phase will be associated with it.\n  const interactions: Set<Interaction> = new Set();\n  root.pendingInteractionMap.forEach(\n    (scheduledInteractions, scheduledExpirationTime) => {\n      if (scheduledExpirationTime >= expirationTime) {\n        scheduledInteractions.forEach(interaction =>\n          interactions.add(interaction),\n        );\n      }\n    },\n  );\n\n  // Store the current set of interactions on the FiberRoot for a few reasons:\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\n  // without having to recalculate it. We will also use it in commitWork() to\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\n  // way to access it when the onCommitRoot() hook is called.\n  root.memoizedInteractions = interactions;\n\n  if (interactions.size > 0) {\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        // If the subscriber throws, rethrow it in a separate task\n        scheduleCallback(ImmediatePriority, () => {\n          throw error;\n        });\n      }\n    }\n  }\n}\n\nfunction finishPendingInteractions(root, committedExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const earliestRemainingTimeAfterCommit = root.firstPendingTime;\n\n  let subscriber;\n\n  try {\n    subscriber = __subscriberRef.current;\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\n      const threadID = computeThreadID(root, committedExpirationTime);\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n    }\n  } catch (error) {\n    // If the subscriber throws, rethrow it in a separate task\n    scheduleCallback(ImmediatePriority, () => {\n      throw error;\n    });\n  } finally {\n    // Clear completed interactions from the pending Map.\n    // Unless the render was suspended or cascading work was scheduled,\n    // In which case leave pending interactions until the subsequent render.\n    const pendingInteractionMap = root.pendingInteractionMap;\n    pendingInteractionMap.forEach(\n      (scheduledInteractions, scheduledExpirationTime) => {\n        // Only decrement the pending interaction count if we're done.\n        // If there's still work at the current priority,\n        // That indicates that we are waiting for suspense data.\n        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n          pendingInteractionMap.delete(scheduledExpirationTime);\n\n          scheduledInteractions.forEach(interaction => {\n            interaction.__count--;\n\n            if (subscriber !== null && interaction.__count === 0) {\n              try {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              } catch (error) {\n                // If the subscriber throws, rethrow it in a separate task\n                scheduleCallback(ImmediatePriority, () => {\n                  throw error;\n                });\n              }\n            }\n          });\n        }\n      },\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}