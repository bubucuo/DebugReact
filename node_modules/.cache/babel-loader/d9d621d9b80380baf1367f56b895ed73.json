{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableUserTimingAPI } from 'shared/ReactFeatureFlags';\nimport getComponentName from 'shared/getComponentName';\nimport { HostRoot, HostComponent, HostText, HostPortal, Fragment, ContextProvider, ContextConsumer, Mode, SuspenseComponent } from 'shared/ReactWorkTags';\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nconst reactEmoji = '\\u269B';\nconst warningEmoji = '\\u26D4';\nconst supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function'; // Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n\nlet currentFiber = null; // If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\n\nlet currentPhase = null;\nlet currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\n\nlet isCommitting = false;\nlet hasScheduledUpdateInCurrentCommit = false;\nlet hasScheduledUpdateInCurrentPhase = false;\nlet commitCountInCurrentWorkLoop = 0;\nlet effectCountInCurrentCommit = 0;\nlet isWaitingForCallback = false; // During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\n\nconst labelsInCurrentCommit = new Set();\n\nconst formatMarkName = markName => {\n  return `${reactEmoji} ${markName}`;\n};\n\nconst formatLabel = (label, warning) => {\n  const prefix = warning ? `${warningEmoji} ` : `${reactEmoji} `;\n  const suffix = warning ? ` Warning: ${warning}` : '';\n  return `${prefix}${label}${suffix}`;\n};\n\nconst beginMark = markName => {\n  performance.mark(formatMarkName(markName));\n};\n\nconst clearMark = markName => {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nconst endMark = (label, markName, warning) => {\n  const formattedMarkName = formatMarkName(markName);\n  const formattedLabel = formatLabel(label, warning);\n\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {} // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n  // Clear marks immediately to avoid growing buffer.\n\n\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nconst getFiberMarkName = (label, debugID) => {\n  return `${label} (#${debugID})`;\n};\n\nconst getFiberLabel = (componentName, isMounted, phase) => {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return `${componentName} [${isMounted ? 'update' : 'mount'}]`;\n  } else {\n    // Composite component methods.\n    return `${componentName}.${phase}`;\n  }\n};\n\nconst beginFiberMark = (fiber, phase) => {\n  const componentName = getComponentName(fiber.type) || 'Unknown';\n  const debugID = fiber._debugID;\n  const isMounted = fiber.alternate !== null;\n  const label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n\n  labelsInCurrentCommit.add(label);\n  const markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nconst clearFiberMark = (fiber, phase) => {\n  const componentName = getComponentName(fiber.type) || 'Unknown';\n  const debugID = fiber._debugID;\n  const isMounted = fiber.alternate !== null;\n  const label = getFiberLabel(componentName, isMounted, phase);\n  const markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nconst endFiberMark = (fiber, phase, warning) => {\n  const componentName = getComponentName(fiber.type) || 'Unknown';\n  const debugID = fiber._debugID;\n  const isMounted = fiber.alternate !== null;\n  const label = getFiberLabel(componentName, isMounted, phase);\n  const markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning);\n};\n\nconst shouldIgnoreFiber = fiber => {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nconst clearPendingPhaseMeasurement = () => {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nconst pauseTimers = () => {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  let fiber = currentFiber;\n\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n\n    fiber = fiber.return;\n  }\n};\n\nconst resumeTimersRecursively = fiber => {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nconst resumeTimers = () => {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nexport function recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\nexport function recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\nexport function startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\nexport function stopRequestCallbackTimer(didExpire) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      const warning = didExpire ? 'Update expired; will flush synchronously' : null;\n      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning);\n    }\n  }\n}\nexport function startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    } // If we pause, this is the fiber to unwind from.\n\n\n    currentFiber = fiber;\n\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\nexport function cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    } // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n\n\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\nexport function stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    } // If we pause, its parent is the fiber to unwind from.\n\n\n    currentFiber = fiber.return;\n\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\nexport function stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    } // If we pause, its parent is the fiber to unwind from.\n\n\n    currentFiber = fiber.return;\n\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n\n    fiber._debugIsCurrentlyTiming = false;\n    const warning = fiber.tag === SuspenseComponent ? 'Rendering was suspended' : 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning);\n  }\n}\nexport function startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    clearPendingPhaseMeasurement();\n\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\nexport function stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      const warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning);\n    }\n\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\nexport function startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    commitCountInCurrentWorkLoop = 0; // This is top level call.\n    // Any other measurements are performed within.\n\n    beginMark('(React Tree Reconciliation)'); // Resume any measurements that were in progress during the last loop.\n\n    resumeTimers();\n  }\n}\nexport function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    let warning = null;\n\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning = 'A top-level update interrupted the previous render';\n      } else {\n        const componentName = getComponentName(interruptedBy.type) || 'Unknown';\n        warning = `An update to ${componentName} interrupted the previous render`;\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning = 'There were cascading updates';\n    }\n\n    commitCountInCurrentWorkLoop = 0;\n    let label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)'; // Pause any measurements until the next loop.\n\n    pauseTimers();\n    endMark(label, '(React Tree Reconciliation)', warning);\n  }\n}\nexport function startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\nexport function stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    let warning = null;\n\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning = 'Caused by a cascading update in earlier commit';\n    }\n\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n    endMark('(Committing Changes)', '(Committing Changes)', warning);\n  }\n}\nexport function startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Snapshot Effects)');\n  }\n}\nexport function stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    const count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(`(Committing Snapshot Effects: ${count} Total)`, '(Committing Snapshot Effects)', null);\n  }\n}\nexport function startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\nexport function stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    const count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(`(Committing Host Effects: ${count} Total)`, '(Committing Host Effects)', null);\n  }\n}\nexport function startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\nexport function stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    const count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(`(Calling Lifecycle Methods: ${count} Total)`, '(Calling Lifecycle Methods)', null);\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactDebugFiberPerf.js"],"names":["enableUserTimingAPI","getComponentName","HostRoot","HostComponent","HostText","HostPortal","Fragment","ContextProvider","ContextConsumer","Mode","SuspenseComponent","reactEmoji","warningEmoji","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","isMounted","phase","beginFiberMark","fiber","type","_debugID","alternate","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","tag","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","return","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","didCompleteRoot","startCommitTimer","clear","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","count","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\n\nimport {enableUserTimingAPI} from 'shared/ReactFeatureFlags';\nimport getComponentName from 'shared/getComponentName';\nimport {\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  Fragment,\n  ContextProvider,\n  ContextConsumer,\n  Mode,\n  SuspenseComponent,\n} from 'shared/ReactWorkTags';\n\ntype MeasurementPhase =\n  | 'componentWillMount'\n  | 'componentWillUnmount'\n  | 'componentWillReceiveProps'\n  | 'shouldComponentUpdate'\n  | 'componentWillUpdate'\n  | 'componentDidUpdate'\n  | 'componentDidMount'\n  | 'getChildContext'\n  | 'getSnapshotBeforeUpdate';\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nconst reactEmoji = '\\u269B';\nconst warningEmoji = '\\u26D4';\nconst supportsUserTiming =\n  typeof performance !== 'undefined' &&\n  typeof performance.mark === 'function' &&\n  typeof performance.clearMarks === 'function' &&\n  typeof performance.measure === 'function' &&\n  typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nlet currentFiber: Fiber | null = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nlet currentPhase: MeasurementPhase | null = null;\nlet currentPhaseFiber: Fiber | null = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nlet isCommitting: boolean = false;\nlet hasScheduledUpdateInCurrentCommit: boolean = false;\nlet hasScheduledUpdateInCurrentPhase: boolean = false;\nlet commitCountInCurrentWorkLoop: number = 0;\nlet effectCountInCurrentCommit: number = 0;\nlet isWaitingForCallback: boolean = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nconst labelsInCurrentCommit: Set<string> = new Set();\n\nconst formatMarkName = (markName: string) => {\n  return `${reactEmoji} ${markName}`;\n};\n\nconst formatLabel = (label: string, warning: string | null) => {\n  const prefix = warning ? `${warningEmoji} ` : `${reactEmoji} `;\n  const suffix = warning ? ` Warning: ${warning}` : '';\n  return `${prefix}${label}${suffix}`;\n};\n\nconst beginMark = (markName: string) => {\n  performance.mark(formatMarkName(markName));\n};\n\nconst clearMark = (markName: string) => {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nconst endMark = (label: string, markName: string, warning: string | null) => {\n  const formattedMarkName = formatMarkName(markName);\n  const formattedLabel = formatLabel(label, warning);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {\n    // If previous mark was missing for some reason, this will throw.\n    // This could only happen if React crashed in an unexpected place earlier.\n    // Don't pile on with more errors.\n  }\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nconst getFiberMarkName = (label: string, debugID: number) => {\n  return `${label} (#${debugID})`;\n};\n\nconst getFiberLabel = (\n  componentName: string,\n  isMounted: boolean,\n  phase: MeasurementPhase | null,\n) => {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return `${componentName} [${isMounted ? 'update' : 'mount'}]`;\n  } else {\n    // Composite component methods.\n    return `${componentName}.${phase}`;\n  }\n};\n\nconst beginFiberMark = (\n  fiber: Fiber,\n  phase: MeasurementPhase | null,\n): boolean => {\n  const componentName = getComponentName(fiber.type) || 'Unknown';\n  const debugID = ((fiber._debugID: any): number);\n  const isMounted = fiber.alternate !== null;\n  const label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  const markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nconst clearFiberMark = (fiber: Fiber, phase: MeasurementPhase | null) => {\n  const componentName = getComponentName(fiber.type) || 'Unknown';\n  const debugID = ((fiber._debugID: any): number);\n  const isMounted = fiber.alternate !== null;\n  const label = getFiberLabel(componentName, isMounted, phase);\n  const markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nconst endFiberMark = (\n  fiber: Fiber,\n  phase: MeasurementPhase | null,\n  warning: string | null,\n) => {\n  const componentName = getComponentName(fiber.type) || 'Unknown';\n  const debugID = ((fiber._debugID: any): number);\n  const isMounted = fiber.alternate !== null;\n  const label = getFiberLabel(componentName, isMounted, phase);\n  const markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning);\n};\n\nconst shouldIgnoreFiber = (fiber: Fiber): boolean => {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nconst clearPendingPhaseMeasurement = () => {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nconst pauseTimers = () => {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  let fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber.return;\n  }\n};\n\nconst resumeTimersRecursively = (fiber: Fiber) => {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nconst resumeTimers = () => {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nexport function recordEffect(): void {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nexport function recordScheduleUpdate(): void {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (\n      currentPhase !== null &&\n      currentPhase !== 'componentWillMount' &&\n      currentPhase !== 'componentWillReceiveProps'\n    ) {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nexport function startRequestCallbackTimer(): void {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nexport function stopRequestCallbackTimer(didExpire: boolean): void {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      const warning = didExpire\n        ? 'Update expired; will flush synchronously'\n        : null;\n      endMark(\n        '(Waiting for async callback...)',\n        '(Waiting for async callback...)',\n        warning,\n      );\n    }\n  }\n}\n\nexport function startWorkTimer(fiber: Fiber): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nexport function cancelWorkTimer(fiber: Fiber): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nexport function stopWorkTimer(fiber: Fiber): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nexport function stopFailedWorkTimer(fiber: Fiber): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    const warning =\n      fiber.tag === SuspenseComponent\n        ? 'Rendering was suspended'\n        : 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning);\n  }\n}\n\nexport function startPhaseTimer(fiber: Fiber, phase: MeasurementPhase): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nexport function stopPhaseTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      const warning = hasScheduledUpdateInCurrentPhase\n        ? 'Scheduled a cascading update'\n        : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nexport function startWorkLoopTimer(nextUnitOfWork: Fiber | null): void {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nexport function stopWorkLoopTimer(\n  interruptedBy: Fiber | null,\n  didCompleteRoot: boolean,\n): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    let warning = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning = 'A top-level update interrupted the previous render';\n      } else {\n        const componentName = getComponentName(interruptedBy.type) || 'Unknown';\n        warning = `An update to ${componentName} interrupted the previous render`;\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    let label = didCompleteRoot\n      ? '(React Tree Reconciliation: Completed Root)'\n      : '(React Tree Reconciliation: Yielded)';\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, '(React Tree Reconciliation)', warning);\n  }\n}\n\nexport function startCommitTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nexport function stopCommitTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    let warning = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning);\n  }\n}\n\nexport function startCommitSnapshotEffectsTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Snapshot Effects)');\n  }\n}\n\nexport function stopCommitSnapshotEffectsTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    const count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      `(Committing Snapshot Effects: ${count} Total)`,\n      '(Committing Snapshot Effects)',\n      null,\n    );\n  }\n}\n\nexport function startCommitHostEffectsTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nexport function stopCommitHostEffectsTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    const count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      `(Committing Host Effects: ${count} Total)`,\n      '(Committing Host Effects)',\n      null,\n    );\n  }\n}\n\nexport function startCommitLifeCyclesTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nexport function stopCommitLifeCyclesTimer(): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    const count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      `(Calling Lifecycle Methods: ${count} Total)`,\n      '(Calling Lifecycle Methods)',\n      null,\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}