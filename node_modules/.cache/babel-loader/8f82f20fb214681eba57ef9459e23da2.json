{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { HostComponent } from './ReactWorkTags';\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n\n  if (inst) {\n    return inst;\n  }\n\n  return null;\n}\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\n\n\nexport function getLowestCommonAncestor(instA, instB) {\n  let depthA = 0;\n\n  for (let tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n\n  let depthB = 0;\n\n  for (let tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  } // If A is deeper, crawl up.\n\n\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  } // If B is deeper, crawl up.\n\n\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  } // Walk in lockstep until we find a match.\n\n\n  let depth = depthA;\n\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n\n  return null;\n}\n/**\n * Return if A is an ancestor of B.\n */\n\nexport function isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n\n    instB = getParent(instB);\n  }\n\n  return false;\n}\n/**\n * Return the parent instance of the passed-in instance.\n */\n\nexport function getParentInstance(inst) {\n  return getParent(inst);\n}\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\n\nexport function traverseTwoPhase(inst, fn, arg) {\n  const path = [];\n\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n\n  let i;\n\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\nexport function traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  const common = from && to ? getLowestCommonAncestor(from, to) : null;\n  const pathFrom = [];\n\n  while (true) {\n    if (!from) {\n      break;\n    }\n\n    if (from === common) {\n      break;\n    }\n\n    const alternate = from.alternate;\n\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n\n  const pathTo = [];\n\n  while (true) {\n    if (!to) {\n      break;\n    }\n\n    if (to === common) {\n      break;\n    }\n\n    const alternate = to.alternate;\n\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n\n    pathTo.push(to);\n    to = getParent(to);\n  }\n\n  for (let i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n\n  for (let i = pathTo.length; i-- > 0;) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/shared/ReactTreeTraversal.js"],"names":["HostComponent","getParent","inst","return","tag","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","push","i","length","traverseEnterLeave","from","to","argFrom","argTo","common","pathFrom","pathTo"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {HostComponent} from './ReactWorkTags';\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nexport function getLowestCommonAncestor(instA, instB) {\n  let depthA = 0;\n  for (let tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  let depthB = 0;\n  for (let tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  let depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nexport function isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nexport function getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nexport function traverseTwoPhase(inst, fn, arg) {\n  const path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  let i;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nexport function traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  const common = from && to ? getLowestCommonAncestor(from, to) : null;\n  const pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    const alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  const pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    const alternate = to.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (let i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (let i = pathTo.length; i-- > 0; ) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}