{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { now } from './SchedulerWithReactIntegration';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, ContextProvider, ContextConsumer, ForwardRef, Fragment, Mode, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, FundamentalComponent, ScopeComponent } from 'shared/ReactWorkTags';\nimport { NoMode, BlockingMode } from './ReactTypeOfMode';\nimport { Ref, Update, NoEffect, DidCapture, Deletion } from 'shared/ReactSideEffectTags';\nimport invariant from 'shared/invariant';\nimport { createInstance, createTextInstance, appendInitialChild, finalizeInitialChildren, prepareUpdate, supportsMutation, supportsPersistence, cloneInstance, cloneHiddenInstance, cloneHiddenTextInstance, createContainerChildSet, appendChildToContainerChildSet, finalizeContainerChildren, getFundamentalComponentInstance, mountFundamentalComponent, cloneFundamentalInstance, shouldUpdateFundamentalComponent } from './ReactFiberHostConfig';\nimport { getRootHostContainer, popHostContext, getHostContext, popHostContainer } from './ReactFiberHostContext';\nimport { suspenseStackCursor, InvisibleParentSuspenseContext, hasSuspenseContext, popSuspenseContext, pushSuspenseContext, setShallowSuspenseContext, ForceSuspenseFallback, setDefaultShallowSuspenseContext } from './ReactFiberSuspenseContext';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent';\nimport { isContextProvider as isLegacyContextProvider, popContext as popLegacyContext, popTopLevelContextObject as popTopLevelLegacyContextObject } from './ReactFiberContext';\nimport { popProvider } from './ReactFiberNewContext';\nimport { prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, popHydrationState, resetHydrationState } from './ReactFiberHydrationContext';\nimport { enableSchedulerTracing, enableSuspenseCallback, enableSuspenseServerRenderer, enableFlareAPI, enableFundamentalAPI, enableScopeAPI } from 'shared/ReactFeatureFlags';\nimport { markSpawnedWork, renderDidSuspend, renderDidSuspendDelayIfPossible, renderHasNotSuspendedYet } from './ReactFiberWorkLoop';\nimport { createFundamentalStateInstance } from './ReactFiberFundamental';\nimport { Never } from './ReactFiberExpirationTime';\nimport { resetChildFibers } from './ReactChildFiber';\nimport { updateEventListeners } from './ReactFiberEvents';\nimport { createScopeMethods } from './ReactFiberScope';\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef(workInProgress) {\n  workInProgress.effectTag |= Ref;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\n\nif (supportsMutation) {\n  // Mutation mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n        appendInitialChild(parent, node.stateNode.instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    } // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n\n\n    const instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n\n    const updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n\n    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n        let instance = node.stateNode.instance;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === SuspenseComponent) {\n        if ((node.effectTag & Update) !== NoEffect) {\n          // Need to toggle the visibility of the primary children.\n          const newIsHidden = node.memoizedState !== null;\n\n          if (newIsHidden) {\n            const primaryChildParent = node.child;\n\n            if (primaryChildParent !== null) {\n              if (primaryChildParent.child !== null) {\n                primaryChildParent.child.return = primaryChildParent;\n                appendAllChildren(parent, primaryChildParent, true, newIsHidden);\n              }\n\n              const fallbackChildParent = primaryChildParent.sibling;\n\n              if (fallbackChildParent !== null) {\n                fallbackChildParent.return = node;\n                node = fallbackChildParent;\n                continue;\n              }\n            }\n          }\n        }\n\n        if (node.child !== null) {\n          // Continue traversing like normal\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n  const appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n        let instance = node.stateNode.instance;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === SuspenseComponent) {\n        if ((node.effectTag & Update) !== NoEffect) {\n          // Need to toggle the visibility of the primary children.\n          const newIsHidden = node.memoizedState !== null;\n\n          if (newIsHidden) {\n            const primaryChildParent = node.child;\n\n            if (primaryChildParent !== null) {\n              if (primaryChildParent.child !== null) {\n                primaryChildParent.child.return = primaryChildParent;\n                appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, newIsHidden);\n              }\n\n              const fallbackChildParent = primaryChildParent.sibling;\n\n              if (fallbackChildParent !== null) {\n                fallbackChildParent.return = node;\n                node = fallbackChildParent;\n                continue;\n              }\n            }\n          }\n        }\n\n        if (node.child !== null) {\n          // Continue traversing like normal\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (workInProgress) {\n    const portalOrRoot = workInProgress.stateNode;\n    const childrenUnchanged = workInProgress.firstEffect === null;\n\n    if (childrenUnchanged) {// No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      let newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n\n    const childrenUnchanged = workInProgress.firstEffect === null;\n\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    const recyclableInstance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    let newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    workInProgress.stateNode = newInstance;\n\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {// Noop\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {// Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  switch (renderState.tailMode) {\n    case 'hidden':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          renderState.tail = null;\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n\n    case 'collapsed':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          if (!hasRenderedATailFallback && renderState.tail !== null) {\n            // We suspended during the head. We want to show at least one\n            // row at the tail. So we'll keep on and cut off the rest.\n            renderState.tail.sibling = null;\n          } else {\n            renderState.tail = null;\n          }\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n  }\n}\n\nfunction completeWork(current, workInProgress, renderExpirationTime) {\n  const newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      break;\n\n    case LazyComponent:\n      break;\n\n    case SimpleMemoComponent:\n    case FunctionComponent:\n      break;\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        const fiberRoot = workInProgress.stateNode;\n\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          let wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // If we hydrated, then we'll need to schedule an update for\n            // the commit side-effects on the root.\n            markUpdate(workInProgress);\n          }\n        }\n\n        updateHostContainer(workInProgress);\n        break;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        const rootContainerInstance = getRootHostContainer();\n        const type = workInProgress.type;\n\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (enableFlareAPI) {\n            const prevListeners = current.memoizedProps.listeners;\n            const nextListeners = newProps.listeners;\n\n            if (prevListeners !== nextListeners) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            invariant(workInProgress.stateNode !== null, 'We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.'); // This can happen when we abort work.\n\n            break;\n          }\n\n          const currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n\n          let wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n\n            if (enableFlareAPI) {\n              const listeners = newProps.listeners;\n\n              if (listeners != null) {\n                updateEventListeners(listeners, workInProgress, rootContainerInstance);\n              }\n            }\n          } else {\n            let instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n            appendAllChildren(instance, workInProgress, false, false); // This needs to be set before we mount Flare event listeners\n\n            workInProgress.stateNode = instance;\n\n            if (enableFlareAPI) {\n              const listeners = newProps.listeners;\n\n              if (listeners != null) {\n                updateEventListeners(listeners, workInProgress, rootContainerInstance);\n              }\n            } // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n\n\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n\n        break;\n      }\n\n    case HostText:\n      {\n        let newText = newProps;\n\n        if (current && workInProgress.stateNode != null) {\n          const oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            invariant(workInProgress.stateNode !== null, 'We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.'); // This can happen when we abort work.\n          }\n\n          const rootContainerInstance = getRootHostContainer();\n          const currentHostContext = getHostContext();\n          let wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          }\n        }\n\n        break;\n      }\n\n    case ForwardRef:\n      break;\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        const nextState = workInProgress.memoizedState;\n\n        if (enableSuspenseServerRenderer) {\n          if (nextState !== null && nextState.dehydrated !== null) {\n            if (current === null) {\n              let wasHydrated = popHydrationState(workInProgress);\n              invariant(wasHydrated, 'A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n              prepareToHydrateHostSuspenseInstance(workInProgress);\n\n              if (enableSchedulerTracing) {\n                markSpawnedWork(Never);\n              }\n\n              return null;\n            } else {\n              // We should never have been in a hydration state if we didn't have a current.\n              // However, in some of those paths, we might have reentered a hydration state\n              // and then we might be inside a hydration state. In that case, we'll need to\n              // exit out of it.\n              resetHydrationState();\n\n              if ((workInProgress.effectTag & DidCapture) === NoEffect) {\n                // This boundary did not suspend so it's now hydrated and unsuspended.\n                workInProgress.memoizedState = null;\n              } // If nothing suspended, we need to schedule an effect to mark this boundary\n              // as having hydrated so events know that they're free be invoked.\n              // It's also a signal to replay events and the suspense callback.\n              // If something suspended, schedule an effect to attach retry listeners.\n              // So we might as well always mark this.\n\n\n              workInProgress.effectTag |= Update;\n              return null;\n            }\n          }\n        }\n\n        if ((workInProgress.effectTag & DidCapture) !== NoEffect) {\n          // Something suspended. Re-render with the fallback children.\n          workInProgress.expirationTime = renderExpirationTime; // Do not reset the effect list.\n\n          return workInProgress;\n        }\n\n        const nextDidTimeout = nextState !== null;\n        let prevDidTimeout = false;\n\n        if (current === null) {\n          if (workInProgress.memoizedProps.fallback !== undefined) {\n            popHydrationState(workInProgress);\n          }\n        } else {\n          const prevState = current.memoizedState;\n          prevDidTimeout = prevState !== null;\n\n          if (!nextDidTimeout && prevState !== null) {\n            // We just switched from the fallback to the normal children.\n            // Delete the fallback.\n            // TODO: Would it be better to store the fallback fragment on\n            // the stateNode during the begin phase?\n            const currentFallbackChild = current.child.sibling;\n\n            if (currentFallbackChild !== null) {\n              // Deletions go at the beginning of the return fiber's effect list\n              const first = workInProgress.firstEffect;\n\n              if (first !== null) {\n                workInProgress.firstEffect = currentFallbackChild;\n                currentFallbackChild.nextEffect = first;\n              } else {\n                workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;\n                currentFallbackChild.nextEffect = null;\n              }\n\n              currentFallbackChild.effectTag = Deletion;\n            }\n          }\n        }\n\n        if (nextDidTimeout && !prevDidTimeout) {\n          // If this subtreee is running in blocking mode we can suspend,\n          // otherwise we won't suspend.\n          // TODO: This will still suspend a synchronous tree if anything\n          // in the concurrent tree already suspended during this render.\n          // This is a known bug.\n          if ((workInProgress.mode & BlockingMode) !== NoMode) {\n            // TODO: Move this back to throwException because this is too late\n            // if this is a large tree which is common for initial loads. We\n            // don't know if we should restart a render or not until we get\n            // this marker, and this is too late.\n            // If this render already had a ping or lower pri updates,\n            // and this is the first time we know we're going to suspend we\n            // should be able to immediately restart from within throwException.\n            const hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;\n\n            if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n              // If this was in an invisible tree or a new render, then showing\n              // this boundary is ok.\n              renderDidSuspend();\n            } else {\n              // Otherwise, we're going to have to hide content so we should\n              // suspend for longer if possible.\n              renderDidSuspendDelayIfPossible();\n            }\n          }\n        }\n\n        if (supportsPersistence) {\n          // TODO: Only schedule updates if not prevDidTimeout.\n          if (nextDidTimeout) {\n            // If this boundary just timed out, schedule an effect to attach a\n            // retry listener to the proimse. This flag is also used to hide the\n            // primary children.\n            workInProgress.effectTag |= Update;\n          }\n        }\n\n        if (supportsMutation) {\n          // TODO: Only schedule updates if these values are non equal, i.e. it changed.\n          if (nextDidTimeout || prevDidTimeout) {\n            // If this boundary just timed out, schedule an effect to attach a\n            // retry listener to the proimse. This flag is also used to hide the\n            // primary children. In mutation mode, we also need the flag to\n            // *unhide* children that were previously hidden, so check if the\n            // is currently timed out, too.\n            workInProgress.effectTag |= Update;\n          }\n        }\n\n        if (enableSuspenseCallback && workInProgress.updateQueue !== null && workInProgress.memoizedProps.suspenseCallback != null) {\n          // Always notify the callback\n          workInProgress.effectTag |= Update;\n        }\n\n        break;\n      }\n\n    case Fragment:\n      break;\n\n    case Mode:\n      break;\n\n    case Profiler:\n      break;\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      break;\n\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      break;\n\n    case ContextConsumer:\n      break;\n\n    case MemoComponent:\n      break;\n\n    case IncompleteClassComponent:\n      {\n        // Same as class component case. I put it down here so that the tags are\n        // sequential to ensure this switch is compiled to a jump table.\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        break;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress);\n        const renderState = workInProgress.memoizedState;\n\n        if (renderState === null) {\n          // We're running in the default, \"independent\" mode. We don't do anything\n          // in this mode.\n          break;\n        }\n\n        let didSuspendAlready = (workInProgress.effectTag & DidCapture) !== NoEffect;\n        let renderedTail = renderState.rendering;\n\n        if (renderedTail === null) {\n          // We just rendered the head.\n          if (!didSuspendAlready) {\n            // This is the first pass. We need to figure out if anything is still\n            // suspended in the rendered set.\n            // If new content unsuspended, but there's still some content that\n            // didn't. Then we need to do a second pass that forces everything\n            // to keep showing their fallbacks.\n            // We might be suspended if something in this render pass suspended, or\n            // something in the previous committed pass suspended. Otherwise,\n            // there's no chance so we can skip the expensive call to\n            // findFirstSuspended.\n            let cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.effectTag & DidCapture) === NoEffect);\n\n            if (!cannotBeSuspended) {\n              let row = workInProgress.child;\n\n              while (row !== null) {\n                let suspended = findFirstSuspended(row);\n\n                if (suspended !== null) {\n                  didSuspendAlready = true;\n                  workInProgress.effectTag |= DidCapture;\n                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                  // part of the second pass. In that case nothing will subscribe to\n                  // its thennables. Instead, we'll transfer its thennables to the\n                  // SuspenseList so that it can retry if they resolve.\n                  // There might be multiple of these in the list but since we're\n                  // going to wait for all of them anyway, it doesn't really matter\n                  // which ones gets to ping. In theory we could get clever and keep\n                  // track of how many dependencies remain but it gets tricky because\n                  // in the meantime, we can add/remove/change items and dependencies.\n                  // We might bail out of the loop before finding any but that\n                  // doesn't matter since that means that the other boundaries that\n                  // we did find already has their listeners attached.\n\n                  let newThennables = suspended.updateQueue;\n\n                  if (newThennables !== null) {\n                    workInProgress.updateQueue = newThennables;\n                    workInProgress.effectTag |= Update;\n                  } // Rerender the whole list, but this time, we'll force fallbacks\n                  // to stay in place.\n                  // Reset the effect list before doing the second pass since that's now invalid.\n\n\n                  if (renderState.lastEffect === null) {\n                    workInProgress.firstEffect = null;\n                  }\n\n                  workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.\n\n                  resetChildFibers(workInProgress, renderExpirationTime); // Set up the Suspense Context to force suspense and immediately\n                  // rerender the children.\n\n                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));\n                  return workInProgress.child;\n                }\n\n                row = row.sibling;\n              }\n            }\n          } else {\n            cutOffTailIfNeeded(renderState, false);\n          } // Next we're going to render the tail.\n\n        } else {\n          // Append the rendered row to the child list.\n          if (!didSuspendAlready) {\n            let suspended = findFirstSuspended(renderedTail);\n\n            if (suspended !== null) {\n              workInProgress.effectTag |= DidCapture;\n              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n              // get lost if this row ends up dropped during a second pass.\n\n              let newThennables = suspended.updateQueue;\n\n              if (newThennables !== null) {\n                workInProgress.updateQueue = newThennables;\n                workInProgress.effectTag |= Update;\n              }\n\n              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate) {\n                // We need to delete the row we just rendered.\n                // Reset the effect list to what it was before we rendered this\n                // child. The nested children have already appended themselves.\n                let lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.\n\n                if (lastEffect !== null) {\n                  lastEffect.nextEffect = null;\n                } // We're done.\n\n\n                return null;\n              }\n            } else if (now() > renderState.tailExpiration && renderExpirationTime > Never) {\n              // We have now passed our CPU deadline and we'll just give up further\n              // attempts to render the main content and only render fallbacks.\n              // The assumption is that this is usually faster.\n              workInProgress.effectTag |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. If we can show\n              // them, then they really have the same priority as this render.\n              // So we'll pick it back up the very next render pass once we've had\n              // an opportunity to yield for paint.\n\n              const nextPriority = renderExpirationTime - 1;\n              workInProgress.expirationTime = workInProgress.childExpirationTime = nextPriority;\n\n              if (enableSchedulerTracing) {\n                markSpawnedWork(nextPriority);\n              }\n            }\n          }\n\n          if (renderState.isBackwards) {\n            // The effect list of the backwards tail will have been added\n            // to the end. This breaks the guarantee that life-cycles fire in\n            // sibling order but that isn't a strong guarantee promised by React.\n            // Especially since these might also just pop in during future commits.\n            // Append to the beginning of the list.\n            renderedTail.sibling = workInProgress.child;\n            workInProgress.child = renderedTail;\n          } else {\n            let previousSibling = renderState.last;\n\n            if (previousSibling !== null) {\n              previousSibling.sibling = renderedTail;\n            } else {\n              workInProgress.child = renderedTail;\n            }\n\n            renderState.last = renderedTail;\n          }\n        }\n\n        if (renderState.tail !== null) {\n          // We still have tail rows to render.\n          if (renderState.tailExpiration === 0) {\n            // Heuristic for how long we're willing to spend rendering rows\n            // until we just give up and show what we have so far.\n            const TAIL_EXPIRATION_TIMEOUT_MS = 500;\n            renderState.tailExpiration = now() + TAIL_EXPIRATION_TIMEOUT_MS;\n          } // Pop a row.\n\n\n          let next = renderState.tail;\n          renderState.rendering = next;\n          renderState.tail = next.sibling;\n          renderState.lastEffect = workInProgress.lastEffect;\n          next.sibling = null; // Restore the context.\n          // TODO: We can probably just avoid popping it instead and only\n          // setting it the first time we go from not suspended to suspended.\n\n          let suspenseContext = suspenseStackCursor.current;\n\n          if (didSuspendAlready) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          } else {\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n\n          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n\n          return next;\n        }\n\n        break;\n      }\n\n    case FundamentalComponent:\n      {\n        if (enableFundamentalAPI) {\n          const fundamentalImpl = workInProgress.type.impl;\n          let fundamentalInstance = workInProgress.stateNode;\n\n          if (fundamentalInstance === null) {\n            const getInitialState = fundamentalImpl.getInitialState;\n            let fundamentalState;\n\n            if (getInitialState !== undefined) {\n              fundamentalState = getInitialState(newProps);\n            }\n\n            fundamentalInstance = workInProgress.stateNode = createFundamentalStateInstance(workInProgress, newProps, fundamentalImpl, fundamentalState || {});\n            const instance = getFundamentalComponentInstance(fundamentalInstance);\n            fundamentalInstance.instance = instance;\n\n            if (fundamentalImpl.reconcileChildren === false) {\n              return null;\n            }\n\n            appendAllChildren(instance, workInProgress, false, false);\n            mountFundamentalComponent(fundamentalInstance);\n          } else {\n            // We fire update in commit phase\n            const prevProps = fundamentalInstance.props;\n            fundamentalInstance.prevProps = prevProps;\n            fundamentalInstance.props = newProps;\n            fundamentalInstance.currentFiber = workInProgress;\n\n            if (supportsPersistence) {\n              const instance = cloneFundamentalInstance(fundamentalInstance);\n              fundamentalInstance.instance = instance;\n              appendAllChildren(instance, workInProgress, false, false);\n            }\n\n            const shouldUpdate = shouldUpdateFundamentalComponent(fundamentalInstance);\n\n            if (shouldUpdate) {\n              markUpdate(workInProgress);\n            }\n          }\n        }\n\n        break;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          if (current === null) {\n            const type = workInProgress.type;\n            const scopeInstance = {\n              fiber: workInProgress,\n              methods: null\n            };\n            workInProgress.stateNode = scopeInstance;\n            scopeInstance.methods = createScopeMethods(type, scopeInstance);\n\n            if (enableFlareAPI) {\n              const listeners = newProps.listeners;\n\n              if (listeners != null) {\n                const rootContainerInstance = getRootHostContainer();\n                updateEventListeners(listeners, workInProgress, rootContainerInstance);\n              }\n            }\n\n            if (workInProgress.ref !== null) {\n              markRef(workInProgress);\n              markUpdate(workInProgress);\n            }\n          } else {\n            if (enableFlareAPI) {\n              const prevListeners = current.memoizedProps.listeners;\n              const nextListeners = newProps.listeners;\n\n              if (prevListeners !== nextListeners || workInProgress.ref !== null) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              if (workInProgress.ref !== null) {\n                markUpdate(workInProgress);\n              }\n            }\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          }\n        }\n\n        break;\n      }\n\n    default:\n      invariant(false, 'Unknown unit of work tag (%s). This error is likely caused by a bug in ' + 'React. Please file an issue.', workInProgress.tag);\n  }\n\n  return null;\n}\n\nexport { completeWork };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberCompleteWork.js"],"names":["now","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","ContextProvider","ContextConsumer","ForwardRef","Fragment","Mode","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","FundamentalComponent","ScopeComponent","NoMode","BlockingMode","Ref","Update","NoEffect","DidCapture","Deletion","invariant","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","supportsMutation","supportsPersistence","cloneInstance","cloneHiddenInstance","cloneHiddenTextInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","getFundamentalComponentInstance","mountFundamentalComponent","cloneFundamentalInstance","shouldUpdateFundamentalComponent","getRootHostContainer","popHostContext","getHostContext","popHostContainer","suspenseStackCursor","InvisibleParentSuspenseContext","hasSuspenseContext","popSuspenseContext","pushSuspenseContext","setShallowSuspenseContext","ForceSuspenseFallback","setDefaultShallowSuspenseContext","findFirstSuspended","isContextProvider","isLegacyContextProvider","popContext","popLegacyContext","popTopLevelContextObject","popTopLevelLegacyContextObject","popProvider","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","prepareToHydrateHostSuspenseInstance","popHydrationState","resetHydrationState","enableSchedulerTracing","enableSuspenseCallback","enableSuspenseServerRenderer","enableFlareAPI","enableFundamentalAPI","enableScopeAPI","markSpawnedWork","renderDidSuspend","renderDidSuspendDelayIfPossible","renderHasNotSuspendedYet","createFundamentalStateInstance","Never","resetChildFibers","updateEventListeners","createScopeMethods","markUpdate","workInProgress","effectTag","markRef","appendAllChildren","updateHostContainer","updateHostComponent","updateHostText","parent","needsVisibilityToggle","isHidden","node","child","tag","stateNode","instance","return","sibling","current","type","newProps","rootContainerInstance","oldProps","memoizedProps","currentHostContext","updatePayload","updateQueue","oldText","newText","branches","props","text","newIsHidden","memoizedState","primaryChildParent","fallbackChildParent","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","firstEffect","container","containerInfo","newChildSet","pendingChildren","currentInstance","recyclableInstance","newInstance","cutOffTailIfNeeded","renderState","hasRenderedATailFallback","tailMode","tailNode","tail","lastTailNode","alternate","completeWork","renderExpirationTime","pendingProps","Component","fiberRoot","pendingContext","context","wasHydrated","prevListeners","listeners","nextListeners","ref","nextState","dehydrated","expirationTime","nextDidTimeout","prevDidTimeout","fallback","undefined","prevState","currentFallbackChild","first","nextEffect","lastEffect","mode","hasInvisibleChildContext","unstable_avoidThisFallback","suspenseCallback","didSuspendAlready","renderedTail","rendering","cannotBeSuspended","row","suspended","newThennables","tailExpiration","nextPriority","childExpirationTime","isBackwards","previousSibling","last","TAIL_EXPIRATION_TIMEOUT_MS","next","suspenseContext","fundamentalImpl","impl","fundamentalInstance","getInitialState","fundamentalState","reconcileChildren","prevProps","currentFiber","shouldUpdate","scopeInstance","fiber","methods"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {\n  ReactFundamentalComponentInstance,\n  ReactScopeInstance,\n} from 'shared/ReactTypes';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {\n  Instance,\n  Type,\n  Props,\n  Container,\n  ChildSet,\n} from './ReactFiberHostConfig';\nimport type {\n  SuspenseState,\n  SuspenseListRenderState,\n} from './ReactFiberSuspenseComponent';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext';\n\nimport {now} from './SchedulerWithReactIntegration';\n\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  ContextProvider,\n  ContextConsumer,\n  ForwardRef,\n  Fragment,\n  Mode,\n  Profiler,\n  SuspenseComponent,\n  SuspenseListComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  FundamentalComponent,\n  ScopeComponent,\n} from 'shared/ReactWorkTags';\nimport {NoMode, BlockingMode} from './ReactTypeOfMode';\nimport {\n  Ref,\n  Update,\n  NoEffect,\n  DidCapture,\n  Deletion,\n} from 'shared/ReactSideEffectTags';\nimport invariant from 'shared/invariant';\n\nimport {\n  createInstance,\n  createTextInstance,\n  appendInitialChild,\n  finalizeInitialChildren,\n  prepareUpdate,\n  supportsMutation,\n  supportsPersistence,\n  cloneInstance,\n  cloneHiddenInstance,\n  cloneHiddenTextInstance,\n  createContainerChildSet,\n  appendChildToContainerChildSet,\n  finalizeContainerChildren,\n  getFundamentalComponentInstance,\n  mountFundamentalComponent,\n  cloneFundamentalInstance,\n  shouldUpdateFundamentalComponent,\n} from './ReactFiberHostConfig';\nimport {\n  getRootHostContainer,\n  popHostContext,\n  getHostContext,\n  popHostContainer,\n} from './ReactFiberHostContext';\nimport {\n  suspenseStackCursor,\n  InvisibleParentSuspenseContext,\n  hasSuspenseContext,\n  popSuspenseContext,\n  pushSuspenseContext,\n  setShallowSuspenseContext,\n  ForceSuspenseFallback,\n  setDefaultShallowSuspenseContext,\n} from './ReactFiberSuspenseContext';\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popContext as popLegacyContext,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n} from './ReactFiberContext';\nimport {popProvider} from './ReactFiberNewContext';\nimport {\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  prepareToHydrateHostSuspenseInstance,\n  popHydrationState,\n  resetHydrationState,\n} from './ReactFiberHydrationContext';\nimport {\n  enableSchedulerTracing,\n  enableSuspenseCallback,\n  enableSuspenseServerRenderer,\n  enableFlareAPI,\n  enableFundamentalAPI,\n  enableScopeAPI,\n} from 'shared/ReactFeatureFlags';\nimport {\n  markSpawnedWork,\n  renderDidSuspend,\n  renderDidSuspendDelayIfPossible,\n  renderHasNotSuspendedYet,\n} from './ReactFiberWorkLoop';\nimport {createFundamentalStateInstance} from './ReactFiberFundamental';\nimport {Never} from './ReactFiberExpirationTime';\nimport {resetChildFibers} from './ReactChildFiber';\nimport {updateEventListeners} from './ReactFiberEvents';\nimport {createScopeMethods} from './ReactFiberScope';\n\nfunction markUpdate(workInProgress: Fiber) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef(workInProgress: Fiber) {\n  workInProgress.effectTag |= Ref;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\nif (supportsMutation) {\n  // Mutation mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n        appendInitialChild(parent, node.stateNode.instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function(workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    const instance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    const updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      rootContainerInstance,\n      currentHostContext,\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = (updatePayload: any);\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n        let instance = node.stateNode.instance;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === SuspenseComponent) {\n        if ((node.effectTag & Update) !== NoEffect) {\n          // Need to toggle the visibility of the primary children.\n          const newIsHidden = node.memoizedState !== null;\n          if (newIsHidden) {\n            const primaryChildParent = node.child;\n            if (primaryChildParent !== null) {\n              if (primaryChildParent.child !== null) {\n                primaryChildParent.child.return = primaryChildParent;\n                appendAllChildren(\n                  parent,\n                  primaryChildParent,\n                  true,\n                  newIsHidden,\n                );\n              }\n              const fallbackChildParent = primaryChildParent.sibling;\n              if (fallbackChildParent !== null) {\n                fallbackChildParent.return = node;\n                node = fallbackChildParent;\n                continue;\n              }\n            }\n          }\n        }\n        if (node.child !== null) {\n          // Continue traversing like normal\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  const appendAllChildrenToContainer = function(\n    containerChildSet: ChildSet,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n        let instance = node.stateNode.instance;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === SuspenseComponent) {\n        if ((node.effectTag & Update) !== NoEffect) {\n          // Need to toggle the visibility of the primary children.\n          const newIsHidden = node.memoizedState !== null;\n          if (newIsHidden) {\n            const primaryChildParent = node.child;\n            if (primaryChildParent !== null) {\n              if (primaryChildParent.child !== null) {\n                primaryChildParent.child.return = primaryChildParent;\n                appendAllChildrenToContainer(\n                  containerChildSet,\n                  primaryChildParent,\n                  true,\n                  newIsHidden,\n                );\n              }\n              const fallbackChildParent = primaryChildParent.sibling;\n              if (fallbackChildParent !== null) {\n                fallbackChildParent.return = node;\n                node = fallbackChildParent;\n                continue;\n              }\n            }\n          }\n        }\n        if (node.child !== null) {\n          // Continue traversing like normal\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function(workInProgress: Fiber) {\n    const portalOrRoot: {\n      containerInfo: Container,\n      pendingChildren: ChildSet,\n    } =\n      workInProgress.stateNode;\n    const childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      let newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    const childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    const recyclableInstance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(\n        recyclableInstance,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext,\n      );\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    let newInstance = cloneInstance(\n      currentInstance,\n      updatePayload,\n      type,\n      oldProps,\n      newProps,\n      workInProgress,\n      childrenUnchanged,\n      recyclableInstance,\n    );\n    if (\n      finalizeInitialChildren(\n        newInstance,\n        type,\n        newProps,\n        rootContainerInstance,\n        currentHostContext,\n      )\n    ) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(\n        newText,\n        rootContainerInstance,\n        currentHostContext,\n        workInProgress,\n      );\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function(workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    // Noop\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(\n  renderState: SuspenseListRenderState,\n  hasRenderedATailFallback: boolean,\n) {\n  switch (renderState.tailMode) {\n    case 'hidden': {\n      // Any insertions at the end of the tail list after this point\n      // should be invisible. If there are already mounted boundaries\n      // anything before them are not considered for collapsing.\n      // Therefore we need to go through the whole tail to find if\n      // there are any.\n      let tailNode = renderState.tail;\n      let lastTailNode = null;\n      while (tailNode !== null) {\n        if (tailNode.alternate !== null) {\n          lastTailNode = tailNode;\n        }\n        tailNode = tailNode.sibling;\n      }\n      // Next we're simply going to delete all insertions after the\n      // last rendered item.\n      if (lastTailNode === null) {\n        // All remaining items in the tail are insertions.\n        renderState.tail = null;\n      } else {\n        // Detach the insertion after the last node that was already\n        // inserted.\n        lastTailNode.sibling = null;\n      }\n      break;\n    }\n    case 'collapsed': {\n      // Any insertions at the end of the tail list after this point\n      // should be invisible. If there are already mounted boundaries\n      // anything before them are not considered for collapsing.\n      // Therefore we need to go through the whole tail to find if\n      // there are any.\n      let tailNode = renderState.tail;\n      let lastTailNode = null;\n      while (tailNode !== null) {\n        if (tailNode.alternate !== null) {\n          lastTailNode = tailNode;\n        }\n        tailNode = tailNode.sibling;\n      }\n      // Next we're simply going to delete all insertions after the\n      // last rendered item.\n      if (lastTailNode === null) {\n        // All remaining items in the tail are insertions.\n        if (!hasRenderedATailFallback && renderState.tail !== null) {\n          // We suspended during the head. We want to show at least one\n          // row at the tail. So we'll keep on and cut off the rest.\n          renderState.tail.sibling = null;\n        } else {\n          renderState.tail = null;\n        }\n      } else {\n        // Detach the insertion after the last node that was already\n        // inserted.\n        lastTailNode.sibling = null;\n      }\n      break;\n    }\n  }\n}\n\nfunction completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      break;\n    case LazyComponent:\n      break;\n    case SimpleMemoComponent:\n    case FunctionComponent:\n      break;\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      const fiberRoot = (workInProgress.stateNode: FiberRoot);\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        let wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // If we hydrated, then we'll need to schedule an update for\n          // the commit side-effects on the root.\n          markUpdate(workInProgress);\n        }\n      }\n      updateHostContainer(workInProgress);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      const rootContainerInstance = getRootHostContainer();\n      const type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        updateHostComponent(\n          current,\n          workInProgress,\n          type,\n          newProps,\n          rootContainerInstance,\n        );\n\n        if (enableFlareAPI) {\n          const prevListeners = current.memoizedProps.listeners;\n          const nextListeners = newProps.listeners;\n          if (prevListeners !== nextListeners) {\n            markUpdate(workInProgress);\n          }\n        }\n\n        if (current.ref !== workInProgress.ref) {\n          markRef(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          invariant(\n            workInProgress.stateNode !== null,\n            'We must have new props for new mounts. This error is likely ' +\n              'caused by a bug in React. Please file an issue.',\n          );\n          // This can happen when we abort work.\n          break;\n        }\n\n        const currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on we want to add then top->down or\n        // bottom->up. Top->down is faster in IE11.\n        let wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(\n              workInProgress,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            // If changes to the hydrated node needs to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n          if (enableFlareAPI) {\n            const listeners = newProps.listeners;\n            if (listeners != null) {\n              updateEventListeners(\n                listeners,\n                workInProgress,\n                rootContainerInstance,\n              );\n            }\n          }\n        } else {\n          let instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n\n          appendAllChildren(instance, workInProgress, false, false);\n\n          // This needs to be set before we mount Flare event listeners\n          workInProgress.stateNode = instance;\n\n          if (enableFlareAPI) {\n            const listeners = newProps.listeners;\n            if (listeners != null) {\n              updateEventListeners(\n                listeners,\n                workInProgress,\n                rootContainerInstance,\n              );\n            }\n          }\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef(workInProgress);\n        }\n      }\n      break;\n    }\n    case HostText: {\n      let newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        const oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== 'string') {\n          invariant(\n            workInProgress.stateNode !== null,\n            'We must have new props for new mounts. This error is likely ' +\n              'caused by a bug in React. Please file an issue.',\n          );\n          // This can happen when we abort work.\n        }\n        const rootContainerInstance = getRootHostContainer();\n        const currentHostContext = getHostContext();\n        let wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n        }\n      }\n      break;\n    }\n    case ForwardRef:\n      break;\n    case SuspenseComponent: {\n      popSuspenseContext(workInProgress);\n      const nextState: null | SuspenseState = workInProgress.memoizedState;\n\n      if (enableSuspenseServerRenderer) {\n        if (nextState !== null && nextState.dehydrated !== null) {\n          if (current === null) {\n            let wasHydrated = popHydrationState(workInProgress);\n            invariant(\n              wasHydrated,\n              'A dehydrated suspense component was completed without a hydrated node. ' +\n                'This is probably a bug in React.',\n            );\n            prepareToHydrateHostSuspenseInstance(workInProgress);\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            }\n            return null;\n          } else {\n            // We should never have been in a hydration state if we didn't have a current.\n            // However, in some of those paths, we might have reentered a hydration state\n            // and then we might be inside a hydration state. In that case, we'll need to\n            // exit out of it.\n            resetHydrationState();\n            if ((workInProgress.effectTag & DidCapture) === NoEffect) {\n              // This boundary did not suspend so it's now hydrated and unsuspended.\n              workInProgress.memoizedState = null;\n            }\n            // If nothing suspended, we need to schedule an effect to mark this boundary\n            // as having hydrated so events know that they're free be invoked.\n            // It's also a signal to replay events and the suspense callback.\n            // If something suspended, schedule an effect to attach retry listeners.\n            // So we might as well always mark this.\n            workInProgress.effectTag |= Update;\n            return null;\n          }\n        }\n      }\n\n      if ((workInProgress.effectTag & DidCapture) !== NoEffect) {\n        // Something suspended. Re-render with the fallback children.\n        workInProgress.expirationTime = renderExpirationTime;\n        // Do not reset the effect list.\n        return workInProgress;\n      }\n\n      const nextDidTimeout = nextState !== null;\n      let prevDidTimeout = false;\n      if (current === null) {\n        if (workInProgress.memoizedProps.fallback !== undefined) {\n          popHydrationState(workInProgress);\n        }\n      } else {\n        const prevState: null | SuspenseState = current.memoizedState;\n        prevDidTimeout = prevState !== null;\n        if (!nextDidTimeout && prevState !== null) {\n          // We just switched from the fallback to the normal children.\n          // Delete the fallback.\n          // TODO: Would it be better to store the fallback fragment on\n          // the stateNode during the begin phase?\n          const currentFallbackChild: Fiber | null = (current.child: any)\n            .sibling;\n          if (currentFallbackChild !== null) {\n            // Deletions go at the beginning of the return fiber's effect list\n            const first = workInProgress.firstEffect;\n            if (first !== null) {\n              workInProgress.firstEffect = currentFallbackChild;\n              currentFallbackChild.nextEffect = first;\n            } else {\n              workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;\n              currentFallbackChild.nextEffect = null;\n            }\n            currentFallbackChild.effectTag = Deletion;\n          }\n        }\n      }\n\n      if (nextDidTimeout && !prevDidTimeout) {\n        // If this subtreee is running in blocking mode we can suspend,\n        // otherwise we won't suspend.\n        // TODO: This will still suspend a synchronous tree if anything\n        // in the concurrent tree already suspended during this render.\n        // This is a known bug.\n        if ((workInProgress.mode & BlockingMode) !== NoMode) {\n          // TODO: Move this back to throwException because this is too late\n          // if this is a large tree which is common for initial loads. We\n          // don't know if we should restart a render or not until we get\n          // this marker, and this is too late.\n          // If this render already had a ping or lower pri updates,\n          // and this is the first time we know we're going to suspend we\n          // should be able to immediately restart from within throwException.\n          const hasInvisibleChildContext =\n            current === null &&\n            workInProgress.memoizedProps.unstable_avoidThisFallback !== true;\n          if (\n            hasInvisibleChildContext ||\n            hasSuspenseContext(\n              suspenseStackCursor.current,\n              (InvisibleParentSuspenseContext: SuspenseContext),\n            )\n          ) {\n            // If this was in an invisible tree or a new render, then showing\n            // this boundary is ok.\n            renderDidSuspend();\n          } else {\n            // Otherwise, we're going to have to hide content so we should\n            // suspend for longer if possible.\n            renderDidSuspendDelayIfPossible();\n          }\n        }\n      }\n\n      if (supportsPersistence) {\n        // TODO: Only schedule updates if not prevDidTimeout.\n        if (nextDidTimeout) {\n          // If this boundary just timed out, schedule an effect to attach a\n          // retry listener to the proimse. This flag is also used to hide the\n          // primary children.\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (supportsMutation) {\n        // TODO: Only schedule updates if these values are non equal, i.e. it changed.\n        if (nextDidTimeout || prevDidTimeout) {\n          // If this boundary just timed out, schedule an effect to attach a\n          // retry listener to the proimse. This flag is also used to hide the\n          // primary children. In mutation mode, we also need the flag to\n          // *unhide* children that were previously hidden, so check if the\n          // is currently timed out, too.\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (\n        enableSuspenseCallback &&\n        workInProgress.updateQueue !== null &&\n        workInProgress.memoizedProps.suspenseCallback != null\n      ) {\n        // Always notify the callback\n        workInProgress.effectTag |= Update;\n      }\n      break;\n    }\n    case Fragment:\n      break;\n    case Mode:\n      break;\n    case Profiler:\n      break;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      break;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      break;\n    case ContextConsumer:\n      break;\n    case MemoComponent:\n      break;\n    case IncompleteClassComponent: {\n      // Same as class component case. I put it down here so that the tags are\n      // sequential to ensure this switch is compiled to a jump table.\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      break;\n    }\n    case SuspenseListComponent: {\n      popSuspenseContext(workInProgress);\n\n      const renderState: null | SuspenseListRenderState =\n        workInProgress.memoizedState;\n\n      if (renderState === null) {\n        // We're running in the default, \"independent\" mode. We don't do anything\n        // in this mode.\n        break;\n      }\n\n      let didSuspendAlready =\n        (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n      let renderedTail = renderState.rendering;\n      if (renderedTail === null) {\n        // We just rendered the head.\n        if (!didSuspendAlready) {\n          // This is the first pass. We need to figure out if anything is still\n          // suspended in the rendered set.\n\n          // If new content unsuspended, but there's still some content that\n          // didn't. Then we need to do a second pass that forces everything\n          // to keep showing their fallbacks.\n\n          // We might be suspended if something in this render pass suspended, or\n          // something in the previous committed pass suspended. Otherwise,\n          // there's no chance so we can skip the expensive call to\n          // findFirstSuspended.\n          let cannotBeSuspended =\n            renderHasNotSuspendedYet() &&\n            (current === null || (current.effectTag & DidCapture) === NoEffect);\n          if (!cannotBeSuspended) {\n            let row = workInProgress.child;\n            while (row !== null) {\n              let suspended = findFirstSuspended(row);\n              if (suspended !== null) {\n                didSuspendAlready = true;\n                workInProgress.effectTag |= DidCapture;\n                cutOffTailIfNeeded(renderState, false);\n\n                // If this is a newly suspended tree, it might not get committed as\n                // part of the second pass. In that case nothing will subscribe to\n                // its thennables. Instead, we'll transfer its thennables to the\n                // SuspenseList so that it can retry if they resolve.\n                // There might be multiple of these in the list but since we're\n                // going to wait for all of them anyway, it doesn't really matter\n                // which ones gets to ping. In theory we could get clever and keep\n                // track of how many dependencies remain but it gets tricky because\n                // in the meantime, we can add/remove/change items and dependencies.\n                // We might bail out of the loop before finding any but that\n                // doesn't matter since that means that the other boundaries that\n                // we did find already has their listeners attached.\n                let newThennables = suspended.updateQueue;\n                if (newThennables !== null) {\n                  workInProgress.updateQueue = newThennables;\n                  workInProgress.effectTag |= Update;\n                }\n\n                // Rerender the whole list, but this time, we'll force fallbacks\n                // to stay in place.\n                // Reset the effect list before doing the second pass since that's now invalid.\n                if (renderState.lastEffect === null) {\n                  workInProgress.firstEffect = null;\n                }\n                workInProgress.lastEffect = renderState.lastEffect;\n                // Reset the child fibers to their original state.\n                resetChildFibers(workInProgress, renderExpirationTime);\n\n                // Set up the Suspense Context to force suspense and immediately\n                // rerender the children.\n                pushSuspenseContext(\n                  workInProgress,\n                  setShallowSuspenseContext(\n                    suspenseStackCursor.current,\n                    ForceSuspenseFallback,\n                  ),\n                );\n                return workInProgress.child;\n              }\n              row = row.sibling;\n            }\n          }\n        } else {\n          cutOffTailIfNeeded(renderState, false);\n        }\n        // Next we're going to render the tail.\n      } else {\n        // Append the rendered row to the child list.\n        if (!didSuspendAlready) {\n          let suspended = findFirstSuspended(renderedTail);\n          if (suspended !== null) {\n            workInProgress.effectTag |= DidCapture;\n            didSuspendAlready = true;\n\n            // Ensure we transfer the update queue to the parent so that it doesn't\n            // get lost if this row ends up dropped during a second pass.\n            let newThennables = suspended.updateQueue;\n            if (newThennables !== null) {\n              workInProgress.updateQueue = newThennables;\n              workInProgress.effectTag |= Update;\n            }\n\n            cutOffTailIfNeeded(renderState, true);\n            // This might have been modified.\n            if (\n              renderState.tail === null &&\n              renderState.tailMode === 'hidden' &&\n              !renderedTail.alternate\n            ) {\n              // We need to delete the row we just rendered.\n              // Reset the effect list to what it was before we rendered this\n              // child. The nested children have already appended themselves.\n              let lastEffect = (workInProgress.lastEffect =\n                renderState.lastEffect);\n              // Remove any effects that were appended after this point.\n              if (lastEffect !== null) {\n                lastEffect.nextEffect = null;\n              }\n              // We're done.\n              return null;\n            }\n          } else if (\n            now() > renderState.tailExpiration &&\n            renderExpirationTime > Never\n          ) {\n            // We have now passed our CPU deadline and we'll just give up further\n            // attempts to render the main content and only render fallbacks.\n            // The assumption is that this is usually faster.\n            workInProgress.effectTag |= DidCapture;\n            didSuspendAlready = true;\n\n            cutOffTailIfNeeded(renderState, false);\n\n            // Since nothing actually suspended, there will nothing to ping this\n            // to get it started back up to attempt the next item. If we can show\n            // them, then they really have the same priority as this render.\n            // So we'll pick it back up the very next render pass once we've had\n            // an opportunity to yield for paint.\n\n            const nextPriority = renderExpirationTime - 1;\n            workInProgress.expirationTime = workInProgress.childExpirationTime = nextPriority;\n            if (enableSchedulerTracing) {\n              markSpawnedWork(nextPriority);\n            }\n          }\n        }\n        if (renderState.isBackwards) {\n          // The effect list of the backwards tail will have been added\n          // to the end. This breaks the guarantee that life-cycles fire in\n          // sibling order but that isn't a strong guarantee promised by React.\n          // Especially since these might also just pop in during future commits.\n          // Append to the beginning of the list.\n          renderedTail.sibling = workInProgress.child;\n          workInProgress.child = renderedTail;\n        } else {\n          let previousSibling = renderState.last;\n          if (previousSibling !== null) {\n            previousSibling.sibling = renderedTail;\n          } else {\n            workInProgress.child = renderedTail;\n          }\n          renderState.last = renderedTail;\n        }\n      }\n\n      if (renderState.tail !== null) {\n        // We still have tail rows to render.\n        if (renderState.tailExpiration === 0) {\n          // Heuristic for how long we're willing to spend rendering rows\n          // until we just give up and show what we have so far.\n          const TAIL_EXPIRATION_TIMEOUT_MS = 500;\n          renderState.tailExpiration = now() + TAIL_EXPIRATION_TIMEOUT_MS;\n        }\n        // Pop a row.\n        let next = renderState.tail;\n        renderState.rendering = next;\n        renderState.tail = next.sibling;\n        renderState.lastEffect = workInProgress.lastEffect;\n        next.sibling = null;\n\n        // Restore the context.\n        // TODO: We can probably just avoid popping it instead and only\n        // setting it the first time we go from not suspended to suspended.\n        let suspenseContext = suspenseStackCursor.current;\n        if (didSuspendAlready) {\n          suspenseContext = setShallowSuspenseContext(\n            suspenseContext,\n            ForceSuspenseFallback,\n          );\n        } else {\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n        }\n        pushSuspenseContext(workInProgress, suspenseContext);\n        // Do a pass over the next row.\n        return next;\n      }\n      break;\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        const fundamentalImpl = workInProgress.type.impl;\n        let fundamentalInstance: ReactFundamentalComponentInstance<\n          any,\n          any,\n        > | null =\n          workInProgress.stateNode;\n\n        if (fundamentalInstance === null) {\n          const getInitialState = fundamentalImpl.getInitialState;\n          let fundamentalState;\n          if (getInitialState !== undefined) {\n            fundamentalState = getInitialState(newProps);\n          }\n          fundamentalInstance = workInProgress.stateNode = createFundamentalStateInstance(\n            workInProgress,\n            newProps,\n            fundamentalImpl,\n            fundamentalState || {},\n          );\n          const instance = ((getFundamentalComponentInstance(\n            fundamentalInstance,\n          ): any): Instance);\n          fundamentalInstance.instance = instance;\n          if (fundamentalImpl.reconcileChildren === false) {\n            return null;\n          }\n          appendAllChildren(instance, workInProgress, false, false);\n          mountFundamentalComponent(fundamentalInstance);\n        } else {\n          // We fire update in commit phase\n          const prevProps = fundamentalInstance.props;\n          fundamentalInstance.prevProps = prevProps;\n          fundamentalInstance.props = newProps;\n          fundamentalInstance.currentFiber = workInProgress;\n          if (supportsPersistence) {\n            const instance = cloneFundamentalInstance(fundamentalInstance);\n            fundamentalInstance.instance = instance;\n            appendAllChildren(instance, workInProgress, false, false);\n          }\n          const shouldUpdate = shouldUpdateFundamentalComponent(\n            fundamentalInstance,\n          );\n          if (shouldUpdate) {\n            markUpdate(workInProgress);\n          }\n        }\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        if (current === null) {\n          const type = workInProgress.type;\n          const scopeInstance: ReactScopeInstance = {\n            fiber: workInProgress,\n            methods: null,\n          };\n          workInProgress.stateNode = scopeInstance;\n          scopeInstance.methods = createScopeMethods(type, scopeInstance);\n          if (enableFlareAPI) {\n            const listeners = newProps.listeners;\n            if (listeners != null) {\n              const rootContainerInstance = getRootHostContainer();\n              updateEventListeners(\n                listeners,\n                workInProgress,\n                rootContainerInstance,\n              );\n            }\n          }\n          if (workInProgress.ref !== null) {\n            markRef(workInProgress);\n            markUpdate(workInProgress);\n          }\n        } else {\n          if (enableFlareAPI) {\n            const prevListeners = current.memoizedProps.listeners;\n            const nextListeners = newProps.listeners;\n            if (\n              prevListeners !== nextListeners ||\n              workInProgress.ref !== null\n            ) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            if (workInProgress.ref !== null) {\n              markUpdate(workInProgress);\n            }\n          }\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        }\n      }\n      break;\n    }\n    default:\n      invariant(\n        false,\n        'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n          'React. Please file an issue.',\n        workInProgress.tag,\n      );\n  }\n\n  return null;\n}\n\nexport {completeWork};\n"]},"metadata":{},"sourceType":"module"}