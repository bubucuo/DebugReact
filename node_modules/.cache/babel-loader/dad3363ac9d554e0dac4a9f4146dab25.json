{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { invokeGuardedCallbackAndCatchFirstError } from 'shared/ReactErrorUtils';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nexport let getFiberCurrentPropsFromNode = null;\nexport let getInstanceFromNode = null;\nexport let getNodeFromInstance = null;\nexport function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode = getInstanceFromNodeImpl;\n  getNodeFromInstance = getNodeFromInstanceImpl;\n\n  if (__DEV__) {\n    warningWithoutStack(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n  }\n}\nlet validateEventDispatches;\n\nif (__DEV__) {\n  validateEventDispatches = function (event) {\n    const dispatchListeners = event._dispatchListeners;\n    const dispatchInstances = event._dispatchInstances;\n    const listenersIsArr = Array.isArray(dispatchListeners);\n    const listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n    const instancesIsArr = Array.isArray(dispatchInstances);\n    const instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n    warningWithoutStack(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n  };\n}\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\n\n\nexport function executeDispatch(event, listener, inst) {\n  const type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\n\nexport function executeDispatchesInOrder(event) {\n  const dispatchListeners = event._dispatchListeners;\n  const dispatchInstances = event._dispatchInstances;\n\n  if (__DEV__) {\n    validateEventDispatches(event);\n  }\n\n  if (Array.isArray(dispatchListeners)) {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, dispatchListeners, dispatchInstances);\n  }\n\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\n\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  const dispatchListeners = event._dispatchListeners;\n  const dispatchInstances = event._dispatchInstances;\n\n  if (__DEV__) {\n    validateEventDispatches(event);\n  }\n\n  if (Array.isArray(dispatchListeners)) {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n\n  return null;\n}\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\nexport function executeDispatchesInOrderStopAtTrue(event) {\n  const ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\nexport function executeDirectDispatch(event) {\n  if (__DEV__) {\n    validateEventDispatches(event);\n  }\n\n  const dispatchListener = event._dispatchListeners;\n  const dispatchInstance = event._dispatchInstances;\n  invariant(!Array.isArray(dispatchListener), 'executeDirectDispatch(...): Invalid `event`.');\n  event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;\n  const res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\nexport function hasDispatches(event) {\n  return !!event._dispatchListeners;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/legacy-events/EventPluginUtils.js"],"names":["invokeGuardedCallbackAndCatchFirstError","invariant","warningWithoutStack","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","setComponentTree","getFiberCurrentPropsFromNodeImpl","getInstanceFromNodeImpl","getNodeFromInstanceImpl","__DEV__","validateEventDispatches","event","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","Array","isArray","listenersLen","length","instancesIsArr","instancesLen","executeDispatch","listener","inst","type","currentTarget","undefined","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","res","hasDispatches"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {invokeGuardedCallbackAndCatchFirstError} from 'shared/ReactErrorUtils';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nexport let getFiberCurrentPropsFromNode = null;\nexport let getInstanceFromNode = null;\nexport let getNodeFromInstance = null;\n\nexport function setComponentTree(\n  getFiberCurrentPropsFromNodeImpl,\n  getInstanceFromNodeImpl,\n  getNodeFromInstanceImpl,\n) {\n  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode = getInstanceFromNodeImpl;\n  getNodeFromInstance = getNodeFromInstanceImpl;\n  if (__DEV__) {\n    warningWithoutStack(\n      getNodeFromInstance && getInstanceFromNode,\n      'EventPluginUtils.setComponentTree(...): Injected ' +\n        'module is missing getNodeFromInstance or getInstanceFromNode.',\n    );\n  }\n}\n\nlet validateEventDispatches;\nif (__DEV__) {\n  validateEventDispatches = function(event) {\n    const dispatchListeners = event._dispatchListeners;\n    const dispatchInstances = event._dispatchInstances;\n\n    const listenersIsArr = Array.isArray(dispatchListeners);\n    const listenersLen = listenersIsArr\n      ? dispatchListeners.length\n      : dispatchListeners\n        ? 1\n        : 0;\n\n    const instancesIsArr = Array.isArray(dispatchInstances);\n    const instancesLen = instancesIsArr\n      ? dispatchInstances.length\n      : dispatchInstances\n        ? 1\n        : 0;\n\n    warningWithoutStack(\n      instancesIsArr === listenersIsArr && instancesLen === listenersLen,\n      'EventPluginUtils: Invalid `event`.',\n    );\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nexport function executeDispatch(event, listener, inst) {\n  const type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nexport function executeDispatchesInOrder(event) {\n  const dispatchListeners = event._dispatchListeners;\n  const dispatchInstances = event._dispatchInstances;\n  if (__DEV__) {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  const dispatchListeners = event._dispatchListeners;\n  const dispatchInstances = event._dispatchInstances;\n  if (__DEV__) {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nexport function executeDispatchesInOrderStopAtTrue(event) {\n  const ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nexport function executeDirectDispatch(event) {\n  if (__DEV__) {\n    validateEventDispatches(event);\n  }\n  const dispatchListener = event._dispatchListeners;\n  const dispatchInstance = event._dispatchInstances;\n  invariant(\n    !Array.isArray(dispatchListener),\n    'executeDirectDispatch(...): Invalid `event`.',\n  );\n  event.currentTarget = dispatchListener\n    ? getNodeFromInstance(dispatchInstance)\n    : null;\n  const res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nexport function hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n"]},"metadata":{},"sourceType":"module"}