{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isFiberMounted } from 'react-reconciler/reflection';\nimport { disableLegacyContext } from 'shared/ReactFeatureFlags';\nimport { ClassComponent, HostRoot } from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport { setCurrentPhase, getCurrentFiberStackInDev } from './ReactCurrentFiber';\nimport { startPhaseTimer, stopPhaseTimer } from './ReactDebugFiberPerf';\nimport { createCursor, push, pop } from './ReactFiberStack';\nlet warnedAboutMissingGetChildContext;\n\nif (__DEV__) {\n  warnedAboutMissingGetChildContext = {};\n}\n\nexport const emptyContextObject = {};\n\nif (__DEV__) {\n  Object.freeze(emptyContextObject);\n} // A cursor to the current merged context object on the stack.\n\n\nlet contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n\nlet didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\n\nlet previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    const type = workInProgress.type;\n    const contextTypes = type.contextTypes;\n\n    if (!contextTypes) {\n      return emptyContextObject;\n    } // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n    const instance = workInProgress.stateNode;\n\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    const context = {};\n\n    for (let key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    if (__DEV__) {\n      const name = getComponentName(type) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name, getCurrentFiberStackInDev);\n    } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n\n\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged() {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type) {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    invariant(contextStackCursor.current === emptyContextObject, 'Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  if (disableLegacyContext) {\n    return parentContext;\n  } else {\n    const instance = fiber.stateNode;\n    const childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n    if (typeof instance.getChildContext !== 'function') {\n      if (__DEV__) {\n        const componentName = getComponentName(type) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          warningWithoutStack(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n\n      return parentContext;\n    }\n\n    let childContext;\n\n    if (__DEV__) {\n      setCurrentPhase('getChildContext');\n    }\n\n    startPhaseTimer(fiber, 'getChildContext');\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n\n    if (__DEV__) {\n      setCurrentPhase(null);\n    }\n\n    for (let contextKey in childContext) {\n      invariant(contextKey in childContextTypes, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(type) || 'Unknown', contextKey);\n    }\n\n    if (__DEV__) {\n      const name = getComponentName(type) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name, // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      getCurrentFiberStackInDev);\n    }\n\n    return { ...parentContext,\n      ...childContext\n    };\n  }\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n\n    const memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n    invariant(instance, 'Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      const mergedContext = processChildContext(workInProgress, type, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    invariant(isFiberMounted(fiber) && fiber.tag === ClassComponent, 'Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    let node = fiber;\n\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n\n        case ClassComponent:\n          {\n            const Component = node.type;\n\n            if (isContextProvider(Component)) {\n              return node.stateNode.__reactInternalMemoizedMergedChildContext;\n            }\n\n            break;\n          }\n      }\n\n      node = node.return;\n    } while (node !== null);\n\n    invariant(false, 'Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nexport { getUnmaskedContext, cacheContext, getMaskedContext, hasContextChanged, popContext, popTopLevelContextObject, pushTopLevelContextObject, processChildContext, isContextProvider, pushContextProvider, invalidateContextProvider, findCurrentUnmaskedContext };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberContext.js"],"names":["isFiberMounted","disableLegacyContext","ClassComponent","HostRoot","getComponentName","invariant","warningWithoutStack","checkPropTypes","setCurrentPhase","getCurrentFiberStackInDev","startPhaseTimer","stopPhaseTimer","createCursor","push","pop","warnedAboutMissingGetChildContext","__DEV__","emptyContextObject","Object","freeze","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","workInProgress","Component","didPushOwnContextIfProvider","isContextProvider","current","cacheContext","unmaskedContext","maskedContext","instance","stateNode","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","type","contextTypes","context","key","name","hasContextChanged","childContextTypes","undefined","popContext","fiber","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","componentName","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","findCurrentUnmaskedContext","tag","node","return"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {StackCursor} from './ReactFiberStack';\n\nimport {isFiberMounted} from 'react-reconciler/reflection';\nimport {disableLegacyContext} from 'shared/ReactFeatureFlags';\nimport {ClassComponent, HostRoot} from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport checkPropTypes from 'prop-types/checkPropTypes';\n\nimport {setCurrentPhase, getCurrentFiberStackInDev} from './ReactCurrentFiber';\nimport {startPhaseTimer, stopPhaseTimer} from './ReactDebugFiberPerf';\nimport {createCursor, push, pop} from './ReactFiberStack';\n\nlet warnedAboutMissingGetChildContext;\n\nif (__DEV__) {\n  warnedAboutMissingGetChildContext = {};\n}\n\nexport const emptyContextObject = {};\nif (__DEV__) {\n  Object.freeze(emptyContextObject);\n}\n\n// A cursor to the current merged context object on the stack.\nlet contextStackCursor: StackCursor<Object> = createCursor(emptyContextObject);\n// A cursor to a boolean indicating whether the context has changed.\nlet didPerformWorkStackCursor: StackCursor<boolean> = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nlet previousContext: Object = emptyContextObject;\n\nfunction getUnmaskedContext(\n  workInProgress: Fiber,\n  Component: Function,\n  didPushOwnContextIfProvider: boolean,\n): Object {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(\n  workInProgress: Fiber,\n  unmaskedContext: Object,\n  maskedContext: Object,\n): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(\n  workInProgress: Fiber,\n  unmaskedContext: Object,\n): Object {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    const type = workInProgress.type;\n    const contextTypes = type.contextTypes;\n    if (!contextTypes) {\n      return emptyContextObject;\n    }\n\n    // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n    const instance = workInProgress.stateNode;\n    if (\n      instance &&\n      instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n    ) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    const context = {};\n    for (let key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    if (__DEV__) {\n      const name = getComponentName(type) || 'Unknown';\n      checkPropTypes(\n        contextTypes,\n        context,\n        'context',\n        name,\n        getCurrentFiberStackInDev,\n      );\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged(): boolean {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type: Function): boolean {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber: Fiber): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber: Fiber): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(\n  fiber: Fiber,\n  context: Object,\n  didChange: boolean,\n): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    invariant(\n      contextStackCursor.current === emptyContextObject,\n      'Unexpected context found on stack. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(\n  fiber: Fiber,\n  type: any,\n  parentContext: Object,\n): Object {\n  if (disableLegacyContext) {\n    return parentContext;\n  } else {\n    const instance = fiber.stateNode;\n    const childContextTypes = type.childContextTypes;\n\n    // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n    if (typeof instance.getChildContext !== 'function') {\n      if (__DEV__) {\n        const componentName = getComponentName(type) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          warningWithoutStack(\n            false,\n            '%s.childContextTypes is specified but there is no getChildContext() method ' +\n              'on the instance. You can either define getChildContext() on %s or remove ' +\n              'childContextTypes from it.',\n            componentName,\n            componentName,\n          );\n        }\n      }\n      return parentContext;\n    }\n\n    let childContext;\n    if (__DEV__) {\n      setCurrentPhase('getChildContext');\n    }\n    startPhaseTimer(fiber, 'getChildContext');\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n    if (__DEV__) {\n      setCurrentPhase(null);\n    }\n    for (let contextKey in childContext) {\n      invariant(\n        contextKey in childContextTypes,\n        '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n        getComponentName(type) || 'Unknown',\n        contextKey,\n      );\n    }\n    if (__DEV__) {\n      const name = getComponentName(type) || 'Unknown';\n      checkPropTypes(\n        childContextTypes,\n        childContext,\n        'child context',\n        name,\n        // In practice, there is one case in which we won't get a stack. It's when\n        // somebody calls unstable_renderSubtreeIntoContainer() and we process\n        // context from the parent component instance. The stack will be missing\n        // because it's outside of the reconciliation, and so the pointer has not\n        // been set. This is rare and doesn't matter. We'll also remove that API.\n        getCurrentFiberStackInDev,\n      );\n    }\n\n    return {...parentContext, ...childContext};\n  }\n}\n\nfunction pushContextProvider(workInProgress: Fiber): boolean {\n  if (disableLegacyContext) {\n    return false;\n  } else {\n    const instance = workInProgress.stateNode;\n    // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n    const memoizedMergedChildContext =\n      (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n      emptyContextObject;\n\n    // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(\n      didPerformWorkStackCursor,\n      didPerformWorkStackCursor.current,\n      workInProgress,\n    );\n\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(\n  workInProgress: Fiber,\n  type: any,\n  didChange: boolean,\n): void {\n  if (disableLegacyContext) {\n    return;\n  } else {\n    const instance = workInProgress.stateNode;\n    invariant(\n      instance,\n      'Expected to have an instance by this point. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      const mergedContext = processChildContext(\n        workInProgress,\n        type,\n        previousContext,\n      );\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n      // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress);\n      // Now push the new context and mark that it has changed.\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber: Fiber): Object {\n  if (disableLegacyContext) {\n    return emptyContextObject;\n  } else {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    invariant(\n      isFiberMounted(fiber) && fiber.tag === ClassComponent,\n      'Expected subtree parent to be a mounted class component. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n\n    let node = fiber;\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n        case ClassComponent: {\n          const Component = node.type;\n          if (isContextProvider(Component)) {\n            return node.stateNode.__reactInternalMemoizedMergedChildContext;\n          }\n          break;\n        }\n      }\n      node = node.return;\n    } while (node !== null);\n    invariant(\n      false,\n      'Found unexpected detached subtree parent. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n}\n\nexport {\n  getUnmaskedContext,\n  cacheContext,\n  getMaskedContext,\n  hasContextChanged,\n  popContext,\n  popTopLevelContextObject,\n  pushTopLevelContextObject,\n  processChildContext,\n  isContextProvider,\n  pushContextProvider,\n  invalidateContextProvider,\n  findCurrentUnmaskedContext,\n};\n"]},"metadata":{},"sourceType":"module"}