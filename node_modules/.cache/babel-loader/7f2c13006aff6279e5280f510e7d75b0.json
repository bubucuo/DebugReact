{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from 'shared/invariant';\nimport { getChildHostContext, getRootHostContext } from './ReactFiberHostConfig';\nimport { createCursor, push, pop } from './ReactFiberStack';\nconst NO_CONTEXT = {};\nlet contextStackCursor = createCursor(NO_CONTEXT);\nlet contextFiberStackCursor = createCursor(NO_CONTEXT);\nlet rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  invariant(c !== NO_CONTEXT, 'Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  return c;\n}\n\nfunction getRootHostContainer() {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n\n  push(contextStackCursor, NO_CONTEXT, fiber);\n  const nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n  pop(contextStackCursor, fiber);\n  push(contextStackCursor, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  const context = requiredContext(contextStackCursor.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  const context = requiredContext(contextStackCursor.current);\n  const nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n  if (context === nextContext) {\n    return;\n  } // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nexport { getHostContext, getRootHostContainer, popHostContainer, popHostContext, pushHostContainer, pushHostContext };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberHostContext.js"],"names":["invariant","getChildHostContext","getRootHostContext","createCursor","push","pop","NO_CONTEXT","contextStackCursor","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","c","getRootHostContainer","rootInstance","current","pushHostContainer","fiber","nextRootInstance","nextRootContext","popHostContainer","getHostContext","context","pushHostContext","nextContext","type","popHostContext"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {StackCursor} from './ReactFiberStack';\nimport type {Container, HostContext} from './ReactFiberHostConfig';\n\nimport invariant from 'shared/invariant';\n\nimport {getChildHostContext, getRootHostContext} from './ReactFiberHostConfig';\nimport {createCursor, push, pop} from './ReactFiberStack';\n\ndeclare class NoContextT {}\nconst NO_CONTEXT: NoContextT = ({}: any);\n\nlet contextStackCursor: StackCursor<HostContext | NoContextT> = createCursor(\n  NO_CONTEXT,\n);\nlet contextFiberStackCursor: StackCursor<Fiber | NoContextT> = createCursor(\n  NO_CONTEXT,\n);\nlet rootInstanceStackCursor: StackCursor<Container | NoContextT> = createCursor(\n  NO_CONTEXT,\n);\n\nfunction requiredContext<Value>(c: Value | NoContextT): Value {\n  invariant(\n    c !== NO_CONTEXT,\n    'Expected host context to exist. This error is likely caused by a bug ' +\n      'in React. Please file an issue.',\n  );\n  return (c: any);\n}\n\nfunction getRootHostContainer(): Container {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber: Fiber, nextRootInstance: Container) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor, NO_CONTEXT, fiber);\n  const nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor, fiber);\n  push(contextStackCursor, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber: Fiber) {\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext(): HostContext {\n  const context = requiredContext(contextStackCursor.current);\n  return context;\n}\n\nfunction pushHostContext(fiber: Fiber): void {\n  const rootInstance: Container = requiredContext(\n    rootInstanceStackCursor.current,\n  );\n  const context: HostContext = requiredContext(contextStackCursor.current);\n  const nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor, nextContext, fiber);\n}\n\nfunction popHostContext(fiber: Fiber): void {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nexport {\n  getHostContext,\n  getRootHostContainer,\n  popHostContainer,\n  popHostContext,\n  pushHostContainer,\n  pushHostContext,\n};\n"]},"metadata":{},"sourceType":"module"}