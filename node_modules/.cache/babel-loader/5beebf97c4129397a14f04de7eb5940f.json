{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from 'shared/invariant';\n\n/**\n * Injectable ordering of event plugins.\n */\nlet eventPluginOrder = null;\n/**\n * Injectable mapping from names to event plugin modules.\n */\n\nconst namesToPlugins = {};\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\n\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n\n  for (const pluginName in namesToPlugins) {\n    const pluginModule = namesToPlugins[pluginName];\n    const pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(pluginIndex > -1, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName);\n\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n\n    invariant(pluginModule.extractEvents, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName);\n    plugins[pluginIndex] = pluginModule;\n    const publishedEvents = pluginModule.eventTypes;\n\n    for (const eventName in publishedEvents) {\n      invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName);\n    }\n  }\n}\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\n\n\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName);\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n  const phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n\n  if (phasedRegistrationNames) {\n    for (const phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        const phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\n\n\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  invariant(!registrationNameModules[registrationName], 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  if (__DEV__) {\n    const lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\n\n\nexport const plugins = [];\n/**\n * Mapping from event name to dispatch config\n */\n\nexport const eventNameDispatchConfigs = {};\n/**\n * Mapping from registration name to plugin module\n */\n\nexport const registrationNameModules = {};\n/**\n * Mapping from registration name to event name\n */\n\nexport const registrationNameDependencies = {};\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in __DEV__.\n * @type {Object}\n */\n\nexport const possibleRegistrationNames = __DEV__ ? {} : null; // Trust the developer to only use possibleRegistrationNames in __DEV__\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\n\nexport function injectEventPluginOrder(injectedEventPluginOrder) {\n  invariant(!eventPluginOrder, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.'); // Clone the ordering so it cannot be dynamically mutated.\n\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\n\nexport function injectEventPluginsByName(injectedNamesToPlugins) {\n  let isOrderingDirty = false;\n\n  for (const pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n\n    const pluginModule = injectedNamesToPlugins[pluginName];\n\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      invariant(!namesToPlugins[pluginName], 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName);\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/legacy-events/EventPluginRegistry.js"],"names":["invariant","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","hasOwnProperty","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","__DEV__","lowerCasedName","toLowerCase","possibleRegistrationNames","ondblclick","injectEventPluginOrder","injectedEventPluginOrder","Array","prototype","slice","call","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {DispatchConfig} from './ReactSyntheticEventType';\nimport type {\n  AnyNativeEvent,\n  PluginName,\n  PluginModule,\n} from './PluginModuleType';\n\nimport invariant from 'shared/invariant';\n\ntype NamesToPlugins = {[key: PluginName]: PluginModule<AnyNativeEvent>};\ntype EventPluginOrder = null | Array<PluginName>;\n\n/**\n * Injectable ordering of event plugins.\n */\nlet eventPluginOrder: EventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nconst namesToPlugins: NamesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering(): void {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (const pluginName in namesToPlugins) {\n    const pluginModule = namesToPlugins[pluginName];\n    const pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(\n      pluginIndex > -1,\n      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +\n        'the plugin ordering, `%s`.',\n      pluginName,\n    );\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    invariant(\n      pluginModule.extractEvents,\n      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +\n        'method, but `%s` does not.',\n      pluginName,\n    );\n    plugins[pluginIndex] = pluginModule;\n    const publishedEvents = pluginModule.eventTypes;\n    for (const eventName in publishedEvents) {\n      invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          pluginModule,\n          eventName,\n        ),\n        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',\n        eventName,\n        pluginName,\n      );\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(\n  dispatchConfig: DispatchConfig,\n  pluginModule: PluginModule<AnyNativeEvent>,\n  eventName: string,\n): boolean {\n  invariant(\n    !eventNameDispatchConfigs.hasOwnProperty(eventName),\n    'EventPluginHub: More than one plugin attempted to publish the same ' +\n      'event name, `%s`.',\n    eventName,\n  );\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  const phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (const phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        const phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          pluginModule,\n          eventName,\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      pluginModule,\n      eventName,\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(\n  registrationName: string,\n  pluginModule: PluginModule<AnyNativeEvent>,\n  eventName: string,\n): void {\n  invariant(\n    !registrationNameModules[registrationName],\n    'EventPluginHub: More than one plugin attempted to publish the same ' +\n      'registration name, `%s`.',\n    registrationName,\n  );\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] =\n    pluginModule.eventTypes[eventName].dependencies;\n\n  if (__DEV__) {\n    const lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nexport const plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nexport const eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nexport const registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nexport const registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in __DEV__.\n * @type {Object}\n */\nexport const possibleRegistrationNames = __DEV__ ? {} : (null: any);\n// Trust the developer to only use possibleRegistrationNames in __DEV__\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nexport function injectEventPluginOrder(\n  injectedEventPluginOrder: EventPluginOrder,\n): void {\n  invariant(\n    !eventPluginOrder,\n    'EventPluginRegistry: Cannot inject event plugin ordering more than ' +\n      'once. You are likely trying to load more than one copy of React.',\n  );\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nexport function injectEventPluginsByName(\n  injectedNamesToPlugins: NamesToPlugins,\n): void {\n  let isOrderingDirty = false;\n  for (const pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    const pluginModule = injectedNamesToPlugins[pluginName];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName) ||\n      namesToPlugins[pluginName] !== pluginModule\n    ) {\n      invariant(\n        !namesToPlugins[pluginName],\n        'EventPluginRegistry: Cannot inject two different event plugins ' +\n          'using the same name, `%s`.',\n        pluginName,\n      );\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}