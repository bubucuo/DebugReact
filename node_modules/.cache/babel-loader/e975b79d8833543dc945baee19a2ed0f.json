{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from 'shared/invariant';\nimport invokeGuardedCallbackImpl from './invokeGuardedCallbackImpl'; // Used by Fiber to simulate a try-catch.\n\nlet hasError = false;\nlet caughtError = null; // Used by event system to capture/rethrow the first error.\n\nlet hasRethrowError = false;\nlet rethrowError = null;\nconst reporter = {\n  onError(error) {\n    hasError = true;\n    caughtError = error;\n  }\n\n};\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\nexport function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl.apply(reporter, arguments);\n}\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\nexport function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n  invokeGuardedCallback.apply(this, arguments);\n\n  if (hasError) {\n    const error = clearCaughtError();\n\n    if (!hasRethrowError) {\n      hasRethrowError = true;\n      rethrowError = error;\n    }\n  }\n}\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\n\nexport function rethrowCaughtError() {\n  if (hasRethrowError) {\n    const error = rethrowError;\n    hasRethrowError = false;\n    rethrowError = null;\n    throw error;\n  }\n}\nexport function hasCaughtError() {\n  return hasError;\n}\nexport function clearCaughtError() {\n  if (hasError) {\n    const error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    invariant(false, 'clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/shared/ReactErrorUtils.js"],"names":["invariant","invokeGuardedCallbackImpl","hasError","caughtError","hasRethrowError","rethrowError","reporter","onError","error","invokeGuardedCallback","name","func","context","a","b","c","d","e","f","apply","arguments","invokeGuardedCallbackAndCatchFirstError","clearCaughtError","rethrowCaughtError","hasCaughtError"],"mappings":"AAAA;;;;;;;;AASA,OAAOA,SAAP,MAAsB,kBAAtB;AACA,OAAOC,yBAAP,MAAsC,6BAAtC,C,CAEA;;AACA,IAAIC,QAAiB,GAAG,KAAxB;AACA,IAAIC,WAAkB,GAAG,IAAzB,C,CAEA;;AACA,IAAIC,eAAwB,GAAG,KAA/B;AACA,IAAIC,YAAmB,GAAG,IAA1B;AAEA,MAAMC,QAAQ,GAAG;AACfC,EAAAA,OAAO,CAACC,KAAD,EAAe;AACpBN,IAAAA,QAAQ,GAAG,IAAX;AACAC,IAAAA,WAAW,GAAGK,KAAd;AACD;;AAJc,CAAjB;AAOA;;;;;;;;;;;;;;AAaA,OAAO,SAASC,qBAAT,CACLC,IADK,EAELC,IAFK,EAGLC,OAHK,EAILC,CAJK,EAKLC,CALK,EAMLC,CANK,EAOLC,CAPK,EAQLC,CARK,EASLC,CATK,EAUC;AACNhB,EAAAA,QAAQ,GAAG,KAAX;AACAC,EAAAA,WAAW,GAAG,IAAd;AACAF,EAAAA,yBAAyB,CAACkB,KAA1B,CAAgCb,QAAhC,EAA0Cc,SAA1C;AACD;AAED;;;;;;;;;;;AAUA,OAAO,SAASC,uCAAT,CASLX,IATK,EAULC,IAVK,EAWLC,OAXK,EAYLC,CAZK,EAaLC,CAbK,EAcLC,CAdK,EAeLC,CAfK,EAgBLC,CAhBK,EAiBLC,CAjBK,EAkBC;AACNT,EAAAA,qBAAqB,CAACU,KAAtB,CAA4B,IAA5B,EAAkCC,SAAlC;;AACA,MAAIlB,QAAJ,EAAc;AACZ,UAAMM,KAAK,GAAGc,gBAAgB,EAA9B;;AACA,QAAI,CAAClB,eAAL,EAAsB;AACpBA,MAAAA,eAAe,GAAG,IAAlB;AACAC,MAAAA,YAAY,GAAGG,KAAf;AACD;AACF;AACF;AAED;;;;;AAIA,OAAO,SAASe,kBAAT,GAA8B;AACnC,MAAInB,eAAJ,EAAqB;AACnB,UAAMI,KAAK,GAAGH,YAAd;AACAD,IAAAA,eAAe,GAAG,KAAlB;AACAC,IAAAA,YAAY,GAAG,IAAf;AACA,UAAMG,KAAN;AACD;AACF;AAED,OAAO,SAASgB,cAAT,GAA0B;AAC/B,SAAOtB,QAAP;AACD;AAED,OAAO,SAASoB,gBAAT,GAA4B;AACjC,MAAIpB,QAAJ,EAAc;AACZ,UAAMM,KAAK,GAAGL,WAAd;AACAD,IAAAA,QAAQ,GAAG,KAAX;AACAC,IAAAA,WAAW,GAAG,IAAd;AACA,WAAOK,KAAP;AACD,GALD,MAKO;AACLR,IAAAA,SAAS,CACP,KADO,EAEP,uEACE,2DAHK,CAAT;AAKD;AACF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\nimport invokeGuardedCallbackImpl from './invokeGuardedCallbackImpl';\n\n// Used by Fiber to simulate a try-catch.\nlet hasError: boolean = false;\nlet caughtError: mixed = null;\n\n// Used by event system to capture/rethrow the first error.\nlet hasRethrowError: boolean = false;\nlet rethrowError: mixed = null;\n\nconst reporter = {\n  onError(error: mixed) {\n    hasError = true;\n    caughtError = error;\n  },\n};\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nexport function invokeGuardedCallback<A, B, C, D, E, F, Context>(\n  name: string | null,\n  func: (a: A, b: B, c: C, d: D, e: E, f: F) => mixed,\n  context: Context,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n): void {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl.apply(reporter, arguments);\n}\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nexport function invokeGuardedCallbackAndCatchFirstError<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  Context,\n>(\n  name: string | null,\n  func: (a: A, b: B, c: C, d: D, e: E, f: F) => void,\n  context: Context,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n): void {\n  invokeGuardedCallback.apply(this, arguments);\n  if (hasError) {\n    const error = clearCaughtError();\n    if (!hasRethrowError) {\n      hasRethrowError = true;\n      rethrowError = error;\n    }\n  }\n}\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\nexport function rethrowCaughtError() {\n  if (hasRethrowError) {\n    const error = rethrowError;\n    hasRethrowError = false;\n    rethrowError = null;\n    throw error;\n  }\n}\n\nexport function hasCaughtError() {\n  return hasError;\n}\n\nexport function clearCaughtError() {\n  if (hasError) {\n    const error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    invariant(\n      false,\n      'clearCaughtError was called but no error was captured. This error ' +\n        'is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}