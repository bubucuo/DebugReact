{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from 'shared/invariant';\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  invariant(next != null, 'accumulateInto(...): Accumulated items must not be null or undefined.');\n\n  if (current == null) {\n    return next;\n  } // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n\n\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\nexport default accumulateInto;","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/legacy-events/accumulateInto.js"],"names":["invariant","accumulateInto","current","next","Array","isArray","push","apply","concat"],"mappings":"AAAA;;;;;;;;AASA,OAAOA,SAAP,MAAsB,kBAAtB;AAEA;;;;;;;;;;;;;AAaA,SAASC,cAAT,CACEC,OADF,EAEEC,IAFF,EAGgB;AACdH,EAAAA,SAAS,CACPG,IAAI,IAAI,IADD,EAEP,uEAFO,CAAT;;AAKA,MAAID,OAAO,IAAI,IAAf,EAAqB;AACnB,WAAOC,IAAP;AACD,GARa,CAUd;AACA;;;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcH,OAAd,CAAJ,EAA4B;AAC1B,QAAIE,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;AACvBD,MAAAA,OAAO,CAACI,IAAR,CAAaC,KAAb,CAAmBL,OAAnB,EAA4BC,IAA5B;AACA,aAAOD,OAAP;AACD;;AACDA,IAAAA,OAAO,CAACI,IAAR,CAAaH,IAAb;AACA,WAAOD,OAAP;AACD;;AAED,MAAIE,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;AACvB;AACA,WAAO,CAACD,OAAD,EAAUM,MAAV,CAAiBL,IAAjB,CAAP;AACD;;AAED,SAAO,CAACD,OAAD,EAAUC,IAAV,CAAP;AACD;;AAED,eAAeF,cAAf","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto<T>(\n  current: ?(Array<T> | T),\n  next: T | Array<T>,\n): T | Array<T> {\n  invariant(\n    next != null,\n    'accumulateInto(...): Accumulated items must not be null or undefined.',\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\nexport default accumulateInto;\n"]},"metadata":{},"sourceType":"module"}