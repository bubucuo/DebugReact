{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { needsStateRestore, restoreStateIfNeeded } from './ReactControlledComponent';\nimport { enableFlareAPI } from 'shared/ReactFeatureFlags';\nimport { invokeGuardedCallbackAndCatchFirstError } from 'shared/ReactErrorUtils'; // Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\n\nlet batchedUpdatesImpl = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nlet discreteUpdatesImpl = function (fn, a, b, c) {\n  return fn(a, b, c);\n};\n\nlet flushDiscreteUpdatesImpl = function () {};\n\nlet batchedEventUpdatesImpl = batchedUpdatesImpl;\nlet isInsideEventHandler = false;\nlet isBatchingEventUpdates = false;\n\nfunction finishEventHandler() {\n  // Here we wait until all updates have propagated, which is important\n  // when using controlled components within layers:\n  // https://github.com/facebook/react/issues/1698\n  // Then we restore state of any controlled component.\n  const controlledComponentsHavePendingUpdates = needsStateRestore();\n\n  if (controlledComponentsHavePendingUpdates) {\n    // If a controlled event was fired, we may need to restore the state of\n    // the DOM node back to the controlled value. This is necessary when React\n    // bails out of the update without touching the DOM.\n    flushDiscreteUpdatesImpl();\n    restoreStateIfNeeded();\n  }\n}\n\nexport function batchedUpdates(fn, bookkeeping) {\n  if (isInsideEventHandler) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n\n  isInsideEventHandler = true;\n\n  try {\n    return batchedUpdatesImpl(fn, bookkeeping);\n  } finally {\n    isInsideEventHandler = false;\n    finishEventHandler();\n  }\n}\nexport function batchedEventUpdates(fn, a, b) {\n  if (isBatchingEventUpdates) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(a, b);\n  }\n\n  isBatchingEventUpdates = true;\n\n  try {\n    return batchedEventUpdatesImpl(fn, a, b);\n  } finally {\n    isBatchingEventUpdates = false;\n    finishEventHandler();\n  }\n} // This is for the React Flare event system\n\nexport function executeUserEventHandler(fn, value) {\n  const previouslyInEventHandler = isInsideEventHandler;\n\n  try {\n    isInsideEventHandler = true;\n    const type = typeof value === 'object' && value !== null ? value.type : '';\n    invokeGuardedCallbackAndCatchFirstError(type, fn, undefined, value);\n  } finally {\n    isInsideEventHandler = previouslyInEventHandler;\n  }\n}\nexport function discreteUpdates(fn, a, b, c) {\n  const prevIsInsideEventHandler = isInsideEventHandler;\n  isInsideEventHandler = true;\n\n  try {\n    return discreteUpdatesImpl(fn, a, b, c);\n  } finally {\n    isInsideEventHandler = prevIsInsideEventHandler;\n\n    if (!isInsideEventHandler) {\n      finishEventHandler();\n    }\n  }\n}\nlet lastFlushedEventTimeStamp = 0;\nexport function flushDiscreteUpdatesIfNeeded(timeStamp) {\n  // event.timeStamp isn't overly reliable due to inconsistencies in\n  // how different browsers have historically provided the time stamp.\n  // Some browsers provide high-resolution time stamps for all events,\n  // some provide low-resolution time stamps for all events. FF < 52\n  // even mixes both time stamps together. Some browsers even report\n  // negative time stamps or time stamps that are 0 (iOS9) in some cases.\n  // Given we are only comparing two time stamps with equality (!==),\n  // we are safe from the resolution differences. If the time stamp is 0\n  // we bail-out of preventing the flush, which can affect semantics,\n  // such as if an earlier flush removes or adds event listeners that\n  // are fired in the subsequent flush. However, this is the same\n  // behaviour as we had before this change, so the risks are low.\n  if (!isInsideEventHandler && (!enableFlareAPI || timeStamp === 0 || lastFlushedEventTimeStamp !== timeStamp)) {\n    lastFlushedEventTimeStamp = timeStamp;\n    flushDiscreteUpdatesImpl();\n  }\n}\nexport function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {\n  batchedUpdatesImpl = _batchedUpdatesImpl;\n  discreteUpdatesImpl = _discreteUpdatesImpl;\n  flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;\n  batchedEventUpdatesImpl = _batchedEventUpdatesImpl;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/legacy-events/ReactGenericBatching.js"],"names":["needsStateRestore","restoreStateIfNeeded","enableFlareAPI","invokeGuardedCallbackAndCatchFirstError","batchedUpdatesImpl","fn","bookkeeping","discreteUpdatesImpl","a","b","c","flushDiscreteUpdatesImpl","batchedEventUpdatesImpl","isInsideEventHandler","isBatchingEventUpdates","finishEventHandler","controlledComponentsHavePendingUpdates","batchedUpdates","batchedEventUpdates","executeUserEventHandler","value","previouslyInEventHandler","type","undefined","discreteUpdates","prevIsInsideEventHandler","lastFlushedEventTimeStamp","flushDiscreteUpdatesIfNeeded","timeStamp","setBatchingImplementation","_batchedUpdatesImpl","_discreteUpdatesImpl","_flushDiscreteUpdatesImpl","_batchedEventUpdatesImpl"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  needsStateRestore,\n  restoreStateIfNeeded,\n} from './ReactControlledComponent';\n\nimport {enableFlareAPI} from 'shared/ReactFeatureFlags';\nimport {invokeGuardedCallbackAndCatchFirstError} from 'shared/ReactErrorUtils';\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nlet batchedUpdatesImpl = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nlet discreteUpdatesImpl = function(fn, a, b, c) {\n  return fn(a, b, c);\n};\nlet flushDiscreteUpdatesImpl = function() {};\nlet batchedEventUpdatesImpl = batchedUpdatesImpl;\n\nlet isInsideEventHandler = false;\nlet isBatchingEventUpdates = false;\n\nfunction finishEventHandler() {\n  // Here we wait until all updates have propagated, which is important\n  // when using controlled components within layers:\n  // https://github.com/facebook/react/issues/1698\n  // Then we restore state of any controlled component.\n  const controlledComponentsHavePendingUpdates = needsStateRestore();\n  if (controlledComponentsHavePendingUpdates) {\n    // If a controlled event was fired, we may need to restore the state of\n    // the DOM node back to the controlled value. This is necessary when React\n    // bails out of the update without touching the DOM.\n    flushDiscreteUpdatesImpl();\n    restoreStateIfNeeded();\n  }\n}\n\nexport function batchedUpdates(fn, bookkeeping) {\n  if (isInsideEventHandler) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isInsideEventHandler = true;\n  try {\n    return batchedUpdatesImpl(fn, bookkeeping);\n  } finally {\n    isInsideEventHandler = false;\n    finishEventHandler();\n  }\n}\n\nexport function batchedEventUpdates(fn, a, b) {\n  if (isBatchingEventUpdates) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(a, b);\n  }\n  isBatchingEventUpdates = true;\n  try {\n    return batchedEventUpdatesImpl(fn, a, b);\n  } finally {\n    isBatchingEventUpdates = false;\n    finishEventHandler();\n  }\n}\n\n// This is for the React Flare event system\nexport function executeUserEventHandler(fn: any => void, value: any): void {\n  const previouslyInEventHandler = isInsideEventHandler;\n  try {\n    isInsideEventHandler = true;\n    const type = typeof value === 'object' && value !== null ? value.type : '';\n    invokeGuardedCallbackAndCatchFirstError(type, fn, undefined, value);\n  } finally {\n    isInsideEventHandler = previouslyInEventHandler;\n  }\n}\n\nexport function discreteUpdates(fn, a, b, c) {\n  const prevIsInsideEventHandler = isInsideEventHandler;\n  isInsideEventHandler = true;\n  try {\n    return discreteUpdatesImpl(fn, a, b, c);\n  } finally {\n    isInsideEventHandler = prevIsInsideEventHandler;\n    if (!isInsideEventHandler) {\n      finishEventHandler();\n    }\n  }\n}\n\nlet lastFlushedEventTimeStamp = 0;\nexport function flushDiscreteUpdatesIfNeeded(timeStamp: number) {\n  // event.timeStamp isn't overly reliable due to inconsistencies in\n  // how different browsers have historically provided the time stamp.\n  // Some browsers provide high-resolution time stamps for all events,\n  // some provide low-resolution time stamps for all events. FF < 52\n  // even mixes both time stamps together. Some browsers even report\n  // negative time stamps or time stamps that are 0 (iOS9) in some cases.\n  // Given we are only comparing two time stamps with equality (!==),\n  // we are safe from the resolution differences. If the time stamp is 0\n  // we bail-out of preventing the flush, which can affect semantics,\n  // such as if an earlier flush removes or adds event listeners that\n  // are fired in the subsequent flush. However, this is the same\n  // behaviour as we had before this change, so the risks are low.\n  if (\n    !isInsideEventHandler &&\n    (!enableFlareAPI ||\n      (timeStamp === 0 || lastFlushedEventTimeStamp !== timeStamp))\n  ) {\n    lastFlushedEventTimeStamp = timeStamp;\n    flushDiscreteUpdatesImpl();\n  }\n}\n\nexport function setBatchingImplementation(\n  _batchedUpdatesImpl,\n  _discreteUpdatesImpl,\n  _flushDiscreteUpdatesImpl,\n  _batchedEventUpdatesImpl,\n) {\n  batchedUpdatesImpl = _batchedUpdatesImpl;\n  discreteUpdatesImpl = _discreteUpdatesImpl;\n  flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;\n  batchedEventUpdatesImpl = _batchedEventUpdatesImpl;\n}\n"]},"metadata":{},"sourceType":"module"}