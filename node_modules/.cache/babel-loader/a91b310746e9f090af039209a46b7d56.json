{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { getParentInstance, traverseTwoPhase, traverseEnterLeave } from 'shared/ReactTreeTraversal';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport { getListener } from './EventPluginHub';\nimport accumulateInto from './accumulateInto';\nimport forEachAccumulated from './forEachAccumulated';\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  const registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\n\n\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (__DEV__) {\n    warningWithoutStack(inst, 'Dispatching inst must not be null');\n  }\n\n  const listener = listenerAtPhase(inst, event, phase);\n\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    const targetInst = event._targetInst;\n    const parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\n\n\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    const registrationName = event.dispatchConfig.registrationName;\n    const listener = getListener(inst, registrationName);\n\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\n\n\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nexport function accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\nexport function accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\nexport function accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\nexport function accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/legacy-events/EventPropagators.js"],"names":["getParentInstance","traverseTwoPhase","traverseEnterLeave","warningWithoutStack","getListener","accumulateInto","forEachAccumulated","listenerAtPhase","inst","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","__DEV__","listener","_dispatchListeners","_dispatchInstances","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","from","to","accumulateDirectDispatches"],"mappings":"AAAA;;;;;;AAOA,SACEA,iBADF,EAEEC,gBAFF,EAGEC,kBAHF,QAIO,2BAJP;AAKA,OAAOC,mBAAP,MAAgC,4BAAhC;AAEA,SAAQC,WAAR,QAA0B,kBAA1B;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,kBAAP,MAA+B,sBAA/B;;AAIA;;;;AAIA,SAASC,eAAT,CAAyBC,IAAzB,EAA+BC,KAA/B,EAAsCC,gBAAtC,EAA2E;AACzE,QAAMC,gBAAgB,GACpBF,KAAK,CAACG,cAAN,CAAqBC,uBAArB,CAA6CH,gBAA7C,CADF;AAEA,SAAON,WAAW,CAACI,IAAD,EAAOG,gBAAP,CAAlB;AACD;AAED;;;;;;;;;;AAUA;;;;;;;;AAMA,SAASG,+BAAT,CAAyCN,IAAzC,EAA+CO,KAA/C,EAAsDN,KAAtD,EAA6D;AAC3D,MAAIO,OAAJ,EAAa;AACXb,IAAAA,mBAAmB,CAACK,IAAD,EAAO,mCAAP,CAAnB;AACD;;AACD,QAAMS,QAAQ,GAAGV,eAAe,CAACC,IAAD,EAAOC,KAAP,EAAcM,KAAd,CAAhC;;AACA,MAAIE,QAAJ,EAAc;AACZR,IAAAA,KAAK,CAACS,kBAAN,GAA2Bb,cAAc,CACvCI,KAAK,CAACS,kBADiC,EAEvCD,QAFuC,CAAzC;AAIAR,IAAAA,KAAK,CAACU,kBAAN,GAA2Bd,cAAc,CAACI,KAAK,CAACU,kBAAP,EAA2BX,IAA3B,CAAzC;AACD;AACF;AAED;;;;;;;;;AAOA,SAASY,kCAAT,CAA4CX,KAA5C,EAAmD;AACjD,MAAIA,KAAK,IAAIA,KAAK,CAACG,cAAN,CAAqBC,uBAAlC,EAA2D;AACzDZ,IAAAA,gBAAgB,CAACQ,KAAK,CAACY,WAAP,EAAoBP,+BAApB,EAAqDL,KAArD,CAAhB;AACD;AACF;AAED;;;;;AAGA,SAASa,4CAAT,CAAsDb,KAAtD,EAA6D;AAC3D,MAAIA,KAAK,IAAIA,KAAK,CAACG,cAAN,CAAqBC,uBAAlC,EAA2D;AACzD,UAAMU,UAAU,GAAGd,KAAK,CAACY,WAAzB;AACA,UAAMG,UAAU,GAAGD,UAAU,GAAGvB,iBAAiB,CAACuB,UAAD,CAApB,GAAmC,IAAhE;AACAtB,IAAAA,gBAAgB,CAACuB,UAAD,EAAaV,+BAAb,EAA8CL,KAA9C,CAAhB;AACD;AACF;AAED;;;;;;;AAKA,SAASgB,oBAAT,CAA8BjB,IAA9B,EAAoCkB,gBAApC,EAAsDjB,KAAtD,EAA6D;AAC3D,MAAID,IAAI,IAAIC,KAAR,IAAiBA,KAAK,CAACG,cAAN,CAAqBD,gBAA1C,EAA4D;AAC1D,UAAMA,gBAAgB,GAAGF,KAAK,CAACG,cAAN,CAAqBD,gBAA9C;AACA,UAAMM,QAAQ,GAAGb,WAAW,CAACI,IAAD,EAAOG,gBAAP,CAA5B;;AACA,QAAIM,QAAJ,EAAc;AACZR,MAAAA,KAAK,CAACS,kBAAN,GAA2Bb,cAAc,CACvCI,KAAK,CAACS,kBADiC,EAEvCD,QAFuC,CAAzC;AAIAR,MAAAA,KAAK,CAACU,kBAAN,GAA2Bd,cAAc,CAACI,KAAK,CAACU,kBAAP,EAA2BX,IAA3B,CAAzC;AACD;AACF;AACF;AAED;;;;;;;AAKA,SAASmB,gCAAT,CAA0ClB,KAA1C,EAAiD;AAC/C,MAAIA,KAAK,IAAIA,KAAK,CAACG,cAAN,CAAqBD,gBAAlC,EAAoD;AAClDc,IAAAA,oBAAoB,CAAChB,KAAK,CAACY,WAAP,EAAoB,IAApB,EAA0BZ,KAA1B,CAApB;AACD;AACF;;AAED,OAAO,SAASmB,4BAAT,CAAsCC,MAAtC,EAA8C;AACnDvB,EAAAA,kBAAkB,CAACuB,MAAD,EAAST,kCAAT,CAAlB;AACD;AAED,OAAO,SAASU,sCAAT,CAAgDD,MAAhD,EAAwD;AAC7DvB,EAAAA,kBAAkB,CAACuB,MAAD,EAASP,4CAAT,CAAlB;AACD;AAED,OAAO,SAASS,8BAAT,CAAwCC,KAAxC,EAA+CC,KAA/C,EAAsDC,IAAtD,EAA4DC,EAA5D,EAAgE;AACrEjC,EAAAA,kBAAkB,CAACgC,IAAD,EAAOC,EAAP,EAAWV,oBAAX,EAAiCO,KAAjC,EAAwCC,KAAxC,CAAlB;AACD;AAED,OAAO,SAASG,0BAAT,CAAoCP,MAApC,EAA4C;AACjDvB,EAAAA,kBAAkB,CAACuB,MAAD,EAASF,gCAAT,CAAlB;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  getParentInstance,\n  traverseTwoPhase,\n  traverseEnterLeave,\n} from 'shared/ReactTreeTraversal';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nimport {getListener} from './EventPluginHub';\nimport accumulateInto from './accumulateInto';\nimport forEachAccumulated from './forEachAccumulated';\n\ntype PropagationPhases = 'bubbled' | 'captured';\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase: PropagationPhases) {\n  const registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (__DEV__) {\n    warningWithoutStack(inst, 'Dispatching inst must not be null');\n  }\n  const listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener,\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    const targetInst = event._targetInst;\n    const parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    const registrationName = event.dispatchConfig.registrationName;\n    const listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener,\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nexport function accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nexport function accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nexport function accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nexport function accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n"]},"metadata":{},"sourceType":"module"}