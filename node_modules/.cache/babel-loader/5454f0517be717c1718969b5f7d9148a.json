{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';\nimport { ImmediatePriority, UserBlockingPriority, NormalPriority, IdlePriority } from './SchedulerWithReactIntegration';\nexport const NoWork = 0; // TODO: Think of a better name for Never. The key difference with Idle is that\n// Never work can be committed in an inconsistent state without tearing the UI.\n// The main example is offscreen content, like a hidden subtree. So one possible\n// name is Offscreen. However, it also includes dehydrated Suspense boundaries,\n// which are inconsistent in the sense that they haven't finished yet, but\n// aren't visibly inconsistent because the server rendered HTML matches what the\n// hydrated tree would look like.\n\nexport const Never = 1; // Idle is slightly higher priority than Never. It must completely finish in\n// order to be consistent.\n\nexport const Idle = 2; // Continuous Hydration is a moving priority. It is slightly higher than Idle\n// and is used to increase priority of hover targets. It is increasing with\n// each usage so that last always wins.\n\nlet ContinuousHydration = 3;\nexport const Sync = MAX_SIGNED_31_BIT_INT;\nexport const Batched = Sync - 1;\nconst UNIT_SIZE = 10;\nconst MAGIC_NUMBER_OFFSET = Batched - 1; // 1 unit of expiration time represents 10ms.\n\nexport function msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);\n}\nexport function expirationTimeToMs(expirationTime) {\n  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n} // TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update\n// the names to reflect.\n\n\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\nexport function computeAsyncExpiration(currentTime) {\n  return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);\n}\nexport function computeSuspenseExpiration(currentTime, timeoutMs) {\n  // TODO: Should we warn if timeoutMs is lower than the normal pri expiration time?\n  return computeExpirationBucket(currentTime, timeoutMs, LOW_PRIORITY_BATCH_SIZE);\n} // We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\n//\n// If the main thread is being blocked so long that you hit the expiration,\n// it's a problem that could be solved with better scheduling.\n//\n// People will be more likely to notice this and fix it with the long\n// expiration time in development.\n//\n// In production we opt for better UX at the risk of masking scheduling\n// problems, by expiring fast.\n\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\nexport function computeInteractiveExpiration(currentTime) {\n  return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);\n}\nexport function computeContinuousHydrationExpiration(currentTime) {\n  // Each time we ask for a new one of these we increase the priority.\n  // This ensures that the last one always wins since we can't deprioritize\n  // once we've scheduled work already.\n  return ContinuousHydration++;\n}\nexport function inferPriorityFromExpirationTime(currentTime, expirationTime) {\n  if (expirationTime === Sync) {\n    return ImmediatePriority;\n  }\n\n  if (expirationTime === Never || expirationTime === Idle) {\n    return IdlePriority;\n  }\n\n  const msUntil = expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);\n\n  if (msUntil <= 0) {\n    return ImmediatePriority;\n  }\n\n  if (msUntil <= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {\n    return UserBlockingPriority;\n  }\n\n  if (msUntil <= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {\n    return NormalPriority;\n  } // TODO: Handle LowPriority\n  // Assume anything lower has idle priority\n\n\n  return IdlePriority;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberExpirationTime.js"],"names":["MAX_SIGNED_31_BIT_INT","ImmediatePriority","UserBlockingPriority","NormalPriority","IdlePriority","NoWork","Never","Idle","ContinuousHydration","Sync","Batched","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","expirationTime","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","LOW_PRIORITY_EXPIRATION","LOW_PRIORITY_BATCH_SIZE","computeAsyncExpiration","computeSuspenseExpiration","timeoutMs","HIGH_PRIORITY_EXPIRATION","__DEV__","HIGH_PRIORITY_BATCH_SIZE","computeInteractiveExpiration","computeContinuousHydrationExpiration","inferPriorityFromExpirationTime","msUntil"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';\n\nimport {\n  ImmediatePriority,\n  UserBlockingPriority,\n  NormalPriority,\n  IdlePriority,\n} from './SchedulerWithReactIntegration';\n\nexport type ExpirationTime = number;\n\nexport const NoWork = 0;\n// TODO: Think of a better name for Never. The key difference with Idle is that\n// Never work can be committed in an inconsistent state without tearing the UI.\n// The main example is offscreen content, like a hidden subtree. So one possible\n// name is Offscreen. However, it also includes dehydrated Suspense boundaries,\n// which are inconsistent in the sense that they haven't finished yet, but\n// aren't visibly inconsistent because the server rendered HTML matches what the\n// hydrated tree would look like.\nexport const Never = 1;\n// Idle is slightly higher priority than Never. It must completely finish in\n// order to be consistent.\nexport const Idle = 2;\n// Continuous Hydration is a moving priority. It is slightly higher than Idle\n// and is used to increase priority of hover targets. It is increasing with\n// each usage so that last always wins.\nlet ContinuousHydration = 3;\nexport const Sync = MAX_SIGNED_31_BIT_INT;\nexport const Batched = Sync - 1;\n\nconst UNIT_SIZE = 10;\nconst MAGIC_NUMBER_OFFSET = Batched - 1;\n\n// 1 unit of expiration time represents 10ms.\nexport function msToExpirationTime(ms: number): ExpirationTime {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);\n}\n\nexport function expirationTimeToMs(expirationTime: ExpirationTime): number {\n  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;\n}\n\nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET -\n    ceiling(\n      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  );\n}\n\n// TODO: This corresponds to Scheduler's NormalPriority, not LowPriority. Update\n// the names to reflect.\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\n\nexport function computeAsyncExpiration(\n  currentTime: ExpirationTime,\n): ExpirationTime {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n\nexport function computeSuspenseExpiration(\n  currentTime: ExpirationTime,\n  timeoutMs: number,\n): ExpirationTime {\n  // TODO: Should we warn if timeoutMs is lower than the normal pri expiration time?\n  return computeExpirationBucket(\n    currentTime,\n    timeoutMs,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n\n// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\n//\n// If the main thread is being blocked so long that you hit the expiration,\n// it's a problem that could be solved with better scheduling.\n//\n// People will be more likely to notice this and fix it with the long\n// expiration time in development.\n//\n// In production we opt for better UX at the risk of masking scheduling\n// problems, by expiring fast.\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\n\nexport function computeInteractiveExpiration(currentTime: ExpirationTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  );\n}\n\nexport function computeContinuousHydrationExpiration(\n  currentTime: ExpirationTime,\n) {\n  // Each time we ask for a new one of these we increase the priority.\n  // This ensures that the last one always wins since we can't deprioritize\n  // once we've scheduled work already.\n  return ContinuousHydration++;\n}\n\nexport function inferPriorityFromExpirationTime(\n  currentTime: ExpirationTime,\n  expirationTime: ExpirationTime,\n): ReactPriorityLevel {\n  if (expirationTime === Sync) {\n    return ImmediatePriority;\n  }\n  if (expirationTime === Never || expirationTime === Idle) {\n    return IdlePriority;\n  }\n  const msUntil =\n    expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);\n  if (msUntil <= 0) {\n    return ImmediatePriority;\n  }\n  if (msUntil <= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {\n    return UserBlockingPriority;\n  }\n  if (msUntil <= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {\n    return NormalPriority;\n  }\n\n  // TODO: Handle LowPriority\n\n  // Assume anything lower has idle priority\n  return IdlePriority;\n}\n"]},"metadata":{},"sourceType":"module"}