{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { accumulateTwoPhaseDispatches } from 'legacy-events/EventPropagators';\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport { TOP_BLUR, TOP_COMPOSITION_START, TOP_COMPOSITION_END, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_TEXT_INPUT, TOP_PASTE } from './DOMTopLevelEventTypes';\nimport { getData as FallbackCompositionStateGetData, initialize as FallbackCompositionStateInitialize, reset as FallbackCompositionStateReset } from './FallbackCompositionState';\nimport SyntheticCompositionEvent from './SyntheticCompositionEvent';\nimport SyntheticInputEvent from './SyntheticInputEvent';\nconst END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\n\nconst START_KEYCODE = 229;\nconst canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\nlet documentMode = null;\n\nif (canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n} // Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\n\n\nconst canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\n\nconst useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\nconst SPACEBAR_CODE = 32;\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE); // Events and their corresponding property names.\n\nconst eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  }\n}; // Track whether we've ever handled a keypress on the space key.\n\nlet hasSpaceKeypress = false;\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\n\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\n\n\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_START:\n      return eventTypes.compositionStart;\n\n    case TOP_COMPOSITION_END:\n      return eventTypes.compositionEnd;\n\n    case TOP_COMPOSITION_UPDATE:\n      return eventTypes.compositionUpdate;\n  }\n}\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\n\n\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;\n}\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\n\n\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_KEY_UP:\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n\n    case TOP_KEY_DOWN:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n\n    case TOP_KEY_PRESS:\n    case TOP_MOUSE_DOWN:\n    case TOP_BLUR:\n      // Events are not possible without cancelling IME.\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\n\n\nfunction getDataFromCustomEvent(nativeEvent) {\n  const detail = nativeEvent.detail;\n\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n\n  return null;\n}\n/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */\n\n\nfunction isUsingKoreanIME(nativeEvent) {\n  return nativeEvent.locale === 'ko';\n} // Track the current IME composition status, if any.\n\n\nlet isComposing = false;\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\n\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  let eventType;\n  let fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = FallbackCompositionStateInitialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = FallbackCompositionStateGetData();\n      }\n    }\n  }\n\n  const event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    const customData = getDataFromCustomEvent(nativeEvent);\n\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * @param {TopLevelType} topLevelType Number from `TopLevelType`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\n\n\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_END:\n      return getDataFromCustomEvent(nativeEvent);\n\n    case TOP_KEY_PRESS:\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      const which = nativeEvent.which;\n\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case TOP_TEXT_INPUT:\n      // Record the characters to be added to the DOM.\n      const chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to ignore it.\n\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\n\n\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      const chars = FallbackCompositionStateGetData();\n      FallbackCompositionStateReset();\n      isComposing = false;\n      return chars;\n    }\n\n    return null;\n  }\n\n  switch (topLevelType) {\n    case TOP_PASTE:\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n\n    case TOP_KEY_PRESS:\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n\n      return null;\n\n    case TOP_COMPOSITION_END:\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n\n    default:\n      return null;\n  }\n}\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\n\n\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  let chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  } // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n\n\n  if (!chars) {\n    return null;\n  }\n\n  const event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\n\n\nconst BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n    const composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n    const beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    if (composition === null) {\n      return beforeInput;\n    }\n\n    if (beforeInput === null) {\n      return composition;\n    }\n\n    return [composition, beforeInput];\n  }\n};\nexport default BeforeInputEventPlugin;","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/BeforeInputEventPlugin.js"],"names":["accumulateTwoPhaseDispatches","canUseDOM","TOP_BLUR","TOP_COMPOSITION_START","TOP_COMPOSITION_END","TOP_COMPOSITION_UPDATE","TOP_KEY_DOWN","TOP_KEY_PRESS","TOP_KEY_UP","TOP_MOUSE_DOWN","TOP_TEXT_INPUT","TOP_PASTE","getData","FallbackCompositionStateGetData","initialize","FallbackCompositionStateInitialize","reset","FallbackCompositionStateReset","SyntheticCompositionEvent","SyntheticInputEvent","END_KEYCODES","START_KEYCODE","canUseCompositionEvent","window","documentMode","document","canUseTextInputEvent","useFallbackCompositionData","SPACEBAR_CODE","SPACEBAR_CHAR","String","fromCharCode","eventTypes","beforeInput","phasedRegistrationNames","bubbled","captured","dependencies","compositionEnd","compositionStart","compositionUpdate","hasSpaceKeypress","isKeypressCommand","nativeEvent","ctrlKey","altKey","metaKey","getCompositionEventType","topLevelType","isFallbackCompositionStart","keyCode","isFallbackCompositionEnd","indexOf","getDataFromCustomEvent","detail","data","isUsingKoreanIME","locale","isComposing","extractCompositionEvent","targetInst","nativeEventTarget","eventType","fallbackData","event","getPooled","customData","getNativeBeforeInputChars","which","chars","getFallbackBeforeInputChars","char","length","extractBeforeInputEvent","BeforeInputEventPlugin","extractEvents","eventSystemFlags","composition"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {TopLevelType} from 'legacy-events/TopLevelEventTypes';\n\nimport {accumulateTwoPhaseDispatches} from 'legacy-events/EventPropagators';\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\n\nimport {\n  TOP_BLUR,\n  TOP_COMPOSITION_START,\n  TOP_COMPOSITION_END,\n  TOP_COMPOSITION_UPDATE,\n  TOP_KEY_DOWN,\n  TOP_KEY_PRESS,\n  TOP_KEY_UP,\n  TOP_MOUSE_DOWN,\n  TOP_TEXT_INPUT,\n  TOP_PASTE,\n} from './DOMTopLevelEventTypes';\nimport {\n  getData as FallbackCompositionStateGetData,\n  initialize as FallbackCompositionStateInitialize,\n  reset as FallbackCompositionStateReset,\n} from './FallbackCompositionState';\nimport SyntheticCompositionEvent from './SyntheticCompositionEvent';\nimport SyntheticInputEvent from './SyntheticInputEvent';\n\nconst END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nconst START_KEYCODE = 229;\n\nconst canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\n\nlet documentMode = null;\nif (canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nconst canUseTextInputEvent =\n  canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nconst useFallbackCompositionData =\n  canUseDOM &&\n  (!canUseCompositionEvent ||\n    (documentMode && documentMode > 8 && documentMode <= 11));\n\nconst SPACEBAR_CODE = 32;\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nconst eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture',\n    },\n    dependencies: [\n      TOP_COMPOSITION_END,\n      TOP_KEY_PRESS,\n      TOP_TEXT_INPUT,\n      TOP_PASTE,\n    ],\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture',\n    },\n    dependencies: [\n      TOP_BLUR,\n      TOP_COMPOSITION_END,\n      TOP_KEY_DOWN,\n      TOP_KEY_PRESS,\n      TOP_KEY_UP,\n      TOP_MOUSE_DOWN,\n    ],\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture',\n    },\n    dependencies: [\n      TOP_BLUR,\n      TOP_COMPOSITION_START,\n      TOP_KEY_DOWN,\n      TOP_KEY_PRESS,\n      TOP_KEY_UP,\n      TOP_MOUSE_DOWN,\n    ],\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture',\n    },\n    dependencies: [\n      TOP_BLUR,\n      TOP_COMPOSITION_UPDATE,\n      TOP_KEY_DOWN,\n      TOP_KEY_PRESS,\n      TOP_KEY_UP,\n      TOP_MOUSE_DOWN,\n    ],\n  },\n};\n\n// Track whether we've ever handled a keypress on the space key.\nlet hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (\n    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n    // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n    !(nativeEvent.ctrlKey && nativeEvent.altKey)\n  );\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_START:\n      return eventTypes.compositionStart;\n    case TOP_COMPOSITION_END:\n      return eventTypes.compositionEnd;\n    case TOP_COMPOSITION_UPDATE:\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_KEY_UP:\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case TOP_KEY_DOWN:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case TOP_KEY_PRESS:\n    case TOP_MOUSE_DOWN:\n    case TOP_BLUR:\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  const detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isUsingKoreanIME(nativeEvent) {\n  return nativeEvent.locale === 'ko';\n}\n\n// Track the current IME composition status, if any.\nlet isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget,\n) {\n  let eventType;\n  let fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = FallbackCompositionStateInitialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = FallbackCompositionStateGetData();\n      }\n    }\n  }\n\n  const event = SyntheticCompositionEvent.getPooled(\n    eventType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n  );\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    const customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelType} topLevelType Number from `TopLevelType`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType: TopLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_END:\n      return getDataFromCustomEvent(nativeEvent);\n    case TOP_KEY_PRESS:\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      const which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case TOP_TEXT_INPUT:\n      // Record the characters to be added to the DOM.\n      const chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to ignore it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType: TopLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (\n      topLevelType === TOP_COMPOSITION_END ||\n      (!canUseCompositionEvent &&\n        isFallbackCompositionEnd(topLevelType, nativeEvent))\n    ) {\n      const chars = FallbackCompositionStateGetData();\n      FallbackCompositionStateReset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case TOP_PASTE:\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case TOP_KEY_PRESS:\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case TOP_COMPOSITION_END:\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)\n        ? null\n        : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget,\n) {\n  let chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  const event = SyntheticInputEvent.getPooled(\n    eventTypes.beforeInput,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n  );\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nconst BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n    eventSystemFlags,\n  ) {\n    const composition = extractCompositionEvent(\n      topLevelType,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget,\n    );\n\n    const beforeInput = extractBeforeInputEvent(\n      topLevelType,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget,\n    );\n\n    if (composition === null) {\n      return beforeInput;\n    }\n\n    if (beforeInput === null) {\n      return composition;\n    }\n\n    return [composition, beforeInput];\n  },\n};\n\nexport default BeforeInputEventPlugin;\n"]},"metadata":{},"sourceType":"module"}