{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { runEventsInBatch } from 'legacy-events/EventBatching';\nimport { accumulateTwoPhaseDispatches } from 'legacy-events/EventPropagators';\nimport { enqueueStateRestore } from 'legacy-events/ReactControlledComponent';\nimport { batchedUpdates } from 'legacy-events/ReactGenericBatching';\nimport SyntheticEvent from 'legacy-events/SyntheticEvent';\nimport isTextInputElement from 'shared/isTextInputElement';\nimport { canUseDOM } from 'shared/ExecutionEnvironment';\nimport { TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE } from './DOMTopLevelEventTypes';\nimport getEventTarget from './getEventTarget';\nimport isEventSupported from './isEventSupported';\nimport { getNodeFromInstance } from '../client/ReactDOMComponentTree';\nimport { updateValueIfChanged } from '../client/inputValueTracking';\nimport { setDefaultValue } from '../client/ReactDOMInput';\nimport { disableInputAttributeSyncing } from 'shared/ReactFeatureFlags';\nconst eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  const event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);\n  event.type = 'change'; // Flag this event loop as needing state restore.\n\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\n\n\nlet activeElement = null;\nlet activeElementInst = null;\n/**\n * SECTION: handle `change` event\n */\n\nfunction shouldUseChangeEvent(elem) {\n  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  const event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  runEventsInBatch(event);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  const targetNode = getNodeFromInstance(targetInst);\n\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CHANGE) {\n    return targetInst;\n  }\n}\n/**\n * SECTION: handle `input` event\n */\n\n\nlet isInputEventSupported = false;\n\nif (canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\n\n\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\n\n\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\n\n\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === TOP_FOCUS) {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === TOP_BLUR) {\n    stopWatchingForValueChange();\n  }\n} // For IE8 and IE9.\n\n\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n/**\n * SECTION: handle `click` event\n */\n\n\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  const nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CLICK) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node) {\n  let state = node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  if (!disableInputAttributeSyncing) {\n    // If controlled, assign the value attribute to the current value on blur\n    setDefaultValue(node, 'number', node.value);\n  }\n}\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\n\n\nconst ChangeEventPlugin = {\n  eventTypes: eventTypes,\n  _isInputEventSupported: isInputEventSupported,\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n    const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n    let getTargetInstFunc, handleEventFunc;\n\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      const inst = getTargetInstFunc(topLevelType, targetInst);\n\n      if (inst) {\n        const event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    } // When blurring, set the value attribute for number inputs\n\n\n    if (topLevelType === TOP_BLUR) {\n      handleControlledInputBlur(targetNode);\n    }\n  }\n};\nexport default ChangeEventPlugin;","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/ChangeEventPlugin.js"],"names":["runEventsInBatch","accumulateTwoPhaseDispatches","enqueueStateRestore","batchedUpdates","SyntheticEvent","isTextInputElement","canUseDOM","TOP_BLUR","TOP_CHANGE","TOP_CLICK","TOP_FOCUS","TOP_INPUT","TOP_KEY_DOWN","TOP_KEY_UP","TOP_SELECTION_CHANGE","getEventTarget","isEventSupported","getNodeFromInstance","updateValueIfChanged","setDefaultValue","disableInputAttributeSyncing","eventTypes","change","phasedRegistrationNames","bubbled","captured","dependencies","createAndAccumulateChangeEvent","inst","nativeEvent","target","event","getPooled","type","activeElement","activeElementInst","shouldUseChangeEvent","elem","nodeName","toLowerCase","manualDispatchChangeEvent","runEventInBatch","getInstIfValueChanged","targetInst","targetNode","getTargetInstForChangeEvent","topLevelType","isInputEventSupported","document","documentMode","startWatchingForValueChange","attachEvent","handlePropertyChange","stopWatchingForValueChange","detachEvent","propertyName","handleEventsForInputEventPolyfill","getTargetInstForInputEventPolyfill","shouldUseClickEvent","getTargetInstForClickEvent","getTargetInstForInputOrChangeEvent","handleControlledInputBlur","node","state","_wrapperState","controlled","value","ChangeEventPlugin","_isInputEventSupported","extractEvents","nativeEventTarget","eventSystemFlags","window","getTargetInstFunc","handleEventFunc"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runEventsInBatch} from 'legacy-events/EventBatching';\nimport {accumulateTwoPhaseDispatches} from 'legacy-events/EventPropagators';\nimport {enqueueStateRestore} from 'legacy-events/ReactControlledComponent';\nimport {batchedUpdates} from 'legacy-events/ReactGenericBatching';\nimport SyntheticEvent from 'legacy-events/SyntheticEvent';\nimport isTextInputElement from 'shared/isTextInputElement';\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\n\nimport {\n  TOP_BLUR,\n  TOP_CHANGE,\n  TOP_CLICK,\n  TOP_FOCUS,\n  TOP_INPUT,\n  TOP_KEY_DOWN,\n  TOP_KEY_UP,\n  TOP_SELECTION_CHANGE,\n} from './DOMTopLevelEventTypes';\nimport getEventTarget from './getEventTarget';\nimport isEventSupported from './isEventSupported';\nimport {getNodeFromInstance} from '../client/ReactDOMComponentTree';\nimport {updateValueIfChanged} from '../client/inputValueTracking';\nimport {setDefaultValue} from '../client/ReactDOMInput';\nimport {disableInputAttributeSyncing} from 'shared/ReactFeatureFlags';\n\nconst eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture',\n    },\n    dependencies: [\n      TOP_BLUR,\n      TOP_CHANGE,\n      TOP_CLICK,\n      TOP_FOCUS,\n      TOP_INPUT,\n      TOP_KEY_DOWN,\n      TOP_KEY_UP,\n      TOP_SELECTION_CHANGE,\n    ],\n  },\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  const event = SyntheticEvent.getPooled(\n    eventTypes.change,\n    inst,\n    nativeEvent,\n    target,\n  );\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nlet activeElement = null;\nlet activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return (\n    nodeName === 'select' || (nodeName === 'input' && elem.type === 'file')\n  );\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  const event = createAndAccumulateChangeEvent(\n    activeElementInst,\n    nativeEvent,\n    getEventTarget(nativeEvent),\n  );\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  runEventsInBatch(event);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  const targetNode = getNodeFromInstance(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CHANGE) {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nlet isInputEventSupported = false;\nif (canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported =\n    isEventSupported('input') &&\n    (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === TOP_FOCUS) {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === TOP_BLUR) {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (\n    topLevelType === TOP_SELECTION_CHANGE ||\n    topLevelType === TOP_KEY_UP ||\n    topLevelType === TOP_KEY_DOWN\n  ) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  const nodeName = elem.nodeName;\n  return (\n    nodeName &&\n    nodeName.toLowerCase() === 'input' &&\n    (elem.type === 'checkbox' || elem.type === 'radio')\n  );\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CLICK) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node) {\n  let state = node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  if (!disableInputAttributeSyncing) {\n    // If controlled, assign the value attribute to the current value on blur\n    setDefaultValue(node, 'number', node.value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nconst ChangeEventPlugin = {\n  eventTypes: eventTypes,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n    eventSystemFlags,\n  ) {\n    const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n\n    let getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      const inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        const event = createAndAccumulateChangeEvent(\n          inst,\n          nativeEvent,\n          nativeEventTarget,\n        );\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === TOP_BLUR) {\n      handleControlledInputBlur(targetNode);\n    }\n  },\n};\n\nexport default ChangeEventPlugin;\n"]},"metadata":{},"sourceType":"module"}