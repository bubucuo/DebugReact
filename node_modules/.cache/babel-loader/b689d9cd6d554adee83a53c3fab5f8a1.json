{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { HostComponent, HostText, HostRoot, SuspenseComponent } from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\nimport { getParentSuspenseInstance } from './ReactDOMHostConfig';\nconst randomKey = Math.random().toString(36).slice(2);\nconst internalInstanceKey = '__reactInternalInstance$' + randomKey;\nconst internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\nconst internalContainerInstanceKey = '__reactContainere$' + randomKey;\nexport function precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\nexport function markContainerAsRoot(hostRoot, node) {\n  node[internalContainerInstanceKey] = hostRoot;\n}\nexport function unmarkContainerAsRoot(node) {\n  node[internalContainerInstanceKey] = null;\n}\nexport function isContainerMarkedAsRoot(node) {\n  return !!node[internalContainerInstanceKey];\n} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\n\nexport function getClosestInstanceFromNode(targetNode) {\n  let targetInst = targetNode[internalInstanceKey];\n\n  if (targetInst) {\n    // Don't return HostRoot or SuspenseComponent here.\n    return targetInst;\n  } // If the direct event target isn't a React owned DOM node, we need to look\n  // to see if one of its parents is a React owned DOM node.\n\n\n  let parentNode = targetNode.parentNode;\n\n  while (parentNode) {\n    // We'll check if this is a container root that could include\n    // React nodes in the future. We need to check this first because\n    // if we're a child of a dehydrated container, we need to first\n    // find that inner container before moving on to finding the parent\n    // instance. Note that we don't check this field on  the targetNode\n    // itself because the fibers are conceptually between the container\n    // node and the first child. It isn't surrounding the container node.\n    // If it's not a container, we check if it's an instance.\n    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\n\n    if (targetInst) {\n      // Since this wasn't the direct target of the event, we might have\n      // stepped past dehydrated DOM nodes to get here. However they could\n      // also have been non-React nodes. We need to answer which one.\n      // If we the instance doesn't have any children, then there can't be\n      // a nested suspense boundary within it. So we can use this as a fast\n      // bailout. Most of the time, when people add non-React children to\n      // the tree, it is using a ref to a child-less DOM node.\n      // Normally we'd only need to check one of the fibers because if it\n      // has ever gone from having children to deleting them or vice versa\n      // it would have deleted the dehydrated boundary nested inside already.\n      // However, since the HostRoot starts out with an alternate it might\n      // have one on the alternate so we need to check in case this was a\n      // root.\n      const alternate = targetInst.alternate;\n\n      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {\n        // Next we need to figure out if the node that skipped past is\n        // nested within a dehydrated boundary and if so, which one.\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\n\n        while (suspenseInstance !== null) {\n          // We found a suspense instance. That means that we haven't\n          // hydrated it yet. Even though we leave the comments in the\n          // DOM after hydrating, and there are boundaries in the DOM\n          // that could already be hydrated, we wouldn't have found them\n          // through this pass since if the target is hydrated it would\n          // have had an internalInstanceKey on it.\n          // Let's get the fiber associated with the SuspenseComponent\n          // as the deepest instance.\n          let targetSuspenseInst = suspenseInstance[internalInstanceKey];\n\n          if (targetSuspenseInst) {\n            return targetSuspenseInst;\n          } // If we don't find a Fiber on the comment, it might be because\n          // we haven't gotten to hydrate it yet. There might still be a\n          // parent boundary that hasn't above this one so we need to find\n          // the outer most that is known.\n\n\n          suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent\n          // host component also hasn't hydrated yet. We can return it\n          // below since it will bail out on the isMounted check later.\n        }\n      }\n\n      return targetInst;\n    }\n\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n\n  return null;\n}\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\n\nexport function getInstanceFromNode(node) {\n  const inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\n\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\n\nexport function getNodeFromInstance(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  } // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n\n\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\nexport function getFiberCurrentPropsFromNode(node) {\n  return node[internalEventHandlersKey] || null;\n}\nexport function updateFiberProps(node, props) {\n  node[internalEventHandlersKey] = props;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/client/ReactDOMComponentTree.js"],"names":["HostComponent","HostText","HostRoot","SuspenseComponent","invariant","getParentSuspenseInstance","randomKey","Math","random","toString","slice","internalInstanceKey","internalEventHandlersKey","internalContainerInstanceKey","precacheFiberNode","hostInst","node","markContainerAsRoot","hostRoot","unmarkContainerAsRoot","isContainerMarkedAsRoot","getClosestInstanceFromNode","targetNode","targetInst","parentNode","alternate","child","suspenseInstance","targetSuspenseInst","getInstanceFromNode","inst","tag","getNodeFromInstance","stateNode","getFiberCurrentPropsFromNode","updateFiberProps","props"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  HostComponent,\n  HostText,\n  HostRoot,\n  SuspenseComponent,\n} from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\n\nimport {getParentSuspenseInstance} from './ReactDOMHostConfig';\n\nconst randomKey = Math.random()\n  .toString(36)\n  .slice(2);\nconst internalInstanceKey = '__reactInternalInstance$' + randomKey;\nconst internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\nconst internalContainerInstanceKey = '__reactContainere$' + randomKey;\n\nexport function precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\nexport function markContainerAsRoot(hostRoot, node) {\n  node[internalContainerInstanceKey] = hostRoot;\n}\n\nexport function unmarkContainerAsRoot(node) {\n  node[internalContainerInstanceKey] = null;\n}\n\nexport function isContainerMarkedAsRoot(node) {\n  return !!node[internalContainerInstanceKey];\n}\n\n// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nexport function getClosestInstanceFromNode(targetNode) {\n  let targetInst = targetNode[internalInstanceKey];\n  if (targetInst) {\n    // Don't return HostRoot or SuspenseComponent here.\n    return targetInst;\n  }\n  // If the direct event target isn't a React owned DOM node, we need to look\n  // to see if one of its parents is a React owned DOM node.\n  let parentNode = targetNode.parentNode;\n  while (parentNode) {\n    // We'll check if this is a container root that could include\n    // React nodes in the future. We need to check this first because\n    // if we're a child of a dehydrated container, we need to first\n    // find that inner container before moving on to finding the parent\n    // instance. Note that we don't check this field on  the targetNode\n    // itself because the fibers are conceptually between the container\n    // node and the first child. It isn't surrounding the container node.\n    // If it's not a container, we check if it's an instance.\n    targetInst =\n      parentNode[internalContainerInstanceKey] ||\n      parentNode[internalInstanceKey];\n    if (targetInst) {\n      // Since this wasn't the direct target of the event, we might have\n      // stepped past dehydrated DOM nodes to get here. However they could\n      // also have been non-React nodes. We need to answer which one.\n\n      // If we the instance doesn't have any children, then there can't be\n      // a nested suspense boundary within it. So we can use this as a fast\n      // bailout. Most of the time, when people add non-React children to\n      // the tree, it is using a ref to a child-less DOM node.\n      // Normally we'd only need to check one of the fibers because if it\n      // has ever gone from having children to deleting them or vice versa\n      // it would have deleted the dehydrated boundary nested inside already.\n      // However, since the HostRoot starts out with an alternate it might\n      // have one on the alternate so we need to check in case this was a\n      // root.\n      const alternate = targetInst.alternate;\n      if (\n        targetInst.child !== null ||\n        (alternate !== null && alternate.child !== null)\n      ) {\n        // Next we need to figure out if the node that skipped past is\n        // nested within a dehydrated boundary and if so, which one.\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\n        while (suspenseInstance !== null) {\n          // We found a suspense instance. That means that we haven't\n          // hydrated it yet. Even though we leave the comments in the\n          // DOM after hydrating, and there are boundaries in the DOM\n          // that could already be hydrated, we wouldn't have found them\n          // through this pass since if the target is hydrated it would\n          // have had an internalInstanceKey on it.\n          // Let's get the fiber associated with the SuspenseComponent\n          // as the deepest instance.\n          let targetSuspenseInst = suspenseInstance[internalInstanceKey];\n          if (targetSuspenseInst) {\n            return targetSuspenseInst;\n          }\n          // If we don't find a Fiber on the comment, it might be because\n          // we haven't gotten to hydrate it yet. There might still be a\n          // parent boundary that hasn't above this one so we need to find\n          // the outer most that is known.\n          suspenseInstance = getParentSuspenseInstance(suspenseInstance);\n          // If we don't find one, then that should mean that the parent\n          // host component also hasn't hydrated yet. We can return it\n          // below since it will bail out on the isMounted check later.\n        }\n      }\n      return targetInst;\n    }\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nexport function getInstanceFromNode(node) {\n  const inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\n  if (inst) {\n    if (\n      inst.tag === HostComponent ||\n      inst.tag === HostText ||\n      inst.tag === SuspenseComponent ||\n      inst.tag === HostRoot\n    ) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nexport function getNodeFromInstance(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nexport function getFiberCurrentPropsFromNode(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nexport function updateFiberProps(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n"]},"metadata":{},"sourceType":"module"}